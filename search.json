[{"title":"架构设计-缓存","url":"/2022/07/31/architecture/service-cache/","content":"<blockquote>\n<p>缓存的设计</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"为什么使用缓存\">为什么使用缓存</h2>\n<p>为了提高数据读取或写入速度</p>\n<h2 id=\"缓存的类型\">缓存的类型</h2>\n<p>硬件缓存，如cpu的L1、L2、L3 cache</p>\n<p>软件缓存，如内存缓存、数据库缓存、客户端缓存</p>\n<p>本文只对内存缓存做介绍</p>\n<h2 id=\"内存缓存的形式\">内存缓存的形式</h2>\n<p>通常以 k-v 对的形式存在</p>\n<p>key 是缓存的唯一标识，避免碰撞，对敏感数据要进行脱敏（SHA-2）</p>\n<p>value 是缓存的数据</p>\n<h2 id=\"缓存的更新机制\">缓存的更新机制</h2>\n<h3 id=\"时效性更新机制\">时效性更新机制</h3>\n<p>为缓存的key设置过期时间，到达过期时间，被动删除；</p>\n<p>写进程：只写数据提供方，不理会缓存</p>\n<p>读进程：先读缓存，如果缓存中没有，到数据库读，再写入缓存</p>\n<p>存在问题：放弃了缓存与数据库的实时一致性</p>\n<p>适用场景：对实时性要求不高的场景，如点赞数、收藏人数</p>\n<h3 id=\"主动更新机制\">主动更新机制</h3>\n<h4 id=\"双写机制\">双写机制</h4>\n<h5 id=\"双写方案的比较\">双写方案的比较</h5>\n<table>\n<thead>\n<tr class=\"header\">\n<th>方案</th>\n<th>操作</th>\n<th>存在问题</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>1</td>\n<td>先更新缓存，再更新数据库</td>\n<td>更新数据库失败，会导致数据不一致</td>\n</tr>\n<tr class=\"even\">\n<td>2</td>\n<td>先更新数据库，再更新缓存</td>\n<td>并发写操作时，可能导致数据不一致</td>\n</tr>\n<tr class=\"odd\">\n<td>3</td>\n<td>删除缓存，更新数据库</td>\n<td>可能读到旧数据</td>\n</tr>\n<tr class=\"even\">\n<td>4</td>\n<td>更新数据库，再删除缓存</td>\n<td>较低概率读到旧数据</td>\n</tr>\n</tbody>\n</table>\n<p>对于方案3，4，可以采用延时双删，降低数据不一致的概率</p>\n<h5 id=\"双写策略的实现\">双写策略的实现</h5>\n<p>方法一：在代码中实现</p>\n<p>方法二：将删除缓存的功能抽离为单独的服务</p>\n<h4 id=\"readwrite-through\">Read/Write Through</h4>\n<p>调用方只与缓存交互</p>\n<p>写进程：直接将数据写入缓存，由缓存服务写到数据库，这两个写操作在一个事务中完成</p>\n<p>读进程：直接从缓存中读数据，如果没有数据，由缓存服务从数据库中读取，返回给调用方</p>\n<p>优点：程序只与缓存交互，代码简单</p>\n<p>缺点：不能忍受数据不一致</p>\n<h4 id=\"write-behind\">Write Behind</h4>\n<p><code>Write-Behind</code>和<code>Write-Through</code>在“调用方只和缓存交互”这一点上很相似。不同点在于<code>Write-Through</code>会把数据立即写入数据库中，而<code>Write-Behind</code>会异步地把数据一起写入数据库，比如通过消息队列；</p>\n<p>优点：提高了写操作的效率，追求最终一致性</p>\n<p>缺点：牺牲了实时一致性</p>\n<h2 id=\"缓存的清理机制\">缓存的清理机制</h2>\n<p>由于内存空间有限，不会将数据库全部数据都放到缓存中，需要将一些不常用的数据从缓存中移除，以提高命中率</p>\n<h3 id=\"时效性清理\">时效性清理</h3>\n<p>为key设置过期时间，自动清理</p>\n<p>存在问题：不会区分缓存的重要性，一视同仁</p>\n<h3 id=\"数目阈值清理\">数目阈值清理</h3>\n<p>思想：将缓存放入一个队列中，按照某种策略（分数）排序，当队列满时，将分数低的缓存出队</p>\n<p>FIFO：First in First out，先进先出</p>\n<p>LRU：Least Recently Used，最近最少使用</p>\n<p>LFU：Least Frequently Used，最不经常使用</p>\n<p>存在问题：当队列满后，每次都数据进入都需要清理</p>\n<h3 id=\"优先级清理\">优先级清理</h3>\n<p>指定缓存的类型，比如对缓存设置重要级别，当内存不足时，不重要的缓存会被优先清理；如JVM中，强引用指向的缓存不会被清理，弱引用指向的缓存会被清理</p>\n<blockquote>\n<p>实际生产中，一般采用时效性+数目阈值 结合的方式来清理缓存</p>\n</blockquote>\n<h2 id=\"缓存失效的问题\">缓存失效的问题</h2>\n<h3 id=\"缓存击穿\">缓存击穿</h3>\n<p>一个非常热点的key，在大量并发集中访问，一旦该key由于过期被清理，大量并发会请求到数据库</p>\n<p>解决方案：对热点key不设置过期时间，由后台主动更新key的value（做好互斥）</p>\n<h3 id=\"缓存雪崩\">缓存雪崩</h3>\n<p>大量缓存同时失效，只在存在时效性清理机制的情况下存在缓存雪崩</p>\n<p>解决方案：为缓存的过期时间设置为固定值 +\n随机数，让缓存失效的时间分布尽量均匀，避免同时失效</p>\n<h3 id=\"缓存穿透\">缓存穿透</h3>\n<p>缓存与数据库中都没有的数据，每次都会请求数据库，如果有大量这样的请求同时涌入，对数据库造成巨大压力</p>\n<h4 id=\"解决方案\">解决方案</h4>\n<h5 id=\"缓存空对象\">缓存空对象</h5>\n<p>当缓存和数据库中都查询不到key的数据时，将&lt;key:空对象&gt;写入缓存，下次请求该key可以从缓存中查询空对象</p>\n<p>存在的问题：</p>\n<ol type=\"1\">\n<li><p>如果有大量缓存穿透，空对象会占用大量内存空间</p>\n<ol start=\"2\" type=\"1\">\n<li>可能有数据不一致的情况（key在数据库存在对象，缓存中是空对象）</li>\n</ol></li>\n</ol>\n<h5 id=\"构建key的白名单\">构建key的白名单</h5>\n<p>将数据库中的key放到白名单中，如果请求的key不在白名单中，则不在数据库中，直接返回空对象；</p>\n<p>但是这种方式占用的内存空间较大，当key数量很大时，查询效率会降低；可以通过布隆过滤器的思路进行优化，节省空间，提高查询效率</p>\n<h2 id=\"写缓存\">写缓存</h2>\n<p>上面介绍的是调用方来读数据时的缓存应用，当调用方大量并发的写，通过在调用方和数据库之间加入写缓存，防止直接将数据写入数据库，如消息队列</p>\n","categories":["架构设计"],"tags":["缓存"]},{"title":"my-healthy","url":"/2022/11/23/body/my-healthy/","content":"<blockquote>\n<p>助眠（不是煮面）小妙招</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>送给我喜欢的人</p>\n</blockquote>\n<h3 id=\"印堂穴\">印堂穴</h3>\n<figure>\n<img src=\"/images/body/image-20221124000231780.png\" alt=\"image-20221124000231780\">\n<figcaption aria-hidden=\"true\">image-20221124000231780</figcaption>\n</figure>\n<p>适当按摩印堂穴本身具有安神的作用，在睡觉前适当按摩，对头痛，失眠等情况有改善效果，不过，在按摩的过程中力度要适宜，不要太过用力</p>\n<h3 id=\"三阴交穴\">三阴交穴</h3>\n<figure>\n<img src=\"/images/body/image-20221124001037110.png\" alt=\"image-20221124001037110\">\n<figcaption aria-hidden=\"true\">image-20221124001037110</figcaption>\n</figure>\n<figure>\n<img src=\"/images/body/image-20221124001340209.png\" alt=\"image-20221124001340209\">\n<figcaption aria-hidden=\"true\">image-20221124001340209</figcaption>\n</figure>\n<p>三阴交穴用途比较广泛，适当按摩该穴位对肝脏，肾脏功能提高有帮助，还能达到健脾的作用。定期按摩，适当按摩，会发现夜间睡得香，不容易入睡困难或者半夜醒来</p>\n<h3 id=\"安眠穴\">安眠穴</h3>\n<figure>\n<img src=\"/images/body/image-20221124002002671.png\" alt=\"image-20221124002002671\">\n<figcaption aria-hidden=\"true\">image-20221124002002671</figcaption>\n</figure>\n<p>适当按摩安眠穴可以达到安神，定气的功效，促进头部的血液循环后提高睡眠质量</p>\n<h3 id=\"足三里穴\">足三里穴</h3>\n<figure>\n<img src=\"/images/body/image-20221124002143152.png\" alt=\"image-20221124002143152\">\n<figcaption aria-hidden=\"true\">image-20221124002143152</figcaption>\n</figure>\n<p>足三里穴作用可不单纯提高睡眠质量，还能调养气血，滋养脾胃，平时可以养成泡脚这种好习惯，在泡完脚后按摩自己的足三里穴，每次按摩几分钟，会发现正常产生困意，身体有疲倦感，此时及时去入睡同样可以有高质量睡眠。</p>\n<h3 id=\"神门穴\">神门穴</h3>\n<figure>\n<img src=\"/images/body/image-20221124002514917.png\" alt=\"image-20221124002514917\">\n<figcaption aria-hidden=\"true\">image-20221124002514917</figcaption>\n</figure>\n<p>神门穴位于腕部，腕掌侧横纹尺侧端，尺侧腕屈肌腱的桡侧凹陷处，主治失眠、健忘、心烦、晕车等病症。</p>\n<h3 id=\"后腰\">后腰</h3>\n<p>双手掌搓热，往后伸，掌心搓后腰两侧</p>\n<figure>\n<img src=\"/images/body/image-20221124003434241.png\" alt=\"image-20221124003434241\">\n<figcaption aria-hidden=\"true\">image-20221124003434241</figcaption>\n</figure>\n<h3 id=\"reference\">Reference：</h3>\n<p>https://m.baidu.com/bh/m/detail/ar_4688647693666834144</p>\n<p>https://m.baidu.com/bh/m/detail/ar_10023157993195093972</p>\n","categories":["养生"],"tags":["养生"]},{"title":"算法-线性表","url":"/2022/04/21/algorithm/array/","content":"<blockquote>\n<p>线性表相关算法题</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>给定一个有序数组arr，代表坐落在X轴上的点，给定一个正数K，代表绳子的长度，返回绳子最多压中几个点，即使绳子边缘处盖住点也算盖住？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxCoveredPoint</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> K)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">maxValue</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 滑动窗口：坐指针从左到右，右指针找到距离左指针最远的点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; l &lt; arr.length; l++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r &lt; arr.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[r] - arr[l] &gt; K) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxValue = Math.max(r - l + <span class=\"number\">1</span>, maxValue);</span><br><span class=\"line\">            r ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给定一个文件目录的路径，写一个函数统计这个目录下所有的文件数量并返回，隐藏文件也算，但是文件夹不算</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getFileNumber</span><span class=\"params\">(String path)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(path);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root.exists()) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root.isDirectory() &amp;&amp; !root.isFile()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.isFile()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack&lt;File&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">    stack.add(root);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">fileNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">top</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (File next : Objects.requireNonNull(top.listFiles())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next.isFile()) &#123;</span><br><span class=\"line\">                fileNum ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next.isDirectory()) &#123;</span><br><span class=\"line\">                stack.push(next);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fileNum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给定数组hard和money，长度都为N，hard[i]表示i号工作的难度，\nmoney[i]表示i号工作的收入\n给定数组ability，长度都为M，ability[j]表示j号人的能力，每一号工作，都可以提供无数的岗位，难度和收入都一样\n但是人的能力必须&gt;=这份工作的难度，才能上班。返回一个长度为M的数组ans，ans[j]表示j号人能获得的最好收入</p>\n<p>有序表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>[] bestJob(<span class=\"type\">int</span>[] hard, <span class=\"type\">int</span>[] money, <span class=\"type\">int</span>[] ability) &#123;</span><br><span class=\"line\">    Job[] jobList = <span class=\"keyword\">new</span> <span class=\"title class_\">Job</span>[hard.length];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; hard.length; i++) &#123;</span><br><span class=\"line\">        jobList[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Job</span>(hard[i], money[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 先按难度升序排序，再按工资降序排序</span></span><br><span class=\"line\">    Arrays.sort(jobList);</span><br><span class=\"line\">    <span class=\"comment\">// 构建有序表</span></span><br><span class=\"line\">    TreeMap&lt;Integer, Integer&gt; treeMap = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;&gt;();</span><br><span class=\"line\">    treeMap.put(jobList[<span class=\"number\">0</span>].hard, jobList[<span class=\"number\">0</span>].money);</span><br><span class=\"line\">    <span class=\"type\">Job</span> <span class=\"variable\">base</span> <span class=\"operator\">=</span> jobList[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 获取：1.相同难度工资高的工作；2.难度增大工资高的工作</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; jobList.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jobList[i].hard &gt; base.hard &amp;&amp; jobList[i].money &gt; base.money) &#123;</span><br><span class=\"line\">            treeMap.put(jobList[i].hard, jobList[i].money);</span><br><span class=\"line\">            base = jobList[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 取能力&lt;=hard[i]且离hard[i]最近的工作</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[ability.length];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; ability.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> treeMap.floorKey(ability[i]);</span><br><span class=\"line\">        ans[i] = key != <span class=\"literal\">null</span> ? treeMap.get(key) : <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Job</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Comparable</span>&lt;Job&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> hard;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> money;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Job</span><span class=\"params\">(<span class=\"type\">int</span> hard, <span class=\"type\">int</span> money)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.hard = hard;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.money = money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compareTo</span><span class=\"params\">(Job o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.hard - o.hard != <span class=\"number\">0</span> ? <span class=\"built_in\">this</span>.hard - o.hard : - <span class=\"built_in\">this</span>.money + o.money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Job&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;hard=&quot;</span> + hard +</span><br><span class=\"line\">                <span class=\"string\">&quot;, money=&quot;</span> + money +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给定一个数组arr，只能对arr中的一个子数组排序，但是想让arr整体都有序，返回满足这一设定的子数组中最短的是多长</p>\n<p>https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minSortLength</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> arr.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">    <span class=\"comment\">// 从左向右找必须要排序的右端点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如何找：如果arr[i]小于已经发现的最大值，则arr[i]必须得调整位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; max) &#123;</span><br><span class=\"line\">            left = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        max = Math.max(max, arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"comment\">// 从右向左找必须要排序的左端点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> arr.length-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> ; i--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如何找：如果arr[i]大于已经发现的最小值，则arr[i]必须得调整位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &gt; min) &#123;</span><br><span class=\"line\">            right = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        min = Math.min(min, arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(<span class=\"number\">0</span>, left - right + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给定一个二维数组matrix，你可以从任何位置出发，走向上、下、左、右四个方向，返回能走出来的最长的递增链长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">longestIncreasingPath</span><span class=\"params\">(<span class=\"type\">int</span>[][] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">M</span> <span class=\"operator\">=</span> arr[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] cache = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[N][M];</span><br><span class=\"line\">    \t<span class=\"comment\">// 遍历每个位置，求最长递增链长度的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; M; j++) &#123;</span><br><span class=\"line\">                ans = Math.max(ans, process(arr, i, j, cache));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 求从位置i, j出发的最长递增链的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">process</span><span class=\"params\">(<span class=\"type\">int</span>[][] arr, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j, <span class=\"type\">int</span>[][] cache)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache[i][j] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">up</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, down = <span class=\"number\">0</span>, left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; arr[i][j] &lt; arr[i-<span class=\"number\">1</span>][j]) &#123;</span><br><span class=\"line\">            up = process(arr, i - <span class=\"number\">1</span>, j, cache);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; arr.length &amp;&amp; arr[i][j] &lt; arr[i+<span class=\"number\">1</span>][j]) &#123;</span><br><span class=\"line\">            down = process(arr, i + <span class=\"number\">1</span>, j, cache);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; arr[i][j] &lt; arr[i][j-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            left = process(arr, i, j - <span class=\"number\">1</span>, cache);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; arr[<span class=\"number\">0</span>].length &amp;&amp; arr[i][j] &lt; arr[i][j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            right = process(arr, i, j + <span class=\"number\">1</span>, cache);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cache[i][j] = Math.max(Math.max(up, down), Math.max(left, right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cache[i][j];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>给定两个非负数组x和hp，长度都是N，再给定一个正数range，x有序，x[i]表示i号怪兽在x轴上的位置，hp[i]表示i号怪兽的血量，再给定一个正数range，表示如果法师释放技能的范围长度，被打到的每只怪兽损失1点血量。返回要把所有怪兽血量清空，至少需要释放多少次AOE技能？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">AOEGreedy</span><span class=\"params\">(<span class=\"type\">int</span>[] x, <span class=\"type\">int</span>[] hp, <span class=\"type\">int</span> range)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> x.length;</span><br><span class=\"line\">        <span class=\"comment\">// 元素i为AOE攻击最左侧点时，能否覆盖的最右侧元素位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] cover = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (x[j] - x[i] &lt;= range) &#123;</span><br><span class=\"line\">                    cover[i] = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hp[i] &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">hitTime</span> <span class=\"operator\">=</span> hp[i];</span><br><span class=\"line\">            <span class=\"comment\">// 将距离x[i] range 范围内的 hp 值减 hitTime</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i; j &lt;= cover[i]; j++) &#123;</span><br><span class=\"line\">                hp[j] -= hitTime;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans += hitTime;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target，请问最后算出target的方法数</p>\n<p>https://leetcode-cn.com/problems/target-sum/</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findTargetSumWays</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> process(nums, <span class=\"number\">0</span>, target, cache);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">process</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> index, <span class=\"type\">int</span> rest, Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; cache)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读缓存判断是否命中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.containsKey(index) &amp;&amp; cache.get(index).containsKey(rest)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache.get(index).get(rest);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 最后，如果rest为0，说明正好算出target</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == arr.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rest == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> process(arr, index + <span class=\"number\">1</span>, rest - arr[index], cache) + </span><br><span class=\"line\">                process(arr, index + <span class=\"number\">1</span>, rest + arr[index], cache);</span><br><span class=\"line\">        <span class=\"comment\">// 更新缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cache.containsKey(index)) &#123;</span><br><span class=\"line\">            cache.put(index, <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cache.get(index).put(rest, ans);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化：转化为01背包</p>\n<figure>\n<img src=\"/images/algorithm/微信图片_20220419023158.jpg\" alt=\"微信图片_20220419023158\">\n<figcaption aria-hidden=\"true\">微信图片_20220419023158</figcaption>\n</figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findTargetNum</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 都转为正数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                arr[i] = -arr[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sum += arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 所有数字和小于target返回0</span></span><br><span class=\"line\">        <span class=\"comment\">// 所有数字和与target奇偶性不一致返回0</span></span><br><span class=\"line\">        <span class=\"comment\">// 转为01背包问题</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum &lt; target || ((target &amp; <span class=\"number\">1</span>) ^ (sum &amp; <span class=\"number\">1</span>)) != <span class=\"number\">0</span> ? <span class=\"number\">0</span> : subset(arr, (target + sum) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">subset</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> s)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>][s + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt;= s; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - arr[i - <span class=\"number\">1</span>] &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dp[i][j] += dp[i - <span class=\"number\">1</span>][j - arr[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n][s];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化：动态规划的空间压缩（递推公式只与上一行有关，可用一维数组代替二维数组）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">subset</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> s)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (s &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[s + <span class=\"number\">1</span>];</span><br><span class=\"line\">\tdp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> n : arr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> s; i &gt;= n; i--) &#123;</span><br><span class=\"line\">\t\t\tdp[i] += dp[i - n];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[s];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回一个数组中子数组最大累加和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArraySum</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr.length];</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">maxSum</span> <span class=\"operator\">=</span> dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        dp[i] = Math.max(dp[i-<span class=\"number\">1</span>] + arr[i], arr[i]);</span><br><span class=\"line\">        maxSum = Math.max(maxSum, dp[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化：空间压缩（只用到其左侧位置）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArraySum2</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">dp</span> <span class=\"operator\">=</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">maxSum</span> <span class=\"operator\">=</span> dp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        dp = Math.max(dp + arr[i], arr[i]);</span><br><span class=\"line\">        maxSum = Math.max(maxSum, dp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回一个数组中所选数字不能相邻的情况下最大子序列累加和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">subArrMaxSumNotAdjacent</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr.length == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.max(arr[<span class=\"number\">0</span>], arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i]表示0-i范围内的最大不相邻子序列累加和</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr.length];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = arr[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            dp[i] = Math.max(Math.max(dp[i-<span class=\"number\">2</span>] + arr[i], arr[i]), dp[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[arr.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给你一个整数数组 nums 和一个目标值 goal 。你需要从 nums\n中选出一个子序列，使子序列元素总和最接近 goal\n。也就是说，如果子序列元素和为 sum ，你需要 最小化绝对差 abs(sum - goal)\n。返回 abs(sum - goal) 可能的 最小值\n。注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。\n链接：https://leetcode-cn.com/problems/closest-subsequence-sum</p>\n<figure>\n<img src=\"/images/algorithm/20220428014442.jpg\" alt=\"微信图片_20220428014442\">\n<figcaption aria-hidden=\"true\">微信图片_20220428014442</figcaption>\n</figure>\n<p>分治思路：将n个数字分为2份，每份分别计算所有可能的组合情况的序列和，求第一份中最接近的，第二份中最接近的，两份中取两个相加最接近的（先取左侧一个数字a，计算goal-a，在右侧二分查找），再比较三者哪个最接近</p>\n<p>Think：分3，4，5...份行不行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>给定一个有序数组arr，其中值可能为正、负、0。返回arr中每个数都平方之后不同的结果有多少种？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 给定一个有序数组arr，其中值可能为正、负、0。返回arr中每个数都平方之后不同的结果有多少种？</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">power2Diff1</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Set&lt;Integer&gt; powers = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            powers.add(Math.abs(arr[i]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> powers.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">power2Diff2</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">L</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">R</span> <span class=\"operator\">=</span> arr.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">LAbs</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">RAbs</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (L &lt;= R) &#123;</span><br><span class=\"line\">            LAbs = Math.abs(arr[L]);</span><br><span class=\"line\">            RAbs = Math.abs(arr[R]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (LAbs &lt; RAbs) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (R &gt;= <span class=\"number\">0</span> &amp;&amp; Math.abs(arr[R]) == RAbs) &#123;</span><br><span class=\"line\">                    R--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (LAbs &gt; RAbs) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (L &lt; arr.length &amp;&amp; Math.abs(arr[L]) == LAbs) &#123;</span><br><span class=\"line\">                    L++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (L &lt; arr.length &amp;&amp; Math.abs(arr[L]) == LAbs) &#123;</span><br><span class=\"line\">                    L++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (R &gt;= <span class=\"number\">0</span> &amp;&amp; Math.abs(arr[R]) == RAbs) &#123;</span><br><span class=\"line\">                    R--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给定一个数组arr，先递减然后递增，返回arr中有多少个不同的数字？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">diffNum</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">L</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">R</span> <span class=\"operator\">=</span> N-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">diffNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (L &lt;= R) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">lvalue</span> <span class=\"operator\">=</span> arr[L];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rvalue</span> <span class=\"operator\">=</span> arr[R];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lvalue &lt; rvalue) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (R &gt;= <span class=\"number\">0</span> &amp;&amp; arr[R] == rvalue) &#123;</span><br><span class=\"line\">                    R--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lvalue &gt; rvalue) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (L &lt; N &amp;&amp; arr[L] == lvalue) &#123;</span><br><span class=\"line\">                    L++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (L &lt; N &amp;&amp; arr[L] == lvalue) &#123;</span><br><span class=\"line\">                    L++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (R &gt;= <span class=\"number\">0</span> &amp;&amp; arr[R] == rvalue) &#123;</span><br><span class=\"line\">                    R--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            diffNum++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> diffNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["algorithm"],"tags":["arrays"]},{"title":"算法-二叉树","url":"/2022/04/18/algorithm/binary-tree/","content":"<blockquote>\n<p>二叉树系列算法题</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>给定三个参数，二叉树的头节点head，树上某个节点target，正数K。从target开始，可以向上走或者向下走，返回与target的距离是K的所有节点</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">solution</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> value;</span><br><span class=\"line\">        Node left;</span><br><span class=\"line\">        Node right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构建树中节点的父节点关系</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> head</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> hashmap</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HashMap&lt;Node, Node&gt; <span class=\"title function_\">buildParentMap</span><span class=\"params\">(Node head)</span> &#123;</span><br><span class=\"line\">        HashMap&lt;Node, Node&gt; parentMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        Queue&lt;Node&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        queue.add(head);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">top</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (top.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                parentMap.put(top.left, top);</span><br><span class=\"line\">                queue.add(top.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (top.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                parentMap.put(top.right, top);</span><br><span class=\"line\">                queue.add(top.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parentMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Node&gt; <span class=\"title function_\">distinctKNodes</span><span class=\"params\">(Node head, Node target, <span class=\"type\">int</span> K)</span> &#123;</span><br><span class=\"line\">        HashMap&lt;Node, Node&gt; parentMap = buildParentMap(head);</span><br><span class=\"line\">        HashSet&lt;Node&gt; visited = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        Queue&lt;Node&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        queue.add(target);</span><br><span class=\"line\">        visited.add(target);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; K; i++) &#123;</span><br><span class=\"line\">            List&lt;Node&gt; turn = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"type\">Node</span> <span class=\"variable\">top</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (top.left != <span class=\"literal\">null</span> &amp;&amp; !visited.contains(top.left)) &#123;</span><br><span class=\"line\">                    turn.add(top.left);</span><br><span class=\"line\">                    visited.add(top.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (top.right != <span class=\"literal\">null</span> &amp;&amp; !visited.contains(top.right)) &#123;</span><br><span class=\"line\">                    turn.add(top.right);</span><br><span class=\"line\">                    visited.add(top.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (parentMap.containsKey(top) &amp;&amp; !visited.contains(parentMap.get(top))) &#123;</span><br><span class=\"line\">                    turn.add(parentMap.get(top));</span><br><span class=\"line\">                    visited.add(parentMap.get(top));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 将一轮遍历的节点添加到队列中</span></span><br><span class=\"line\">            queue.addAll(turn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue.stream().toList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>已知一棵搜索二叉树上没有重复值的节点，现在有一个数组arr，是这棵搜索二叉树先序遍历的结果，请根据arr生成整棵树并返回头节点</p>\n<p>https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">bstFromPreorder</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> generateTree(arr, <span class=\"number\">0</span>, arr.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">generateTree</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length &lt; end + <span class=\"number\">1</span> || start &gt; end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(arr[start]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 头节点为先序遍历的第一个值</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(arr[start]);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"comment\">// 找到head的左、右孩子节点在先序遍历中的位置</span></span><br><span class=\"line\">        <span class=\"comment\">// head后第一个小于head.value的为左孩子，第一个大于head.value的为右孩子，没有找到为空</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">leftIndex</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rightIndex</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt;= end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] &lt; arr[start] &amp;&amp; leftIndex == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                leftIndex = i;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[i] &gt; arr[start]) &#123;</span><br><span class=\"line\">                rightIndex = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 构建以head为根节点的树结构</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftIndex != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            head.left = generateTree(arr, leftIndex, rightIndex != <span class=\"number\">0</span> ? rightIndex-<span class=\"number\">1</span> : end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rightIndex != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            head.right = generateTree(arr, rightIndex, end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>优化generateTree方法（简洁，但不好理解）：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">generateTree</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (start &gt; end) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 头节点为先序遍历的第一个值</span></span><br><span class=\"line\">       <span class=\"type\">TreeNode</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(arr[start]);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">       <span class=\"comment\">// 假设存在左节点，则左节点位置为start+1</span></span><br><span class=\"line\">       <span class=\"comment\">// 若不存在左节点，右节点值为start+1</span></span><br><span class=\"line\">       <span class=\"comment\">// 从start+1开始找右节点，若不存在右节点，rightIndex最后的值为end+1</span></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">rightIndex</span> <span class=\"operator\">=</span> start + <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (; rightIndex &lt;= end; rightIndex++) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (arr[rightIndex] &gt; arr[start]) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 构建以head为根节点的树结构</span></span><br><span class=\"line\">       head.left = generateTree(arr, start+<span class=\"number\">1</span>, rightIndex-<span class=\"number\">1</span>);</span><br><span class=\"line\">       head.right = generateTree(arr, rightIndex, end);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果一个节点X，它左树结构和右树结构完全一样，那么我们说以X为头的树是相等树，给定一棵二叉树的头节点head，返回head整棵树上有多少棵相等子树</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">theSameTreeNum</span><span class=\"params\">(Node head)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       Queue&lt;Node&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">       queue.add(head);</span><br><span class=\"line\">       Map&lt;Node, Boolean&gt; sameTreeHeadMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">sameTreeHeadNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 队列遍历二叉树</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">           <span class=\"type\">Node</span> <span class=\"variable\">top</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (top.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">               queue.add(top.left);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (top.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">               queue.add(top.right);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (theSameTreeNode(top.left, top.right)) &#123;</span><br><span class=\"line\">               sameTreeHeadNum ++;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> sameTreeHeadNum;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">theSameTreeNum2</span><span class=\"params\">(Node head)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 递归遍历二叉树，代码更简洁</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> theSameTreeNum2(head.left) + theSameTreeNum2(head.right) + (theSameTreeNode(head.left, head.right) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">theSameTreeNode</span><span class=\"params\">(Node n1, Node n2)</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// n1 与 n2 有一个为空</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (n1 == <span class=\"literal\">null</span> ^ n2 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// n1 n2 都为空</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (n1 == <span class=\"literal\">null</span> &amp;&amp; n2 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// n1 n2都不为空</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> theSameTreeNode(n1.left, n2.left) &amp;&amp; theSameTreeNode(n1.right, n2.right) &amp;&amp; n1.value == n2.value;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"对称二叉树\"><a href=\"https://leetcode.cn/problems/symmetric-tree/\">对称二叉树</a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compare(root.left, root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compare</span><span class=\"params\">(TreeNode node1, TreeNode node2)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node1 != <span class=\"literal\">null</span> &amp;&amp; node2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node1.val == node2.val &amp;&amp; compare(node1.left, node2.right) </span><br><span class=\"line\">                    &amp;&amp; compare(node1.right, node2.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node1 == node2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉树的最大深度\"><a href=\"https://leetcode.cn/problems/maximum-depth-of-binary-tree/\">二叉树的最大深度</a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxDepth</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"literal\">null</span> || root.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉树的最小深度\"><a href=\"https://leetcode.cn/problems/minimum-depth-of-binary-tree/\">二叉树的最小深度</a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minDepth</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] minDepth = &#123;Integer.MAX_VALUE&#125;;</span><br><span class=\"line\">        dfs(root, <span class=\"number\">1</span>, minDepth);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minDepth[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(TreeNode node, <span class=\"type\">int</span> depth, <span class=\"type\">int</span>[] minDepth)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (depth &gt;= minDepth[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            minDepth[<span class=\"number\">0</span>] = depth;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        depth ++;</span><br><span class=\"line\">        dfs(node.left, depth, minDepth);</span><br><span class=\"line\">        dfs(node.right, depth, minDepth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"完全二叉树的节点个数\"><a href=\"https://leetcode.cn/problems/count-complete-tree-nodes/\">完全二叉树的节点个数</a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">countNodes</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> root.left;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> root.right;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">leftHeight</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rightHeight</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            left = left.left;</span><br><span class=\"line\">            leftHeight ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            right = right.right;</span><br><span class=\"line\">            rightHeight ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftHeight == rightHeight) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"number\">2</span> &lt;&lt; leftHeight) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> countNodes(root.left) + countNodes(root.right) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"平衡二叉树\"><a href=\"https://leetcode.cn/problems/balanced-binary-tree/\">110.\n平衡二叉树</a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isBalanced</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">leftHeight</span> <span class=\"operator\">=</span> getHeight(root.left);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rightHeight</span> <span class=\"operator\">=</span> getHeight(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Math.abs(leftHeight - rightHeight) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">getHeight</span><span class=\"params\">(TreeNode node)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(getHeight(node.left), getHeight(node.right)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"验证二叉搜索树\"><a href=\"https://leetcode.cn/problems/validate-binary-search-tree/\">98.\n验证二叉搜索树</a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidBST</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> travel(root, Long.MAX_VALUE, Long.MIN_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">travel</span><span class=\"params\">(TreeNode node, <span class=\"type\">long</span> max, <span class=\"type\">long</span> min)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断当前节点为根的树是否为二叉搜索树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.val &gt;= max || node.val &lt;= min) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> travel(node.left, node.val, min) &amp;&amp; travel(node.right, max, node.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉搜索树中的搜索\"><a href=\"https://leetcode.cn/problems/search-in-a-binary-search-tree/\">700.\n二叉搜索树中的搜索</a></h4>\n<p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p>\n<p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。\n如果节点不存在，则返回 null</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">searchBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val == val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &gt; val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> searchBST(root.left, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> searchBST(root.right, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"合并二叉树\"><a href=\"https://leetcode.cn/problems/merge-two-binary-trees/\">617.\n合并二叉树</a></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">mergeTrees</span><span class=\"params\">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root1 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root2;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root2 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root1.val += root2.val;</span><br><span class=\"line\">        root1.left = mergeTrees(root1.left, root2.left);</span><br><span class=\"line\">        root1.right = mergeTrees(root1.right, root2.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"最大二叉树\"><a href=\"https://leetcode.cn/problems/maximum-binary-tree/\">654.\n最大二叉树</a></h4>\n<p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums\n递归地构建:</p>\n<p>创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的\n子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上\n构建右子树。 返回 nums 构建的 最大二叉树</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">constructMaximumBinaryTree</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 找最大值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxPosition</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt; max) &#123;</span><br><span class=\"line\">                max = nums[i];</span><br><span class=\"line\">                maxPosition = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(max);</span><br><span class=\"line\">        <span class=\"type\">int</span>[] leftNums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[maxPosition];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; maxPosition; i++) &#123;</span><br><span class=\"line\">            leftNums[i] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] rightNums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length - maxPosition - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> maxPosition + <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            rightNums[i - maxPosition - <span class=\"number\">1</span>] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root.left = constructMaximumBinaryTree(leftNums);</span><br><span class=\"line\">        root.right = constructMaximumBinaryTree(rightNums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：可以通过控制数组下标进行优化，不要拷贝数组，而是控制要处理的下标范围</p>\n<h4 id=\"从中序与后序遍历序列构造二叉树\"><a href=\"https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\">106.\n从中序与后序遍历序列构造二叉树</a></h4>\n<p>给定两个整数数组 inorder 和 postorder ，其中 inorder\n是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗\n二叉树</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">buildTree</span><span class=\"params\">(<span class=\"type\">int</span>[] inorder, <span class=\"type\">int</span>[] postorder)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据后续遍历的最后一个元素确定根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inorder == <span class=\"literal\">null</span> || inorder.length == <span class=\"number\">0</span> || postorder == <span class=\"literal\">null</span> || postorder.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(postorder[postorder.length - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"comment\">// 在中序遍历中，根据root分割为两部分，对每部分递归操作</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">position</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (inorder[i] == root.val) &#123;</span><br><span class=\"line\">                position = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] leftInOrder = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[position];</span><br><span class=\"line\">        <span class=\"type\">int</span>[] rightInOrder = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[inorder.length - position - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; position; i++) &#123;</span><br><span class=\"line\">            leftInOrder[i] = inorder[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> position + <span class=\"number\">1</span>; i &lt; inorder.length; i++) &#123;</span><br><span class=\"line\">            rightInOrder[i - position - <span class=\"number\">1</span>] = inorder[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] leftPostOrder = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[position];</span><br><span class=\"line\">        <span class=\"type\">int</span>[] rightPostOrder = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[postorder.length - position - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; position; i++) &#123;</span><br><span class=\"line\">            leftPostOrder[i] = postorder[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> position; i &lt; postorder.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            rightPostOrder[i - position] = postorder[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root.left = buildTree(leftInOrder, leftPostOrder);</span><br><span class=\"line\">        root.right = buildTree(rightInOrder, rightPostOrder);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：可以通过控制数组下标进行优化，不要拷贝数组，而是控制要处理的下标范围</p>\n<h4 id=\"路径总和\"><a href=\"https://leetcode.cn/problems/path-sum/\">112.\n路径总和</a></h4>\n<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum\n。判断该树中是否存在 根节点到叶子节点\n的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回\ntrue ；否则，返回 false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasPathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root.val == targetSum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPathSum(root.left, targetSum - root.val) ||</span><br><span class=\"line\">                hasPathSum(root.right, targetSum - root.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"找树左下角的值\"><a href=\"https://leetcode.cn/problems/find-bottom-left-tree-value/\">513.\n找树左下角的值</a></h4>\n<p>难度中等284收藏分享切换为英文接收动态反馈</p>\n<p>给定一个二叉树的 <strong>根节点</strong>\n<code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong>\n节点的值。</p>\n<p>假设二叉树中至少有一个节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findBottomLeftValue</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">leftLastLeaf</span> <span class=\"operator\">=</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            List&lt;TreeNode&gt; nextFloor = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    nextFloor.add(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    nextFloor.add(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!nextFloor.isEmpty()) &#123;</span><br><span class=\"line\">                leftLastLeaf = nextFloor.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">                queue.addAll(nextFloor);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> leftLastLeaf.val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"左叶子之和\"><a href=\"https://leetcode.cn/problems/sum-of-left-leaves/\">404.\n左叶子之和</a></h4>\n<p>难度简单463收藏分享切换为英文接收动态反馈</p>\n<p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sumOfLeftLeaves</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> travel(root.left, <span class=\"literal\">true</span>) + travel(root.right, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">travel</span><span class=\"params\">(TreeNode node, Boolean leftTurn)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftTurn) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node.val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> travel(node.left, <span class=\"literal\">true</span>) + travel(node.right, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉树的所有路径\"><a href=\"https://leetcode.cn/problems/binary-tree-paths/\">257.\n二叉树的所有路径</a></h4>\n<p>难度简单751收藏分享切换为英文接收动态反馈</p>\n<p>给你一个二叉树的根节点 <code>root</code> ，按\n<strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>\n<p><strong>叶子节点</strong> 是指没有子节点的节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">binaryTreePaths</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; paths = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> paths;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            paths.add(root.val + <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> paths;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;String&gt; leftPaths = binaryTreePaths(root.left);</span><br><span class=\"line\">        List&lt;String&gt; rightPaths = binaryTreePaths(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String p : leftPaths) &#123;</span><br><span class=\"line\">            paths.add(root.val + <span class=\"string\">&quot;-&gt;&quot;</span> + p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String p : rightPaths) &#123;</span><br><span class=\"line\">            paths.add(root.val + <span class=\"string\">&quot;-&gt;&quot;</span> + p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> paths;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉搜索树中的众数\"><a href=\"https://leetcode.cn/problems/find-mode-in-binary-search-tree/\">501.\n二叉搜索树中的众数</a></h4>\n<p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code>\n，找出并返回 BST 中的所有 <a href=\"https://baike.baidu.com/item/众数/44796\">众数</a>（即，出现频率最高的元素）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeNode preTravelNode;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">maxModeNum</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">modeNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] findMode(TreeNode root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;Integer&gt; modes = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        midTravel2(root, modes);</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[modes.size()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; modes.size(); i++) &#123;</span><br><span class=\"line\">            arr[i] = modes.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">midTravel2</span><span class=\"params\">(TreeNode node, List&lt;Integer&gt; modes)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        midTravel2(node.left, modes);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (preTravelNode != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前数值与上一个数值相等</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (preTravelNode.val == node.val) &#123;</span><br><span class=\"line\">                modeNum ++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当前数值与上一个数值不相等</span></span><br><span class=\"line\">                modeNum = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            modeNum = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (modeNum == maxModeNum) &#123;</span><br><span class=\"line\">            modes.add(node.val);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (modeNum &gt; maxModeNum) &#123;</span><br><span class=\"line\">            modes.clear();</span><br><span class=\"line\">            modes.add(node.val);</span><br><span class=\"line\">            maxModeNum = modeNum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        preTravelNode = node;</span><br><span class=\"line\">        midTravel2(node.right, modes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉搜索树的最小绝对差\"><a href=\"https://leetcode.cn/problems/minimum-absolute-difference-in-bst/\">530.\n二叉搜索树的最小绝对差</a></h4>\n<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回\n<strong>树中任意两不同节点值之间的最小差值</strong> 。</p>\n<p>差值是一个正数，其数值等于两值之差的绝对值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMinimumDifference</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">minDistance</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        pushStack(root, stack);</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">prePopNode</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prePopNode != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                minDistance = Math.min(minDistance, head.val - prePopNode.val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            prePopNode = head;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                pushStack(head.right, stack);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minDistance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pushStack</span><span class=\"params\">(TreeNode node, Stack&lt;TreeNode&gt; stack)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(node);</span><br><span class=\"line\">            node = node.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉树的最近公共祖先难\"><a href=\"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/\">236.\n二叉树的最近公共祖先</a>【难】</h4>\n<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span> || root == p || root == q) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"literal\">null</span> &amp;&amp; right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉搜索树的最近公共祖先\"><a href=\"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/\">235.\n二叉搜索树的最近公共祖先</a></h4>\n<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉搜索树中的插入操作\"><a href=\"https://leetcode.cn/problems/insert-into-a-binary-search-tree/\">701.\n二叉搜索树中的插入操作</a></h4>\n<p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值\n<code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。\n输入数据 <strong>保证</strong>\n，新值和原始二叉搜索树中的任意节点值都不同</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">insertIntoBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> root;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">preNode</span> <span class=\"operator\">=</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            preNode = node;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.val &gt; val) &#123;</span><br><span class=\"line\">                node = node.left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                node = node.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (preNode.val &gt; val) &#123;</span><br><span class=\"line\">            preNode.left = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            preNode.right = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除二叉搜索树中的节点难\"><a href=\"https://leetcode.cn/problems/delete-node-in-a-bst/\">450.\n删除二叉搜索树中的节点</a>【难】</h4>\n<p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值\n<strong>key</strong>，删除二叉搜索树中的 <strong>key</strong>\n对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">deleteNode</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 情况1：没有找到要删除的节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val == key) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 情况2：左右节点都是空，直接删除节点，返回NULL作为当前子树的根节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 情况3：只有左节点为空，删除节点，右节点作为新的根节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> root.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 情况4：只有右节点为空，删除节点，左节点作为新的根节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 情况5：左右孩子都不为空，将删除节点的左子树放到其右子树最左侧节点的左孩子</span></span><br><span class=\"line\">            <span class=\"comment\">// 或将删除节点的右子树放到其左子树最右侧节点的右孩子</span></span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> root.left;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (node.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                node = node.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node.right = root.right;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &gt; key) &#123;</span><br><span class=\"line\">            root.left = deleteNode(root.left, key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            root.right = deleteNode(root.right, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：情况5较难考虑</p>\n<h4 id=\"修剪二叉搜索树难\"><a href=\"https://leetcode.cn/problems/trim-a-binary-search-tree/\">669.\n修剪二叉搜索树</a>【难】</h4>\n<p>给你二叉搜索树的根节点 <code>root</code>\n，同时给定最小边界<code>low</code> 和最大边界\n<code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树\n<strong>不应该</strong> 改变保留在树中的元素的相对结构\n(即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在\n<strong>唯一的答案</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">trimBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &lt; low) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> trimBST(root.right, low, high);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &gt; high) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> trimBST(root.left, low, high);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root.left = trimBST(root.left, low, high);</span><br><span class=\"line\">        root.right = trimBST(root.right, low, high);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"将有序数组转换为二叉搜索树\"><a href=\"https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/\">108.\n将有序数组转换为二叉搜索树</a></h4>\n<p>给你一个整数数组 <code>nums</code> ，其中元素已经按\n<strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong>\n二叉搜索树</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">sortedArrayToBST</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> travel(nums, <span class=\"number\">0</span>, nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeNode <span class=\"title function_\">travel</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 可能越界，故采用下一行的方法</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// int mid = (right + left) / 2;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(nums[mid]);</span><br><span class=\"line\">        root.left = travel(nums, left, mid-<span class=\"number\">1</span>);</span><br><span class=\"line\">        root.right = travel(nums, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"把二叉搜索树转换为累加树\"><a href=\"https://leetcode.cn/problems/convert-bst-to-greater-tree/\">538.\n把二叉搜索树转换为累加树</a></h4>\n<p>给出二叉 <strong>搜索</strong>\n树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum\nTree），使每个节点 <code>node</code> 的新值等于原树中大于或等于\n<code>node.val</code> 的值之和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">TreeNode</span> <span class=\"variable\">preNode</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">convertBST</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 反中序遍历</span></span><br><span class=\"line\">        convertBST(root.right);</span><br><span class=\"line\">        root.val += preNode.val;</span><br><span class=\"line\">        preNode = root;</span><br><span class=\"line\">        convertBST(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结</h2>\n<ol type=\"1\">\n<li>二叉树递归过程中，可能需要用到额外的类属性记录过程值</li>\n<li>递归可以用栈代替</li>\n</ol>\n<p><a href=\"https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html\">二叉树总结</a></p>\n","categories":["algorithm"],"tags":["二叉树"]},{"title":"算法-位运算","url":"/2022/04/23/algorithm/bit-operation/","content":"<blockquote>\n<p>位运算相关算法题</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>给定一个非负整数num，如何不用循环语句，返回&gt;=num，并且离num最近的2的某次方</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">nearest2Power</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    n --;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">highOnePosition</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 找到二进制下最高位的1的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 右移</span></span><br><span class=\"line\">        n = n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        highOnePosition ++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">int</span>) Math.pow(<span class=\"number\">2</span>, highOnePosition + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>图解：</p>\n<figure>\n<img src=\"/images/algorithm/image-20220410031132541.png\" alt=\"image-20220410031132541\">\n<figcaption aria-hidden=\"true\">image-20220410031132541</figcaption>\n</figure>\n<p>为了保持统计逻辑，令num减一，则都按照第二种情况计算</p>\n<p>高级写法：num-=1，再令最高位1的后面都是1，然后+1即是答案</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">nearest2Power</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    n--;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["algorithm"],"tags":["位运算"]},{"title":"动态规划——编辑距离","url":"/2022/05/29/algorithm/dp-edit-distance/","content":"<blockquote>\n<p>动态规划——<strong>编辑距离</strong> 问题汇总</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"判断子序列\">判断子序列</h2>\n<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列</p>\n<p>https://leetcode.cn/problems/is-subsequence/</p>\n<p>dp[i][j]表示 s[0...i-1]是否为t[0...j-1]的子序列</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSubsequence</span><span class=\"params\">(String s, String t)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() &gt; t.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> t.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">M</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">char</span>[] tc = t.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">char</span>[] sc = s.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[N+<span class=\"number\">1</span>][M+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= M; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= M ; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tc[i-<span class=\"number\">1</span>] == sc[j-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i-<span class=\"number\">1</span>][j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[N][M];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>dp数组变为int[][]类型，即为求t到s的删除距离</p>\n<h3 id=\"判断子序列问题优化空间压缩\">判断子序列问题优化：空间压缩</h3>\n<p>当dp公式只与上一层有关时，可以将二维dp数组优化为一维dp数组，降低空间复杂度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSubsequence</span><span class=\"params\">(String s, String t)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() &gt; t.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> t.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">M</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">char</span>[] sc = s.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">char</span>[] tc = t.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[M+<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= M; i++) &#123;</span><br><span class=\"line\">            dp[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> M; j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sc[j-<span class=\"number\">1</span>] == tc[i-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[j] = dp[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[M];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除成为子串\">删除成为子串</h2>\n<p>给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？比如 s1 =\n\"abcde\"，s2 = \"axbc\"，s2删掉'x'即可，返回1</p>\n<p>思路：求s1的所有子串，求s2到每个子串的删除距离（同上题）</p>\n<p>思考点：如何复用dp数组</p>\n<p>Tips：具有相同前缀的s1的子串，可以共用一个dp数组，即在求一次dp方程时，一次性求出很多s1子串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Solution &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minCost</span><span class=\"params\">(String s1, String s2)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 待补充                  </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"不同的子序列\">不同的子序列</h2>\n<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t\n出现的个数</p>\n<p>https://leetcode.cn/problems/distinct-subsequences/</p>\n<p>dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numDistinct</span><span class=\"params\">(String s, String t)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() &lt; t.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">M</span> <span class=\"operator\">=</span> t.length();</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[N+<span class=\"number\">1</span>][M+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 初始化dp边界</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= M; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 根据dp方程填表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= M; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i-<span class=\"number\">1</span>) == t.charAt(j-<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>] + dp[i-<span class=\"number\">1</span>][j];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i-<span class=\"number\">1</span>][j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[N][M];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样可以用空间压缩优化，与第一题类似</p>\n<h2 id=\"两个字符串的删除操作\">两个字符串的删除操作</h2>\n<p>给定两个单词 word1 和 word2 ，返回使得 word1 和 word2\n<strong>相同</strong>所需的<strong>最小步数</strong>。<strong>每步</strong>\n可以删除任意一个字符串中的一个字符。</p>\n<p>https://leetcode.cn/problems/delete-operation-for-two-strings/</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minDistance</span><span class=\"params\">(String word1, String word2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> word1.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">M</span> <span class=\"operator\">=</span> word2.length();</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[N+<span class=\"number\">1</span>][M+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= M; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= M; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (word1.charAt(i-<span class=\"number\">1</span>) == word2.charAt(j-<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.min(dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>] + <span class=\"number\">2</span>, Math.min(dp[i-<span class=\"number\">1</span>][j] + <span class=\"number\">1</span>, dp[i][j-<span class=\"number\">1</span>] + <span class=\"number\">1</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[N][M];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"编辑距离\">编辑距离</h2>\n<p>给你两个单词 word1 和 word2， <em>请返回将</em> <em>word1</em>\n<em>转换成</em> <em>word2</em> <em>所使用的最少操作数</em>\n。你可以对一个单词进行如下三种操作：插入一个字符，删除一个字符，替换一个字符</p>\n<p>https://leetcode.cn/problems/edit-distance/</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minDistance</span><span class=\"params\">(String word1, String word2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> word1.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">M</span> <span class=\"operator\">=</span> word2.length();</span><br><span class=\"line\">        <span class=\"type\">char</span>[] s = word1.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">char</span>[] t = word2.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[N+<span class=\"number\">1</span>][M+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 初始化dp边界</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= M; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 根据dp方程填表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= M; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[i-<span class=\"number\">1</span>] == t[j-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.min(dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>], Math.min(dp[i-<span class=\"number\">1</span>][j], dp[i][j-<span class=\"number\">1</span>])) + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[N][M];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结</h2>\n<p>本文汇总了动态规划中常见的<strong>编辑距离</strong>问题，通过对每个问题的分析，可以发现：</p>\n<ol type=\"1\">\n<li>dp[i][j]\n的含义一般都表示在s[0...i-1]与t[0...j-1]情况下的问题所求</li>\n<li>边界一般都是考虑在dp[i][0]与dp[0][j]下的值</li>\n<li>dp方程具有很强的规律性，即在 s[i-1] 是否等于 t[j-1]\n的两种情况下，考虑dp方程是什么</li>\n<li>都可以使用<strong>空间压缩</strong>方法进行空间复杂度的优化</li>\n</ol>\n","tags":["dynamic-process","edit-distance"]},{"title":"算法-哈希表","url":"/2022/04/21/algorithm/hashmap/","content":"<blockquote>\n<p>哈希表相关算法题</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>设计有setAll功能的哈希表，put、get、setAll方法，时间复杂度O(1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 带有时间戳的值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;V&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyValue</span>&lt;V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> V value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> time;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyValue</span><span class=\"params\">(V v, <span class=\"type\">long</span> t)</span> &#123;</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">        time = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyHashMap</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashMap&lt;K, MyValue&lt;V&gt;&gt; map;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> time;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 保持setAll的值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyValue&lt;V&gt; setAll;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyHashMap</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        time = <span class=\"number\">0</span>;</span><br><span class=\"line\">        setAll = <span class=\"keyword\">new</span> <span class=\"title class_\">MyValue</span>&lt;&gt;(<span class=\"literal\">null</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">        map.put(key, <span class=\"keyword\">new</span> <span class=\"title class_\">MyValue</span>&lt;&gt;(value, time++));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAll</span><span class=\"params\">(V value)</span> &#123;</span><br><span class=\"line\">        setAll = <span class=\"keyword\">new</span> <span class=\"title class_\">MyValue</span>&lt;&gt;(value, time++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(K key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!map.containsKey(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 比较map与setAll的时间，时间大的覆盖时间小的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map.get(key).time &gt; setAll.time) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map.get(key).value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setAll.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["algorithm"],"tags":["hashmaph"]},{"title":"算法-贪心","url":"/2022/04/27/algorithm/greedy/","content":"<blockquote>\n<p>贪心相关算法</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>给定一个数组arr，代表每个人的能力值。再给定一个非负数k，如果两个人能力差值正好为k，那么可以凑在一起比赛，一局比赛只有两个人，返回最多可以同时有多少场比赛</p>\n<figure>\n<img src=\"/images/algorithm/微信图片_20220427021521.jpg\" alt=\"微信图片_20220427021521\">\n<figcaption aria-hidden=\"true\">微信图片_20220427021521</figcaption>\n</figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">combinePair</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &lt; <span class=\"number\">0</span> || arr == <span class=\"literal\">null</span> || arr.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(arr);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pairNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">L</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">R</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        Set&lt;Integer&gt; usedIndex = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (L &lt; N &amp;&amp; R &lt; N) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (usedIndex.contains(L)) &#123;</span><br><span class=\"line\">                L ++;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[R] - arr[L] &gt; k) &#123;</span><br><span class=\"line\">                L ++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[R] - arr[L] &lt; k) &#123;</span><br><span class=\"line\">                R ++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                usedIndex.add(R);</span><br><span class=\"line\">                pairNum ++;</span><br><span class=\"line\">                L ++;</span><br><span class=\"line\">                R ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pairNum;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>给定一个正数数组arr，代表若干人的体重，再给定一个正数limit，表示所有船共同拥有的载重量，每艘船最多坐两人，且不能超过载重。让所有的人同时过河，并且用最好的分配方法让船尽量少，返回最少的船</p>\n<p>https://leetcode-cn.com/problems/boats-to-save-people/</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numRescueBoats</span><span class=\"params\">(<span class=\"type\">int</span>[] people, <span class=\"type\">int</span> limit)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (people == <span class=\"literal\">null</span> || people.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(people);</span><br><span class=\"line\">        <span class=\"comment\">// 二分查找 limit/2</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">halfLimit</span> <span class=\"operator\">=</span> limit &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> people.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (people[i] &gt; halfLimit) &#123;</span><br><span class=\"line\">                l = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">                r = i;</span><br><span class=\"line\">                mid = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 全都比 limit/2 大</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> N;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 全都比 Limit/2 小</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ((N + <span class=\"number\">1</span>) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">noUseNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从 limit/2 两边出发，向左右移动</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &gt;= <span class=\"number\">0</span> &amp;&amp; r &lt; N) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (people[l] + people[r] &lt;= limit) &#123;</span><br><span class=\"line\">                l --;</span><br><span class=\"line\">                r ++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (people[l] + people[r] &gt; limit) &#123;</span><br><span class=\"line\">                l --;</span><br><span class=\"line\">                noUseNum ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((l + <span class=\"number\">1</span> + noUseNum + <span class=\"number\">1</span>) &gt;&gt; <span class=\"number\">1</span>) + r - mid + N - r;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>给定一个非负数组成的数组，长度一定大于1，想知道数组中哪两个数&amp;的结果最大，返回这个最大结果。要求时间复杂度O(N)，额外空间复杂度O(1)</p>\n<blockquote>\n<p>思路：贪心选择高位与运算结果为1的数字，如果正好有2个数字的高位为1，直接返回；如果小于2个，则该高位无法与出1，看下一位；如果大于2个，则看这些数的下一位哪些是1，直到第0位</p>\n</blockquote>\n<p><img src=\"/images/algorithm/20220504160957.jpg\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxAndValue</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">30</span>; i &gt;= <span class=\"number\">0</span> ; i--) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 0...N-1为有效区，N-arr.lenth-1为淘汰区</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> N;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; N; ) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (((arr[j] &gt;&gt; i) &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                   swap(arr, j, --N);</span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                   j++;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">// 从符号位下一位开始，找最高位为1的数字，如果只有一个，则找下一个高位</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (N &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">               N = tmp;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">// 如果有两个，则返回这两个数字与的结果</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (N == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>] &amp; arr[<span class=\"number\">1</span>];</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">// 如果有大于两个，在向下一个高位寻找</span></span><br><span class=\"line\">           <span class=\"comment\">// next loop</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 循环结束，没有退出，说明循环中没有发现N==2的情况，总之arr[0]与arr[1]是有效区的数字</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>] &amp; arr[<span class=\"number\">1</span>];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> arr[j];</span><br><span class=\"line\">       arr[j] = arr[i];</span><br><span class=\"line\">       arr[i] = tmp;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"摆动序列\"><a href=\"https://leetcode.cn/problems/wiggle-subsequence/\">376.\n摆动序列</a></h4>\n<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为\n<strong>摆动序列\n。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：这个序列包含几个长度为 7 摆动序列</span><br><span class=\"line\">其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">wiggleMaxLength</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums.length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//当前差值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">curDiff</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//上一个差值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">preDiff</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//得到当前差值</span></span><br><span class=\"line\">            curDiff = nums[i] - nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"comment\">//如果当前差值和上一个差值为一正一负</span></span><br><span class=\"line\">            <span class=\"comment\">//等于0的情况表示初始时的preDiff</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((curDiff &gt; <span class=\"number\">0</span> &amp;&amp; preDiff &lt;= <span class=\"number\">0</span>) || (curDiff &lt; <span class=\"number\">0</span> &amp;&amp; preDiff &gt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                preDiff = curDiff;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"买卖股票的最佳时机-ii记\"><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/\">122.\n买卖股票的最佳时机 II</a>【记】</h4>\n<p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code>\n表示某支股票第 <code>i</code> 天的价格。</p>\n<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候\n<strong>最多</strong> 只能持有 <strong>一股</strong>\n股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>\n<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：prices = [7,1,5,3,6,4]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class=\"line\">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class=\"line\">     总利润为 4 + 3 = 7 </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxProfit</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">diff</span> <span class=\"operator\">=</span> prices[i] - prices[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                maxProfit += diff;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxProfit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"跳跃游戏\"><a href=\"https://leetcode.cn/problems/jump-game/\">55.\n跳跃游戏</a></h4>\n<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的\n<strong>第一个下标</strong> 。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>判断你是否能够到达最后一个下标。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,3,1,1,4]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canJump</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= right; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] + i &gt; right) &#123;</span><br><span class=\"line\">                right = nums[i] + i;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right &gt;= nums.length - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"跳跃游戏-ii\"><a href=\"https://leetcode.cn/problems/jump-game-ii/\">45. 跳跃游戏\nII</a></h4>\n<p>给你一个非负整数数组 <code>nums</code>\n，你最初位于数组的第一个位置。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>\n<p>假设你总是可以到达数组的最后一个位置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums = [2,3,1,1,4]</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class=\"line\">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">jump</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">step</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxStep</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= right; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right &gt;= nums.length - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> step;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxStep = Math.max(maxStep, nums[i] + i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == right) &#123;</span><br><span class=\"line\">                right = maxStep;</span><br><span class=\"line\">                step ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> step;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"加油站\"><a href=\"https://leetcode.cn/problems/gas-station/\">134.\n加油站</a></h4>\n<p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code>\n个加油站有汽油 <code>gas[i]</code> 升。</p>\n<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第\n<code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code>\n升。你从其中的一个加油站出发，开始时油箱为空。</p>\n<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code>\n，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回\n<code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是\n<strong>唯一</strong> 的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class=\"line\">输出: 3</span><br></pre></td></tr></table></figure>\n<p>思路：</p>\n<p>局部贪心：任意两个加油站能行驶一周，要求油总量减去总消耗大于等于0；每个加油站的剩余量rest[i]为gas[i]\n- cost[i]。i 从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0,\ni]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">canCompleteCircuit</span><span class=\"params\">(<span class=\"type\">int</span>[] gas, <span class=\"type\">int</span>[] cost)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">totalGas</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">totalCost</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] gasLeft = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[gas.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class=\"line\">            totalGas += gas[i];</span><br><span class=\"line\">            totalCost += cost[i];</span><br><span class=\"line\">            gasLeft[i] = gas[i] - cost[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (totalCost &gt; totalGas) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">totalGasLeft</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; gasLeft.length; i++) &#123;</span><br><span class=\"line\">            totalGasLeft += gasLeft[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (totalGasLeft &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                totalGasLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">                start = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"分发糖果记\"><a href=\"https://leetcode.cn/problems/candy/\">135.\n分发糖果</a>【记】</h4>\n<p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code>\n表示每个孩子的评分。</p>\n<p>你需要按照以下要求，给这些孩子分发糖果：</p>\n<ul>\n<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>\n<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>\n</ul>\n<p>请你给每个孩子分发糖果，计算并返回需要准备的\n<strong>最少糖果数目</strong> 。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：ratings = [1,0,2]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></pre></td></tr></table></figure>\n<p>思路：先从左向右满足条件，再从右向左满足条件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">candy</span><span class=\"params\">(<span class=\"type\">int</span>[] ratings)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] candyNum = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[ratings.length];</span><br><span class=\"line\">        Arrays.fill(candyNum, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ratings[i] &gt; ratings[i-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                candyNum[i] = candyNum[i-<span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> ratings.length - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span> ; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ratings[i] &gt; ratings[i+<span class=\"number\">1</span>] &amp;&amp; candyNum[i] &lt;= candyNum[i+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                candyNum[i] = candyNum[i+<span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">totalCandyNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; candyNum.length; i++) &#123;</span><br><span class=\"line\">            totalCandyNum += candyNum[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> totalCandyNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"柠檬水找零\"><a href=\"https://leetcode.cn/problems/lemonade-change/\">860.\n柠檬水找零</a></h4>\n<p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code>\n美元。顾客排队购买你的产品，（按账单 <code>bills</code>\n支付的顺序）一次购买一杯。</p>\n<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code>\n美元、<code>10</code> 美元或 <code>20</code>\n美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付\n<code>5</code> 美元。</p>\n<p>注意，一开始你手头没有任何零钱。</p>\n<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第\n<code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回\n<code>true</code> ，否则返回 <code>false</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：bills = [5,5,5,10,20]</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lemonadeChange</span><span class=\"params\">(<span class=\"type\">int</span>[] bills)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">five</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ten</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; bills.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bills[i] == <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                five ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bills[i] == <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                five--;</span><br><span class=\"line\">                ten ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bills[i] == <span class=\"number\">20</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ten &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    five--;</span><br><span class=\"line\">                    ten--;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    five -= <span class=\"number\">3</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (five &lt; <span class=\"number\">0</span> || ten &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"根据身高重建队列技\"><a href=\"https://leetcode.cn/problems/queue-reconstruction-by-height/\">406.\n根据身高重建队列</a>【技】</h4>\n<p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code>\n表示队列中一些人的属性（不一定按顺序）。每个\n<code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为\n<code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code>\n个身高大于或等于 <code>hi</code> 的人。</p>\n<p>请你重新构造并返回输入数组 <code>people</code>\n所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中\n<code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code>\n个人的属性（<code>queue[0]</code> 是排在队列前面的人）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class=\"line\">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public int[][] reconstructQueue(int[][] people) &#123;</span><br><span class=\"line\">    // 先按照身高降序排序，如果身高相同，按照k升序排序</span><br><span class=\"line\">    Arrays.sort(people, (o1, o2) -&gt; &#123;</span><br><span class=\"line\">        if (o1[0] == o2[0]) &#123;</span><br><span class=\"line\">            return o1[1] - o2[1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return o2[0] - o1[0];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // 身高从高到低，依次维护队列关系</span><br><span class=\"line\">    LinkedList&lt;int[]&gt; que = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    for(int[] p : people) &#123;</span><br><span class=\"line\">        que.add(p[1], p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return que.toArray(new int[people.length][]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：技巧性题目，考的可能性不大</p>\n<h4 id=\"用最少数量的箭引爆气球\"><a href=\"https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/\">452.\n用最少数量的箭引爆气球</a></h4>\n<p>有一些球形气球贴在一堵用 XY\n平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code>\n，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在\n<code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y\n坐标。</p>\n<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong>\n地射出。在坐标 <code>x</code>\n处射出一支箭，若有一个气球的直径的开始和结束坐标为\n<code>x``start</code>，<code>x``end</code>， 且满足\n<code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong>\n。可以射出的弓箭的数量 <strong>没有限制</strong> 。\n弓箭一旦被射出之后，可以无限地前进。</p>\n<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的\n<strong>最小</strong> 弓箭数</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：气球可以用2支箭来爆破:</span><br><span class=\"line\">-在x = 6处射出箭，击破气球[2,8]和[1,6]。</span><br><span class=\"line\">-在x = 11处发射箭，击破气球[10,16]和[7,12]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findMinArrowShots</span><span class=\"params\">(<span class=\"type\">int</span>[][] points)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(points, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;<span class=\"type\">int</span>[]&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(<span class=\"type\">int</span>[] o1, <span class=\"type\">int</span>[] o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (o1[<span class=\"number\">1</span>] == o2[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o1[<span class=\"number\">1</span>] &gt; o2[<span class=\"number\">1</span>] ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; points.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (points[i][<span class=\"number\">0</span>] &gt; points[i-<span class=\"number\">1</span>][<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                res ++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                points[i][<span class=\"number\">1</span>] = points[i-<span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：排序函数如下写法，会导致整型越界</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">integerTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[][] points = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[][]&#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">5</span>&#125;, &#123;<span class=\"number\">3</span>, <span class=\"number\">2</span>&#125;, &#123;<span class=\"number\">4</span>, Integer.MAX_VALUE&#125;, &#123;<span class=\"number\">2</span>, Integer.MIN_VALUE&#125;&#125;;</span><br><span class=\"line\">    Arrays.sort(points, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;<span class=\"type\">int</span>[]&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(<span class=\"type\">int</span>[] o1, <span class=\"type\">int</span>[] o2)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1[<span class=\"number\">1</span>] - o2[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    System.out.println(Arrays.deepToString(points));</span><br><span class=\"line\">    <span class=\"comment\">// [[3, 2], [1, 5], [4, 2147483647], [2, -2147483648]]</span></span><br><span class=\"line\">    System.out.println(Integer.MAX_VALUE - Integer.MIN_VALUE);</span><br><span class=\"line\">    <span class=\"comment\">// -1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"无重叠区间\"><a href=\"https://leetcode.cn/problems/non-overlapping-intervals/\">435.\n无重叠区间</a></h4>\n<p>给定一个区间的集合 <code>intervals</code> ，其中\n<code>intervals[i] = [starti, endi]</code> 。返回\n<em>需要移除区间的最小数量，使剩余区间互不重叠</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">eraseOverlapIntervals</span><span class=\"params\">(<span class=\"type\">int</span>[][] intervals)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(intervals, (o1, o2) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o1[<span class=\"number\">1</span>] == o2[<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1[<span class=\"number\">1</span>] - o2[<span class=\"number\">1</span>] &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">noLapNum</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">noLapIndex</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 保留右端点小的，给右侧尽可能留空间</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (intervals[i][<span class=\"number\">0</span>] &gt;= intervals[noLapIndex][<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                noLapNum ++;</span><br><span class=\"line\">                noLapIndex = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> intervals.length - noLapNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"划分字母区间\"><a href=\"https://leetcode.cn/problems/partition-labels/\">763.\n划分字母区间</a></h4>\n<p>字符串 <code>S</code>\n由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class=\"line\">输出：[9,7,8]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">partitionLabels</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span> || s.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">char</span>[] charArr = s.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] charIndex = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 计算每个字符出现的第一个位置和最后一个位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; charArr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (charIndex[charArr[i] - <span class=\"string\">&#x27;a&#x27;</span>][<span class=\"number\">0</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                charIndex[charArr[i] - <span class=\"string\">&#x27;a&#x27;</span>][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            charIndex[charArr[i] - <span class=\"string\">&#x27;a&#x27;</span>][<span class=\"number\">1</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> charIndex[charArr[<span class=\"number\">0</span>] - <span class=\"string\">&#x27;a&#x27;</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; charArr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> charIndex[charArr[i] - <span class=\"string\">&#x27;a&#x27;</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == end) &#123;</span><br><span class=\"line\">                res.add(end - start + <span class=\"number\">1</span>);</span><br><span class=\"line\">                start = end + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (start &lt; charArr.length) &#123;</span><br><span class=\"line\">                    end = charIndex[charArr[start] - <span class=\"string\">&#x27;a&#x27;</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t &gt; end) &#123;</span><br><span class=\"line\">                end = t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"合并区间记\"><a href=\"https://leetcode.cn/problems/merge-intervals/\">56.\n合并区间</a>【记】</h4>\n<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为\n<code>intervals[i] = [starti, endi]</code>\n。请你合并所有重叠的区间，并返回\n<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class=\"line\">输出：[[1,6],[8,10],[15,18]]</span><br><span class=\"line\">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[][] merge(<span class=\"type\">int</span>[][] intervals) &#123;</span><br><span class=\"line\">        List&lt;<span class=\"type\">int</span>[]&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(intervals, (o1, o2) -&gt; Integer.compare(o1[<span class=\"number\">0</span>], o2[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> intervals[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (intervals[i][<span class=\"number\">0</span>] &gt; intervals[i-<span class=\"number\">1</span>][<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;start, intervals[i-<span class=\"number\">1</span>][<span class=\"number\">1</span>]&#125;);</span><br><span class=\"line\">                start = intervals[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                intervals[i][<span class=\"number\">1</span>] = Math.max(intervals[i][<span class=\"number\">1</span>], intervals[i-<span class=\"number\">1</span>][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;start, intervals[intervals.length - <span class=\"number\">1</span>][<span class=\"number\">1</span>]&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[res.size()][]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：先按左端点升序排序，再从左向右判断是否重合</p>\n<h4 id=\"单调递增的数字技\"><a href=\"https://leetcode.cn/problems/monotone-increasing-digits/\">738.\n单调递增的数字</a>【技】</h4>\n<p>当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足\n<code>x &lt;= y</code>\n时，我们称这个整数是<strong>单调递增</strong>的。</p>\n<p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code>\n的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = 332</span><br><span class=\"line\">输出: 299</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">monotoneIncreasingDigits</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> n + <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[s.length()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            arr[i] = s.charAt(i) - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] &gt;= arr[i-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[i] = <span class=\"number\">9</span>;</span><br><span class=\"line\">            arr[i-<span class=\"number\">1</span>] --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果最后存在不符合递增的，一律置为9</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] &lt; arr[i-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                arr[i] = <span class=\"number\">9</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = res * <span class=\"number\">10</span> + arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于\n3332，先对最后两位判断是否单调递增，32改为29，整体变为3329，向左移，变为3299，继续左移，2999；对于100，先变为100，再变为090，最后将最后的0变为9</p>\n","categories":["algorithm"],"tags":["贪心"]},{"title":"算法-堆","url":"/2022/06/11/algorithm/heap-question/","content":"<blockquote>\n<p>堆相关算法题</p>\n</blockquote>\n<span id=\"more\"></span>\n<h4 id=\"前-k-个高频元素\"><a href=\"https://leetcode.cn/problems/top-k-frequent-elements/\">347. 前 K\n个高频元素</a></h4>\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>\n，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按\n<strong>任意顺序</strong> 返回答案</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Number</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> val;</span><br><span class=\"line\">        <span class=\"type\">int</span> freq;</span><br><span class=\"line\">        Number(<span class=\"type\">int</span> val, <span class=\"type\">int</span> freq) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.val = val;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.freq = freq;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] topKFrequent(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 统计数组中每个数值出现的次数</span></span><br><span class=\"line\">        PriorityQueue&lt;Number&gt; priorityQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o2.freq - o1.freq);</span><br><span class=\"line\">        Map&lt;Integer, Number&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!map.containsKey(nums[i])) &#123;</span><br><span class=\"line\">                map.put(nums[i], <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>(nums[i], <span class=\"number\">0</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">Number</span> <span class=\"variable\">number</span> <span class=\"operator\">=</span> map.get(nums[i]);</span><br><span class=\"line\">            number.freq ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        priorityQueue.addAll(map.values());</span><br><span class=\"line\">        <span class=\"type\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[k];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Number</span> <span class=\"variable\">number</span> <span class=\"operator\">=</span> priorityQueue.poll();</span><br><span class=\"line\">            ans[i] = number.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(Arrays.toString(ans));</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"丑数-ii\">264. 丑数 II</h4>\n<p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个\n<strong>丑数</strong> 。<strong>丑数</strong> 就是只包含质因数\n<code>2</code>、<code>3</code> 和 <code>5</code> 的正整数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">nthUglyNumber</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        PriorityQueue&lt;Long&gt; priorityQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">        priorityQueue.add(num);</span><br><span class=\"line\">        Set&lt;Long&gt; uglyNumberSet = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        uglyNumberSet.add(num);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            num = priorityQueue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!uglyNumberSet.contains(num * <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">                priorityQueue.add(num * <span class=\"number\">2</span>);</span><br><span class=\"line\">                uglyNumberSet.add(num * <span class=\"number\">2</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!uglyNumberSet.contains(num * <span class=\"number\">3</span>)) &#123;</span><br><span class=\"line\">                priorityQueue.add(num * <span class=\"number\">3</span>);</span><br><span class=\"line\">                uglyNumberSet.add(num * <span class=\"number\">3</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!uglyNumberSet.contains(num * <span class=\"number\">5</span>)) &#123;</span><br><span class=\"line\">                priorityQueue.add(num * <span class=\"number\">5</span>);</span><br><span class=\"line\">                uglyNumberSet.add(num * <span class=\"number\">5</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>) num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["algorithm"],"tags":["堆"]},{"title":"算法-动态规划","url":"/2022/04/23/algorithm/dynamic-program/","content":"<blockquote>\n<p>动态规划相关算法题</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>现有司机N*2人，调度中心会将所有司机平分给A、B两区域，i号司机去A可得收入为income[i][0]，去B可得收入为income[i][1]\n返回能使所有司机总收入最高的方案是多少钱?</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">driverMaxMoney</span><span class=\"params\">(<span class=\"type\">int</span>[][] income)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (income == <span class=\"literal\">null</span> || income.length == <span class=\"number\">0</span> || (income.length &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">driverNumToA</span> <span class=\"operator\">=</span> income.length &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 缓存</span></span><br><span class=\"line\">       HashMap&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">       <span class=\"keyword\">return</span> process(income, <span class=\"number\">0</span>, driverNumToA, cache);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> income 司机分配到A、B地区获取的钱数 income[i][0]表示i司机到A地区的收入，income[i][1]表示i司机到B地区的收入</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> index index位置及之后的司机分配的最大钱数</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> restForA A地区剩余的人数</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">process</span><span class=\"params\">(<span class=\"type\">int</span>[][] income, <span class=\"type\">int</span> index, <span class=\"type\">int</span> restForA, HashMap&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; cache)</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 先查询缓存是否已计算过 index-restForA 的组合</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (cache.containsKey(index) &amp;&amp; cache.get(index).containsKey(restForA)) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 缓存命中</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> cache.get(index).get(restForA);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (index == income.length) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// A地区人满了，剩下的司机都只能去B地区</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (restForA == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> income[index][<span class=\"number\">1</span>] + process(income, index + <span class=\"number\">1</span>, restForA, cache);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// B地区人满了，剩下的司机都只能去A地区</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (income.length - index == restForA) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> income[index][<span class=\"number\">0</span>] + process(income, index + <span class=\"number\">1</span>, restForA - <span class=\"number\">1</span>, cache);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"comment\">// A/B地区都没满，比较当前人去A或者去B两种方案的最大值</span></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">planA</span> <span class=\"operator\">=</span> income[index][<span class=\"number\">0</span>] + process(income, index + <span class=\"number\">1</span>, restForA - <span class=\"number\">1</span>, cache);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">planB</span> <span class=\"operator\">=</span> income[index][<span class=\"number\">1</span>] + process(income, index + <span class=\"number\">1</span>, restForA, cache);</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> Math.max(planA, planB);</span><br><span class=\"line\">       <span class=\"comment\">// 添加到缓存中</span></span><br><span class=\"line\">       cache.put(index, <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(restForA, ans));</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 动态规划填表做法</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> income</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">driverMaxMoneyByDP</span><span class=\"params\">(<span class=\"type\">int</span>[][] income)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> income.length;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">M</span> <span class=\"operator\">=</span> N &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"comment\">// dp[i][j]表示第i个司机及以后，A地区有i个位置，分配的最大收入</span></span><br><span class=\"line\">       <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[N+<span class=\"number\">1</span>][M+<span class=\"number\">1</span>];</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> N-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> ; i--) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt;= M; j++) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// A区人满了，只能去B区</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (j == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                   dp[i][j] = income[i][<span class=\"number\">1</span>] + dp[i+<span class=\"number\">1</span>][j];</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"comment\">// B区人满了，只能去A区</span></span><br><span class=\"line\">               <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (N - i == j) &#123;</span><br><span class=\"line\">                   dp[i][j] = income[i][<span class=\"number\">0</span>] + dp[i+<span class=\"number\">1</span>][j-<span class=\"number\">1</span>];</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"comment\">// A/B地区都没满</span></span><br><span class=\"line\">               <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">// 当前人去A情况下，获取的整体最大收入</span></span><br><span class=\"line\">                   <span class=\"type\">int</span> <span class=\"variable\">planA</span> <span class=\"operator\">=</span> income[i][<span class=\"number\">0</span>] + dp[i+<span class=\"number\">1</span>][j-<span class=\"number\">1</span>];</span><br><span class=\"line\">                   <span class=\"comment\">// 当前人去B情况下，获取的整体最大收入</span></span><br><span class=\"line\">                   <span class=\"type\">int</span> <span class=\"variable\">planB</span> <span class=\"operator\">=</span> income[i][<span class=\"number\">1</span>] + dp[i+<span class=\"number\">1</span>][j];</span><br><span class=\"line\">                   dp[i][j] = Math.max(planA, planB);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][M];</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2\n所使用的最少操作数。你可以对一个单词进行如下三种操作：</p>\n<ul>\n<li><p>插入一个字符</p></li>\n<li><p>删除一个字符</p></li>\n<li><p>替换一个字符</p>\n<p>https://leetcode-cn.com/problems/edit-distance</p></li>\n</ul>\n</blockquote>\n<figure>\n<img src=\"/images/algorithm/b466c347b42065b3a52b5257ce11b80.jpg\" alt=\"b466c347b42065b3a52b5257ce11b80\">\n<figcaption aria-hidden=\"true\">b466c347b42065b3a52b5257ce11b80</figcaption>\n</figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minDistance</span><span class=\"params\">(String word1, String word2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span>[] arr1 = word1.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">char</span>[] arr2 = word2.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> arr1.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">M</span> <span class=\"operator\">=</span> arr2.length;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j]表示word1[0:i]到word2[0:j]的最短编辑距离</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[N+<span class=\"number\">1</span>][M+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 初始化dp矩阵边界</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= M; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= M; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (arr1[i-<span class=\"number\">1</span>] == arr2[j-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.min(dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>], Math.min(dp[i-<span class=\"number\">1</span>][j], dp[i][j-<span class=\"number\">1</span>])) + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[N][M];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>给定三个字符串s1、s2、s3，请你帮忙验证s3是否是由s1和s2交错组成的</p>\n<p>https://leetcode-cn.com/problems/interleaving-string/</p>\n<p><img src=\"/images/algorithm/20220430205817.jpg\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isInterleave</span><span class=\"params\">(String s1, String s2, String s3)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.length() + s2.length() != s3.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">char</span>[] c1 = s1.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">char</span>[] c2 = s2.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">char</span>[] c3 = s3.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> c1.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">M</span> <span class=\"operator\">=</span> c2.length;</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[N+<span class=\"number\">1</span>][M+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 初始化dp边界</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = c1[i-<span class=\"number\">1</span>] == c3[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!dp[i][<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= M; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = c2[i-<span class=\"number\">1</span>] == c3[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!dp[<span class=\"number\">0</span>][i]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 根据dp方程求dp[i][j]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= M; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = (c3[i + j - <span class=\"number\">1</span>] == c1[i-<span class=\"number\">1</span>] &amp;&amp; dp[i-<span class=\"number\">1</span>][j]) ||</span><br><span class=\"line\">                        (c3[i + j - <span class=\"number\">1</span>] == c2[j-<span class=\"number\">1</span>] &amp;&amp; dp[i][j-<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[N][M];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，可以任意切分成若干个不相交的子数组。其中一定存在一种最优方案，使得切出异或和为0的子数组最多，返回这个最多数量</p>\n<p><img src=\"/images/algorithm/20220504151045.jpg\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">mostXor2</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[N];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">xor</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; xorMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        xorMap.put(<span class=\"number\">0</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = arr[<span class=\"number\">0</span>] == <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">        xorMap.put(arr[<span class=\"number\">0</span>], <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果arr[i]在最后一个异或和为0的子数组中</span></span><br><span class=\"line\">            <span class=\"comment\">// 计算xor[0:i]</span></span><br><span class=\"line\">            xor ^= arr[i];</span><br><span class=\"line\">            <span class=\"comment\">// 由于 a ^ 0 = a，假设最后一个异或和为0的分割子数组为last_xor_zero_arr</span></span><br><span class=\"line\">            <span class=\"comment\">// 则 xor ^ last_xor_zero_arr = xor，last_xor_zero_arr 的位置通过查询xor上一次出现的位置确定</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (xorMap.containsKey(xor)) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> xorMap.get(xor);</span><br><span class=\"line\">                dp[i] = pre == -<span class=\"number\">1</span> ? <span class=\"number\">1</span> : (dp[pre] + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dp[i] = Math.max(dp[i], dp[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">            xorMap.put(xor, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[N-<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n","categories":["algorithm"],"tags":["dynamic-program"]},{"title":"算法-前缀树","url":"/2022/05/03/algorithm/prefix-tree/","content":"<blockquote>\n<p>前缀树相关算法题</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，返回arr的最大连续子数组异或和</p>\n</blockquote>\n<p><img src=\"/images/algorithm/20220501000325.jpg\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，返回arr的最大子数组异或和</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">MaxXOR</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 对 arr 中所有数字构建前缀树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">xor</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"type\">NumTree</span> <span class=\"variable\">tree</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NumTree</span>();</span><br><span class=\"line\">        tree.add(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 以i为结尾的子数组的异或和</span></span><br><span class=\"line\">            xor ^= arr[i];</span><br><span class=\"line\">            max = Math.max(max, tree.searchMaxXOR(xor));</span><br><span class=\"line\">            tree.add(xor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        Node[] nexts = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NumTree</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 向前缀树中插入一个数字（对应一条路径）</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> num</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> num)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">move</span> <span class=\"operator\">=</span> <span class=\"number\">31</span>; move &gt;= <span class=\"number\">0</span> ; move--) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> (num &gt;&gt; move) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">                cur.nexts[path] = cur.nexts[path] == <span class=\"literal\">null</span> ? <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>() : cur.nexts[path];</span><br><span class=\"line\">                cur = cur.nexts[path];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 在前缀树中寻找最大的异或结果的数字</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> num</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">searchMaxXOR</span><span class=\"params\">(<span class=\"type\">int</span> num)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">move</span> <span class=\"operator\">=</span> <span class=\"number\">31</span>; move &gt;= <span class=\"number\">0</span> ; move--) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> (num &gt;&gt; move) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">best</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur.nexts[<span class=\"number\">0</span>] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    best = path;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur.nexts[<span class=\"number\">1</span>] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    best = Math.max(best, path ^ <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans |= (best &lt;&lt; move);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，想知道arr中哪两个数的异或结果最大，返回最大的异或结果</p>\n<p>https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前缀树结构同上题</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findMaximumXOR</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NumTree</span> <span class=\"variable\">numTree</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NumTree</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            numTree.add(nums[i]);</span><br><span class=\"line\">            max = Math.max(max, numTree.searchMaxXOR(nums[i]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>给定一个非负整数组成的数组nums。另有一个查询数组queries，其中queries[i]=[xi,\nmi]，第i个查询的答案是xi和任何nums数组中不超过mi的元素按位异或（XOR）得到的最大值</p>\n<p>https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/</p>\n<p>思路：若在每次查询时，用mi进行过滤后再加入到前缀树中，前缀树无法复用，故考虑在前缀树中加入限制，在搜索过程中使用mi判断</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        Node[] nexts = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> minLimit;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">(<span class=\"type\">int</span> minLimit)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.minLimit = minLimit;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.minLimit = Integer.MAX_VALUE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NumTreeWithMinNum</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> num)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">31</span>; i &gt;= <span class=\"number\">0</span> ; i--) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">sign</span> <span class=\"operator\">=</span> (num &gt;&gt; i) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur.nexts[sign] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    cur.nexts[sign] = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(num);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    cur.nexts[sign].minLimit = Math.min(cur.nexts[sign].minLimit, num);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cur = cur.nexts[sign];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">searchMaxXORWithMinLimit</span><span class=\"params\">(<span class=\"type\">int</span> num, <span class=\"type\">int</span> minLimit)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">maxXOR</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">31</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; i &gt;= <span class=\"number\">0</span> ; i--) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> (num &gt;&gt; i) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 期望的最优路径</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">best</span> <span class=\"operator\">=</span> i == <span class=\"number\">31</span> ? path : path ^ <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 判断最优路径是否存在，且满足minLimit限制，如果不存在走另外一条</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur.nexts[best] == <span class=\"literal\">null</span> || cur.nexts[best].minLimit &gt; minLimit) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cur.nexts[path].minLimit &gt; minLimit) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    best = path;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                maxXOR |= (path ^ best) &lt;&lt; i;</span><br><span class=\"line\">                cur = cur.nexts[best];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> maxXOR;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] maximizeXor(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span>[][] queries) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || queries == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">NumTreeWithMinNum</span> <span class=\"variable\">tree</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NumTreeWithMinNum</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            tree.add(nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[queries.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class=\"line\">            ans[i] = tree.searchMaxXORWithMinLimit(queries[i][<span class=\"number\">0</span>], queries[i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["algorithm"],"tags":["前缀树"]},{"title":"数据结构-堆","url":"/2022/05/31/algorithm/heap/","content":"<blockquote>\n<p>数据结构——堆</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"概念与性质\">概念与性质</h3>\n<p>堆是一个完全二叉树</p>\n<p>大根堆：每个子树的最大值都是头节点</p>\n<p>小根堆：每个子树的最小值都是头节点</p>\n<p>将堆元素按照层次遍历放到一个数组中，则i位置的节点的左孩子位置为2*i+1，右孩子的位置为2*i+2，父节点的位置为(i-1)/2</p>\n<h3 id=\"大根堆\">大根堆</h3>\n<h4 id=\"堆中元素用什么存储\">堆中元素用什么存储</h4>\n<p>很直观的感受，大根堆应该用二叉树来存储数据，不过由于为了维护大根堆的性质，比如需要交换堆顶元素与堆底元素，用二叉树不方便</p>\n<p>由于大根堆是满二叉树，每个节点与其父节点、孩子节点在数组下标上有规律可循（见上文），故用<strong>数组</strong>存储堆中元素</p>\n<h4 id=\"堆大小\">堆大小</h4>\n<p>既然堆中元素用数组存储，由于数组长度在申请内存空间时即设定，需要用一个单独的变量（heapSize）记录堆中元素的个数，如数组长度为100，heapSize=20</p>\n<h4 id=\"堆的基本操作\">堆的基本操作</h4>\n<h5 id=\"节点上升\">节点上升</h5>\n<p>对于任意节点，如果大于父节点（通过访问(i-1)/2位置找到父节点），与父节点交互，再与新的父节点比较，直到小于父节点或到达根节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">siftUp</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (arr[index] &gt; arr[(index - <span class=\"number\">1</span>) / <span class=\"number\">2</span>]) &#123;</span><br><span class=\"line\">        swap(arr, index, (index - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        index = (index - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"节点下沉\">节点下沉</h5>\n<p>对于任意节点，如果小于较大的子节点，交换，直到不小于较大子节点或到达叶子节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">siftDown</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> index, <span class=\"type\">int</span> heapSize)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">leftChildIndex</span> <span class=\"operator\">=</span> index * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (leftChildIndex &lt;heapSize) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">largest</span> <span class=\"operator\">=</span> leftChildIndex + <span class=\"number\">1</span> &lt; heapSize &amp;&amp; arr[leftChildIndex + <span class=\"number\">1</span>] &gt; arr[leftChildIndex] ?</span><br><span class=\"line\">                leftChildIndex + <span class=\"number\">1</span> : leftChildIndex;</span><br><span class=\"line\">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest == index) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(arr, index, largest);</span><br><span class=\"line\">        index = largest;</span><br><span class=\"line\">        leftChildIndex = index * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"向堆中插入元素\">向堆中插入元素</h5>\n<p>将堆大小加一，插入的元素放在数组末尾（堆尾），再将堆尾节点上升</p>\n<figure>\n<img src=\"/images/algorithm/image-20220604151952452.png\" alt=\"image-20220604152134239\">\n<figcaption aria-hidden=\"true\">image-20220604152134239</figcaption>\n</figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size &gt;= arr.length) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 数组扩容：复制已有值，长度变为原来的二倍</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.grow();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.size ++;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.arr[<span class=\"built_in\">this</span>.size-<span class=\"number\">1</span>] = n;</span><br><span class=\"line\">    <span class=\"comment\">// 将数组末尾元素上升</span></span><br><span class=\"line\">    siftUp(<span class=\"built_in\">this</span>.arr, <span class=\"built_in\">this</span>.size-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"弹出最大值\">弹出最大值</h5>\n<p>将数组0位置元素（堆顶）与最后位置元素（堆尾）交互，有效长度减一，再将堆顶元素下沉</p>\n<figure>\n<img src=\"/images/algorithm/image-20220604161702736.png\" alt=\"image-20220604161702736\">\n<figcaption aria-hidden=\"true\">image-20220604161702736</figcaption>\n</figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">poll</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;堆已空，无法弹出元素&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    swap(<span class=\"built_in\">this</span>.arr, <span class=\"number\">0</span>, <span class=\"built_in\">this</span>.size-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.size --;</span><br><span class=\"line\">    <span class=\"comment\">// 新的堆顶元素下沉</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.siftDown(<span class=\"built_in\">this</span>.arr, <span class=\"number\">0</span>, <span class=\"built_in\">this</span>.size);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"堆排序\">堆排序</h4>\n<p>问题描述：给定一个无序数组，将其升序排列</p>\n<p>思路：</p>\n<ol type=\"1\">\n<li>将无序数组构造为大顶堆</li>\n<li>将堆顶（最大值）弹出（与数组末尾元素交互，堆大小减一，新堆顶下沉）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 构造堆结构</span></span><br><span class=\"line\">    <span class=\"comment\">// 从上至下，依次上升</span></span><br><span class=\"line\"><span class=\"comment\">//    for (int i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        siftUp(arr, i);</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 从下至上，依次下沉</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        siftDown(arr, i, arr.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 弹出</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">heapSize</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (heapSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        swap(arr, <span class=\"number\">0</span>, --heapSize);</span><br><span class=\"line\">        siftDown(arr, <span class=\"number\">0</span>, heapSize);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思考：将无序数组构造大顶堆有几种方式，哪种最快</p>\n<table>\n<colgroup>\n<col style=\"width: 25%\">\n<col style=\"width: 11%\">\n<col style=\"width: 63%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>构造大顶堆的方式</th>\n<th>是否正确</th>\n<th>效率分析</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>自上而下，依次上升</td>\n<td>正确</td>\n<td>对于一个节点，最坏情况：从叶子节点上升至根节点</td>\n</tr>\n<tr class=\"even\">\n<td>自下而上，依次上升</td>\n<td>错误</td>\n<td>-</td>\n</tr>\n<tr class=\"odd\">\n<td>自上而下，依次下沉</td>\n<td>错误</td>\n<td>-</td>\n</tr>\n<tr class=\"even\">\n<td>自下而上，依次下沉</td>\n<td>正确</td>\n<td>对于一个节点，最坏情况：从根节点下沉到叶子节点</td>\n</tr>\n</tbody>\n</table>\n<p>直观感受：由于满二叉树中，叶子节点个数为N/2，非叶子节点个数为N/2，上升或下沉的时间复杂度与路径长度有关，最长为logN，如果自上而下，依次上升，导致大部分节点要上升的路径很长；如果自下而上，依次下沉，叶子节点不需要变动，大部分节点下沉的路径很短</p>\n<p>时间复杂度分析：待补充</p>\n<p>故采用<strong>自下而上，依次下沉</strong>的方式来将数组构造为大顶堆</p>\n<h3 id=\"大根堆的完整代码\">大根堆的完整代码</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Heap</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">Integer</span> <span class=\"variable\">DEFAULT_INITIAL_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">11</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span>[] arr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Heap</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Heap</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getSize</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 扩容</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.arr = Arrays.copyOf(<span class=\"built_in\">this</span>.arr, oldCapacity * <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 向堆中插入一个数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> n</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.size &gt;= arr.length) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.grow();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.arr[<span class=\"built_in\">this</span>.size] = n;</span><br><span class=\"line\">        siftUp(<span class=\"built_in\">this</span>.arr, <span class=\"built_in\">this</span>.size);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size ++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">peek</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 弹出堆顶数字</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">poll</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;堆已空，无法弹出元素&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">        swap(<span class=\"built_in\">this</span>.arr, <span class=\"number\">0</span>, <span class=\"built_in\">this</span>.size-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size --;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.siftDown(<span class=\"built_in\">this</span>.arr, <span class=\"number\">0</span>, <span class=\"built_in\">this</span>.size);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 构造堆结构</span></span><br><span class=\"line\">        <span class=\"comment\">// 从上至下，依次上升</span></span><br><span class=\"line\"><span class=\"comment\">//        for (int i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            siftUp(arr, i);</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// 从下至上，依次下沉</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            siftDown(arr, i, arr.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 弹出</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">heapSize</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (heapSize &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            swap(arr, <span class=\"number\">0</span>, --heapSize);</span><br><span class=\"line\">            siftDown(arr, <span class=\"number\">0</span>, heapSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将index位置数字上升</span></span><br><span class=\"line\"><span class=\"comment\">     * 直到父节点比当前节点大，或已经是根节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">siftUp</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (arr[index] &gt; arr[(index - <span class=\"number\">1</span>) / <span class=\"number\">2</span>]) &#123;</span><br><span class=\"line\">            swap(arr, index, (index - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">            index = (index - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从index位置开始，不断下沉</span></span><br><span class=\"line\"><span class=\"comment\">     * 直到较大的子孩子比index位置的数小，或已经没有孩子了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">siftDown</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> index, <span class=\"type\">int</span> heapSize)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">leftChildIndex</span> <span class=\"operator\">=</span> index * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (leftChildIndex &lt;heapSize) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">largest</span> <span class=\"operator\">=</span> leftChildIndex + <span class=\"number\">1</span> &lt; heapSize &amp;&amp; arr[leftChildIndex + <span class=\"number\">1</span>] &gt; arr[leftChildIndex] ?</span><br><span class=\"line\">                    leftChildIndex + <span class=\"number\">1</span> : leftChildIndex;</span><br><span class=\"line\">            largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (largest == index) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(arr, index, largest);</span><br><span class=\"line\">            index = largest;</span><br><span class=\"line\">            leftChildIndex = index * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isEmpty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Heap&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;arr=&quot;</span> + Arrays.toString(arr) +</span><br><span class=\"line\">                <span class=\"string\">&quot;, size=&quot;</span> + size +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码中存在的问题：</p>\n<ol type=\"1\">\n<li>只支持单一类型</li>\n<li>数组扩容方式暴力，存在OOM隐患</li>\n<li>堆排序只支持升序</li>\n</ol>\n<p>思考：</p>\n<ol type=\"1\">\n<li>如何合理的让堆的数据动态扩容</li>\n</ol>\n<h2 id=\"jdk中priorityqueue代码解读\">JDK中PriorityQueue代码解读</h2>\n<h3 id=\"object-queue-的动态扩容方法\">Object[] queue 的动态扩容方法</h3>\n<blockquote>\n<p>由于每次扩容都需要拷贝整个数组，故需要控制扩容的次数不要太频繁；如果每次扩容量太大，可以减少扩容频率，但存在空间的浪费</p>\n<p>如何找到二者的平衡呢，下面是JDK的实现方案</p>\n</blockquote>\n<p>设置最小扩容量minCapacity，每次需要扩容时，扩容到原size的1.5倍，如果这个扩容量没有达到minCapacity，则直接扩容到minCapacity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> queue.length;</span><br><span class=\"line\">    <span class=\"comment\">// Double size if small; else grow by 50%</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class=\"line\">           minCapacity - oldCapacity, <span class=\"comment\">/* minimum growth */</span></span><br><span class=\"line\">           oldCapacity &lt; <span class=\"number\">64</span> ? oldCapacity + <span class=\"number\">2</span> : oldCapacity &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">                                      <span class=\"comment\">/* preferred growth */</span>);</span><br><span class=\"line\">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么-object-queue-前要加-transient\">为什么 Object[] queue\n前要加 transient</h3>\n<p>transient 令属性不再可序列化和反序列化</p>\n<p><strong>transient 的使用场景</strong>：一些不应该设为 static\n的属性，不进行序列化（静态属性不会被序列化），如 Logger\n实例，安全性的信息</p>\n<p><strong>transient 的原因</strong>：由于 Object[] queue\n的长度是动态扩容产生的，即根据heapSize，设定合理的queue长度，故queue中存在很多没有存储实际数据的空间，将\nqueue 整体直接序列化，可能存在空间浪费。通过 writeObject 序列化，可通过\nheapSize 自行控制，只序列化实际存储数据部分的queue；而利用 readObject\n反序列化时，先获取\nheapSize，再初始化queue中的值，并根据heapSize，动态设定合理的容量</p>\n","categories":["algorithm"],"tags":["heap"]},{"title":"栈与队列","url":"/2022/06/30/algorithm/stack-heap/","content":"<blockquote>\n<p>栈与队列相关算法题</p>\n</blockquote>\n<span id=\"more\"></span>\n<h4 id=\"用栈实现队列\"><a href=\"https://leetcode.cn/problems/implement-queue-using-stacks/\">232.\n用栈实现队列</a></h4>\n<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyQueue</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> toPeek;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        stack1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        stack2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.empty()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.toPeek = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack1.push(x);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size ++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack1.isEmpty()) &#123;</span><br><span class=\"line\">            stack2.push(stack1.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">toPop</span> <span class=\"operator\">=</span> stack2.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!stack2.empty()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.toPeek = stack2.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack2.isEmpty()) &#123;</span><br><span class=\"line\">            stack1.push(stack2.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size--;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> toPop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">peek</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.toPeek;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">empty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"用队列实现栈\"><a href=\"https://leetcode.cn/problems/implement-stack-using-queues/\">225.\n用队列实现栈</a></h4>\n<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code>\n和 <code>empty</code>）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyStack</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Queue&lt;Integer&gt; queue1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Queue&lt;Integer&gt; queue2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> top;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyStack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        queue1 = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        queue2 = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.top = x;</span><br><span class=\"line\">        queue1.add(x);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size ++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.empty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == size - <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.top = queue1.peek();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            queue2.add(queue1.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">toPop</span> <span class=\"operator\">=</span> queue1.poll();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue2.isEmpty()) &#123;</span><br><span class=\"line\">            queue1.add(queue2.poll());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size--;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> toPop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">top</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.top;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">empty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.size == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"有效的括号\"><a href=\"https://leetcode.cn/problems/valid-parentheses/\">20.\n有效的括号</a></h4>\n<p>给定一个只包括\n<code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code>\n的字符串 <code>s</code> ，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ol type=\"1\">\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">输入：s = &quot;([)]&quot;</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValid</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span> || s.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">char</span>[] chars = s.toCharArray();</span><br><span class=\"line\">        Stack&lt;Character&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (chars[i] == <span class=\"string\">&#x27;&#123;&#x27;</span> || chars[i] == <span class=\"string\">&#x27;[&#x27;</span> || chars[i] == <span class=\"string\">&#x27;(&#x27;</span>) &#123;</span><br><span class=\"line\">                stack.push(chars[i]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (stack.empty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (chars[i] == <span class=\"string\">&#x27;&#125;&#x27;</span> &amp;&amp; stack.pop() != <span class=\"string\">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (chars[i] == <span class=\"string\">&#x27;)&#x27;</span> &amp;&amp; stack.pop() != <span class=\"string\">&#x27;(&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (chars[i] == <span class=\"string\">&#x27;]&#x27;</span> &amp;&amp; stack.pop() != <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.empty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"逆波兰表达式求值\"><a href=\"https://leetcode.cn/problems/evaluate-reverse-polish-notation/\">150.\n逆波兰表达式求值</a></h4>\n<p>根据<a href=\"https://baike.baidu.com/item/逆波兰式/128437\">逆波兰表示法</a>，求表达式的值。</p>\n<p>有效的算符包括\n<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>\n。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>\n<p><strong>注意</strong> 两个整数之间的除法只保留整数部分。</p>\n<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为\n0 的情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class=\"line\">输出：9</span><br><span class=\"line\">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">evalRPN</span><span class=\"params\">(String[] tokens)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tokens == <span class=\"literal\">null</span> || tokens.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        Set&lt;String&gt; symbols = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        symbols.add(<span class=\"string\">&quot;+&quot;</span>);</span><br><span class=\"line\">        symbols.add(<span class=\"string\">&quot;-&quot;</span>);</span><br><span class=\"line\">        symbols.add(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        symbols.add(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 运算符</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (symbols.contains(tokens[i])) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">&quot;+&quot;</span>.equals(tokens[i])) &#123;</span><br><span class=\"line\">                    stack.push(b + a);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;-&quot;</span>.equals(tokens[i])) &#123;</span><br><span class=\"line\">                    stack.push(b - a);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;*&quot;</span>.equals(tokens[i])) &#123;</span><br><span class=\"line\">                    stack.push(b * a);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;/&quot;</span>.equals(tokens[i])) &#123;</span><br><span class=\"line\">                    stack.push(b / a);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 数字</span></span><br><span class=\"line\">            stack.add(Integer.valueOf(tokens[i]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["栈与队列"]},{"title":"股票买卖问题","url":"/2022/06/30/algorithm/stock-question/","content":"<blockquote>\n<p>股票买卖相关算法题</p>\n</blockquote>\n<span id=\"more\"></span>\n<h4 id=\"买卖股票的最佳时机\"><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/\">121.\n买卖股票的最佳时机</a></h4>\n<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素\n<code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>\n<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在\n<strong>未来的某一个不同的日子</strong>\n卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>\n<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回\n<code>0</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：[7,1,5,3,6,4]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class=\"line\">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 贪心法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prices == <span class=\"literal\">null</span> || prices.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxProfile</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 寻找最小左端点</span></span><br><span class=\"line\">            left = Math.min(left, prices[i]);</span><br><span class=\"line\">            <span class=\"comment\">// 寻找最大收益（当前价格与最小左端点值的差）</span></span><br><span class=\"line\">            maxProfile = Math.max(prices[i] - left, maxProfile);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxProfile;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 动态规划法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit2</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prices == <span class=\"literal\">null</span> || prices.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length][<span class=\"number\">2</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// dp[i][0] 代表第i天持有股票，持有股票，收益越大，说明股票价格越低</span></span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = Math.max(dp[i-<span class=\"number\">1</span>][<span class=\"number\">0</span>], -prices[i]);</span><br><span class=\"line\">            <span class=\"comment\">// dp[i][1] 代表第i天不持有股票，卖出股票，收益越大，说明股票价格越高</span></span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = Math.max(dp[i-<span class=\"number\">1</span>][<span class=\"number\">1</span>], dp[i-<span class=\"number\">1</span>][<span class=\"number\">0</span>] + prices[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[dp.length-<span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"买卖股票的最佳时机-ii技\"><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/\">122.\n买卖股票的最佳时机 II</a>【技】</h4>\n<p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code>\n表示某支股票第 <code>i</code> 天的价格。</p>\n<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候\n<strong>最多</strong> 只能持有 <strong>一股</strong>\n股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。返回\n你能获得的 <strong>最大</strong> 利润</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：prices = [7,1,5,3,6,4]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class=\"line\">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class=\"line\">     总利润为 4 + 3 = 7</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxProfit</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 假设prices=[1,3,5], 1-5 与 1-3,3-5 的收益是一样的</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">diff</span> <span class=\"operator\">=</span> prices[i] - prices[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (diff &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                maxProfit += diff;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxProfit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["贪心","动态规划"]},{"title":"算法题-目录","url":"/2022/04/08/algorithm/menu/","content":"<blockquote>\n<p>算法题目录</p>\n</blockquote>\n<span id=\"more\"></span>\n<a href=\"/2022/04/21/algorithm/array/\" title=\"算法-线性表\">算法-数组</a>\n<p><br></p>\n<a href=\"/2022/04/18/algorithm/binary-tree/\" title=\"算法-二叉树\">算法-二叉树</a>\n<p><br></p>\n<a href=\"/2022/05/03/algorithm/prefix-tree/\" title=\"算法-前缀树\">算法-前缀树</a>\n<p><br></p>\n<a href=\"/2022/04/23/algorithm/bit-operation/\" title=\"算法-位运算\">算法-位运算</a>\n<p><br></p>\n<a href=\"/2022/04/23/algorithm/dynamic-program/\" title=\"算法-动态规划\">算法-动态规划</a>\n<p><br></p>\n<a href=\"/2022/04/21/algorithm/hashmap/\" title=\"算法-哈希表\">算法-哈希表</a>\n<p><br></p>\n<a href=\"/2022/04/23/algorithm/string/\" title=\"算法-字符串\">算法-字符串</a>\n<p><br></p>\n<a href=\"/2022/04/27/algorithm/greedy/\" title=\"算法-贪心\">算法-贪心</a>\n","categories":["algorithm"],"tags":["interview","algorithm"]},{"title":"算法-字符串","url":"/2022/04/23/algorithm/string/","content":"<blockquote>\n<p>字符串相关算法</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>求一个字符串中，最长无重复字符子串长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span> || s.equals(<span class=\"string\">&quot;&quot;</span>)) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"type\">char</span>[] str = s.toCharArray();</span><br><span class=\"line\">       <span class=\"comment\">// 记录每个字符最后一次出现的位置</span></span><br><span class=\"line\">       <span class=\"type\">int</span>[] map = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">256</span>; i++) &#123;</span><br><span class=\"line\">           map[i] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">longestLength</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">       map[str[<span class=\"number\">0</span>]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> str.length;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 假设后面的字符都不重复的最大值，还小于以求的最大值，则后面的位置不会出现最大值</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (pre + N - i &lt; longestLength) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           pre = Math.min(pre + <span class=\"number\">1</span>, i - map[str[i]]);</span><br><span class=\"line\">           longestLength = Math.max(longestLength, pre);</span><br><span class=\"line\">           map[str[i]] = i;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> longestLength;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>只由小写字母（a~z）组成的一批字符串，都放在字符类型的数组String[]\narr中，如果其中某两个字符串所含有的字符种类完全一样\n就将两个字符串算作一类，比如baacbba和bac就算作一类，返回arr中有多少类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">stringTypes</span><span class=\"params\">(String[] arr)</span> &#123;</span><br><span class=\"line\">       HashSet&lt;Integer&gt; hashSet = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (String s : arr) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 将字符串的字符映射到32位字节数组中，只用到低26位</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">           <span class=\"type\">char</span>[] chars = s.toCharArray();</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : chars) &#123;</span><br><span class=\"line\">               type |= (<span class=\"number\">1</span> &lt;&lt; (c - <span class=\"string\">&#x27;a&#x27;</span>));</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           hashSet.add(type);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> hashSet.size();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>假设所有字符都是小写字母，大字符串是str，arr是去重的单词表,\n每个单词都不是空字符串且可以使用任意次。使用arr中的单词有多少种拼接str的方式，返回方法数</p>\n<p><img src=\"/images/algorithm/20220513003630.jpg\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">wordBreak</span><span class=\"params\">(String str, String[] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str == <span class=\"literal\">null</span> || str.equals(<span class=\"string\">&quot;&quot;</span>) || arr == <span class=\"literal\">null</span> || arr.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(Arrays.asList(arr));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> splitWord(<span class=\"number\">0</span>, str, set, cache);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">splitWord</span><span class=\"params\">(<span class=\"type\">int</span> start, String str, Set&lt;String&gt; set, Map&lt;Integer, Integer&gt; cache)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.containsKey(start)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache.get(start);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">N</span> <span class=\"operator\">=</span> str.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == N) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">prefix</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; N; i++) &#123;</span><br><span class=\"line\">            prefix.append(str.charAt(i));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!set.contains(prefix.toString())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count += splitWord(i+<span class=\"number\">1</span>, str, set, cache);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cache.put(start, count);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["algorithm"],"tags":["algorithm"]},{"title":"算法-回溯","url":"/2022/06/16/algorithm/trace-back/","content":"<blockquote>\n<p>回溯相关算法题</p>\n</blockquote>\n<span id=\"more\"></span>\n<h4 id=\"组合基\"><a href=\"https://leetcode.cn/problems/combinations/\">77.\n组合</a>【基】</h4>\n<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围\n<code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 4, k = 2</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TraceBack</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        trace(n, k, <span class=\"number\">1</span>, path, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 回溯过程</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> n 数字的范围</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> k 回溯树的深度</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> startNum 当前回溯层的开始值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> path 一条回溯路径</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> result 所有回溯路径</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k, <span class=\"type\">int</span> startNum, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 减支：如果当前层不能满足k的深度要求，不向下搜索</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n - startNum + <span class=\"number\">1</span> &lt; k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 回溯到最下面一层（叶子节点）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 新创建一个list，用一个list会干扰</span></span><br><span class=\"line\">            result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当前层，从开始数字遍历到n，如 [3,4,5]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startNum; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            path.add(i);</span><br><span class=\"line\">            <span class=\"comment\">// 下一层，深度-1，如i=3，下一层应为[4,5]</span></span><br><span class=\"line\">            trace(n, k - <span class=\"number\">1</span>, i + <span class=\"number\">1</span>, path, result);</span><br><span class=\"line\">            path.remove(path.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"组合总和-iii\"><a href=\"https://leetcode.cn/problems/combination-sum-iii/\">216. 组合总和\nIII</a></h4>\n<p>找出所有相加之和为 <code>n</code> 的 <code>k</code>\n个数的组合，且满足下列条件：</p>\n<ul>\n<li>只使用数字1到9</li>\n<li>每个数字 <strong>最多使用一次</strong></li>\n</ul>\n<p>返回 <em>所有可能的有效组合的列表</em>\n。该列表不能包含相同的组合两次，组合可以以任何顺序返回</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: k = 3, n = 9</span><br><span class=\"line\">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combinationSum3</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        traceForCombinationSum3(k, n, <span class=\"number\">1</span>, <span class=\"number\">0</span>, path, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traceForCombinationSum3</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n, <span class=\"type\">int</span> start, <span class=\"type\">int</span> sum, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == n &amp;&amp; k == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &gt; n || k == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 回溯过程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt;= <span class=\"number\">9</span>; i++) &#123;</span><br><span class=\"line\">            path.add(i);</span><br><span class=\"line\">            traceForCombinationSum3(k-<span class=\"number\">1</span>, n, i+<span class=\"number\">1</span>, sum + i, path, res);</span><br><span class=\"line\">            path.remove(path.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"电话号码的字母组合\"><a href=\"https://leetcode.cn/problems/letter-combinations-of-a-phone-number/\">17.\n电话号码的字母组合</a></h4>\n<p>给定一个仅包含数字 <code>2-9</code>\n的字符串，返回所有它能表示的字母组合。答案可以按\n<strong>任意顺序</strong> 返回。</p>\n<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：digits = &quot;23&quot;</span><br><span class=\"line\">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">letterCombinations</span><span class=\"params\">(String digits)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (digits == <span class=\"literal\">null</span> || <span class=\"string\">&quot;&quot;</span>.equals(digits)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">char</span>[][] telephone = &#123;</span><br><span class=\"line\">                &#123;&#125;,</span><br><span class=\"line\">                &#123;&#125;,</span><br><span class=\"line\">                &#123;<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"string\">&#x27;g&#x27;</span>, <span class=\"string\">&#x27;h&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"string\">&#x27;j&#x27;</span>, <span class=\"string\">&#x27;k&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"string\">&#x27;m&#x27;</span>, <span class=\"string\">&#x27;n&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"string\">&#x27;p&#x27;</span>, <span class=\"string\">&#x27;q&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>, <span class=\"string\">&#x27;s&#x27;</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"string\">&#x27;t&#x27;</span>, <span class=\"string\">&#x27;u&#x27;</span>, <span class=\"string\">&#x27;v&#x27;</span>&#125;,</span><br><span class=\"line\">                &#123;<span class=\"string\">&#x27;w&#x27;</span>, <span class=\"string\">&#x27;x&#x27;</span>, <span class=\"string\">&#x27;y&#x27;</span>, <span class=\"string\">&#x27;z&#x27;</span>&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        List&lt;String&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        traceForLetterCombinations(digits, <span class=\"number\">0</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"string\">&quot;&quot;</span>), res, telephone);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traceForLetterCombinations</span><span class=\"params\">(String digits, <span class=\"type\">int</span> index, StringBuilder s,</span></span><br><span class=\"line\"><span class=\"params\">                                            List&lt;String&gt; res, <span class=\"type\">char</span>[][] telephone)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 回溯一条路径的结束条件：当到达最下面一层（叶子节点），终止</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == digits.length()) &#123;</span><br><span class=\"line\">            res.add(s.toString());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">number</span> <span class=\"operator\">=</span> digits.charAt(index) - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"type\">char</span>[] chars = telephone[number];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class=\"line\">            s.append(chars[i]);</span><br><span class=\"line\">            traceForLetterCombinations(digits, index + <span class=\"number\">1</span>, s, res, telephone);</span><br><span class=\"line\">            s.deleteCharAt(s.length() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"组合总和难\"><a href=\"https://leetcode.cn/problems/combination-sum/\">39.\n组合总和</a>【难】</h4>\n<p>给你一个 <strong>无重复元素</strong> 的整数数组\n<code>candidates</code> 和一个目标整数 <code>target</code> ，找出\n<code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的\n<em>所有</em> <strong>不同组合</strong> ，并以列表形式返回。你可以按\n<strong>任意顺序</strong> 返回这些组合。</p>\n<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以\n<strong>无限制重复被选取</strong>\n。如果至少一个数字的被选数量不同，则两种组合是不同的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: candidates = [2,3,5], target = 8</span><br><span class=\"line\">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combinationSum</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidates == <span class=\"literal\">null</span> || candidates.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        traceForCombinationSum(candidates, <span class=\"number\">0</span>, target, <span class=\"number\">0</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traceForCombinationSum</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> sum, <span class=\"type\">int</span> target, <span class=\"type\">int</span> start,</span></span><br><span class=\"line\"><span class=\"params\">                                        List&lt;Integer&gt; arr, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &gt; target) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(arr));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 回溯过程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr.add(candidates[i]);</span><br><span class=\"line\">            traceForCombinationSum(candidates, sum + candidates[i], target, i, arr, res);</span><br><span class=\"line\">            arr.remove(arr.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"组合总和-ii\"><a href=\"https://leetcode.cn/problems/combination-sum-ii/\">40. 组合总和\nII</a></h4>\n<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数\n<code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为\n<code>target</code> 的组合。</p>\n<p><code>candidates</code> 中的每个数字在每个组合中只能使用\n<strong>一次</strong> 。</p>\n<p><strong>注意：</strong>解集不能包含重复的组合。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[[1,1,6],[1,2,5],[1,7],[2,6]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combinationSum2</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (candidates == <span class=\"literal\">null</span> || candidates.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        traceForCombinationSum2(candidates, <span class=\"number\">0</span>, <span class=\"number\">0</span>, target, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traceForCombinationSum2</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> start, <span class=\"type\">int</span> sum, <span class=\"type\">int</span> target,</span></span><br><span class=\"line\"><span class=\"params\">                                         List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &gt; target) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            path.add(candidates[i]);</span><br><span class=\"line\">            traceForCombinationSum2(candidates, i + <span class=\"number\">1</span>, sum + candidates[i], target, path, res);</span><br><span class=\"line\">            path.remove(path.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>小结：组合问题都遇到了对原始数组排序，回溯过程中去重的方法，去重是只在同一层，跳过一些数值，防止组合结果重复</p>\n<h4 id=\"分割回文串\"><a href=\"https://leetcode.cn/problems/palindrome-partitioning/\">131.\n分割回文串</a></h4>\n<p>给你一个字符串 <code>s</code>，请你将 <code>s</code>\n分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回\n<code>s</code> 所有可能的分割方案。</p>\n<p><strong>回文串</strong> 是正着读和反着读都一样的字符串</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;aab&quot;</span><br><span class=\"line\">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; <span class=\"title function_\">partition</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;String&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span> || s.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trace(s, <span class=\"number\">0</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(String s, <span class=\"type\">int</span> start, List&lt;String&gt; palindrome, List&lt;List&lt;String&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() == start) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(palindrome));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">stringBuilder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            stringBuilder.append(s.charAt(i));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isPalindrome(stringBuilder.toString())) &#123;</span><br><span class=\"line\">                palindrome.add(stringBuilder.toString());</span><br><span class=\"line\">                trace(s, i + <span class=\"number\">1</span>, palindrome, res);</span><br><span class=\"line\">                palindrome.remove(palindrome.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断回文串</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> s</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span> || s.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len / <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) != s.charAt(len - i - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复原-ip-地址\"><a href=\"https://leetcode.cn/problems/restore-ip-addresses/\">93. 复原 IP\n地址</a></h4>\n<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于\n<code>0</code> 到 <code>255</code> 之间组成，且不能含有前导\n<code>0</code>），整数之间用 <code>'.'</code> 分隔。</p>\n<ul>\n<li>例如：<code>\"0.1.2.201\"</code> 和<code>\"192.168.1.1\"</code> 是\n<strong>有效</strong> IP 地址，但是\n<code>\"0.011.255.245\"</code>、<code>\"192.168.1.312\"</code> 和\n<code>\"192.168@1.1\"</code> 是 <strong>无效</strong> IP 地址。</li>\n</ul>\n<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP\n地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在\n<code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong>\n重新排序或删除 <code>s</code> 中的任何数字。你可以按\n<strong>任何</strong> 顺序返回答案</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;25525511135&quot;</span><br><span class=\"line\">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">restoreIpAddresses</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;String&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        List&lt;String&gt; ipList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span> || s.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ipList;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        traceForRestoreAIpAddresses(s, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), res);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; res.size(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">stringBuilder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; res.get(i).size(); j++) &#123;</span><br><span class=\"line\">                stringBuilder.append(res.get(i).get(j)).append(<span class=\"string\">&quot;.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stringBuilder.deleteCharAt(stringBuilder.length() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            ipList.add(stringBuilder.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ipList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traceForRestoreAIpAddresses</span><span class=\"params\">(String s, <span class=\"type\">int</span> start, <span class=\"type\">int</span> ipNum,</span></span><br><span class=\"line\"><span class=\"params\">                                             List&lt;String&gt; ip, List&lt;List&lt;String&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ipNum == <span class=\"number\">4</span> &amp;&amp; start != s.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ipNum == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(ip));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">strBuilder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; Math.min(start + <span class=\"number\">3</span>, s.length()); i++) &#123;</span><br><span class=\"line\">            strBuilder.append(s.charAt(i));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (availableIP(strBuilder.toString())) &#123;</span><br><span class=\"line\">                ip.add(strBuilder.toString());</span><br><span class=\"line\">                traceForRestoreAIpAddresses(s, i + <span class=\"number\">1</span>, ipNum + <span class=\"number\">1</span>, ip, res);</span><br><span class=\"line\">                ip.remove(ip.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断分割的字符串是否为有效IP</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> s</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">availableIP</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() &gt; <span class=\"number\">1</span> &amp;&amp; s.charAt(<span class=\"number\">0</span>) == <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> Integer.parseInt(s);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value &lt; <span class=\"number\">0</span> || value &gt; <span class=\"number\">255</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"子集\"><a href=\"https://leetcode.cn/problems/subsets/\">78.\n子集</a></h4>\n<p>给你一个整数数组 <code>nums</code> ，数组中的元素\n<strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3]</span><br><span class=\"line\">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">subsets</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        trace(nums, <span class=\"number\">0</span>, <span class=\"literal\">true</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">trace</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> start, <span class=\"type\">boolean</span> next, List&lt;Integer&gt; subSet, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(subSet));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            subSet.add(nums[i]);</span><br><span class=\"line\">            trace(nums, i+<span class=\"number\">1</span>, <span class=\"literal\">true</span>, subSet, res);</span><br><span class=\"line\">            subSet.remove(subSet.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"子集-ii\"><a href=\"https://leetcode.cn/problems/subsets-ii/\">90.\n子集 II</a></h4>\n<p>给你一个整数数组 <code>nums</code>\n，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）</p>\n<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按\n<strong>任意顺序</strong> 排列</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,2]</span><br><span class=\"line\">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">subsetsWithDup</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        traceForSubsetsWithDup(nums, <span class=\"number\">0</span>, <span class=\"literal\">true</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traceForSubsetsWithDup</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> start, <span class=\"type\">boolean</span> next,</span></span><br><span class=\"line\"><span class=\"params\">                                        List&lt;Integer&gt; subSet, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(subSet));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            subSet.add(nums[i]);</span><br><span class=\"line\">            traceForSubsetsWithDup(nums, i+<span class=\"number\">1</span>, <span class=\"literal\">true</span>, subSet, res);</span><br><span class=\"line\">            subSet.remove(subSet.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注：重点在于如果去重，与<a href=\"https://leetcode.cn/problems/combination-sum-ii/\">40. 组合总和\nII</a>思路相同</strong></p>\n<h4 id=\"递增子序列难\"><a href=\"https://leetcode.cn/problems/increasing-subsequences/\">491.\n递增子序列</a>【难】</h4>\n<p>给你一个整数数组 <code>nums</code>\n，找出并返回所有该数组中不同的递增子序列，递增子序列中\n<strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong>\n返回答案</p>\n<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [4,6,7,7]</span><br><span class=\"line\">输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">findSubsequences</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        traceForFindSubSequences(nums, <span class=\"number\">0</span>, <span class=\"literal\">false</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traceForFindSubSequences</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> start, <span class=\"type\">boolean</span> finish,</span></span><br><span class=\"line\"><span class=\"params\">                                          List&lt;Integer&gt; subsequence, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (finish) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(subsequence));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subsequence.size() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            traceForFindSubSequences(nums, start, <span class=\"literal\">true</span>, subsequence, res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (set.contains(nums[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (start - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> &amp;&amp; nums[i] &lt; nums[start - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set.add(nums[i]);</span><br><span class=\"line\">            subsequence.add(nums[i]);</span><br><span class=\"line\">            traceForFindSubSequences(nums, i+<span class=\"number\">1</span>, <span class=\"literal\">false</span>, subsequence, res);</span><br><span class=\"line\">            subsequence.remove(subsequence.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>去重条件为：本行遍历中出现重复的数字，就会导致最后结果重复</p>\n<p>思考：为什么<a href=\"https://leetcode.cn/problems/combination-sum-ii/\">40. 组合总和\nII</a>与<a href=\"https://leetcode.cn/problems/subsets-ii/\">90. 子集\nII</a>可以直接通过与前一个元素比较去重？</p>\n<p>原因：那两道题可以先对数组排序，让相等的数字连续出现，而本题要保证先对顺序，不能排序，故需要用set去重</p>\n<h4 id=\"全排列\"><a href=\"https://leetcode.cn/problems/permutations/\">46.\n全排列</a></h4>\n<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其\n<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong>\n返回答案</p>\n<figure class=\"highlight latex\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3]</span><br><span class=\"line\">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permute</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        traceForPermute(nums, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traceForPermute</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, List&lt;Integer&gt; permute, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (permute.size() == nums.length) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(permute));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (permute.contains(nums[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            permute.add(nums[i]);</span><br><span class=\"line\">            traceForPermute(nums, permute, res);</span><br><span class=\"line\">            permute.remove(permute.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"全排列-ii\"><a href=\"https://leetcode.cn/problems/permutations-ii/\">47. 全排列\nII</a></h4>\n<p>给定一个可包含重复数字的序列 <code>nums</code>\n，<strong><em>按任意顺序</em></strong> 返回所有不重复的全排列</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,1,2]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[[1,1,2],[1,2,1],[2,1,1]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permuteUnique</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        traceForPermuteUnique(nums, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(), res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traceForPermuteUnique</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, List&lt;Integer&gt; numIndexList, List&lt;Integer&gt; permuteUnique, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (permuteUnique.size() == nums.length) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(permuteUnique));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">preNum</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (numIndexList.contains(i)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (preNum == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                preNum = nums[i];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[i] == preNum) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                preNum = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            permuteUnique.add(nums[i]);</span><br><span class=\"line\">            numIndexList.add(i);</span><br><span class=\"line\">            traceForPermuteUnique(nums, numIndexList, permuteUnique, res);</span><br><span class=\"line\">            permuteUnique.remove(permuteUnique.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            numIndexList.remove(numIndexList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hard问题待做\">Hard问题待做</h4>\n<p><a href=\"https://leetcode.cn/problems/reconstruct-itinerary/\">332.\n重新安排行程</a></p>\n<p><a href=\"https://leetcode.cn/problems/n-queens/\">51. N 皇后</a></p>\n<p><a href=\"https://leetcode.cn/problems/sudoku-solver/\">37.\n解数独</a></p>\n<h3 id=\"总结\">总结</h3>\n<p>回溯问题存在明显的解题规律：</p>\n<ol type=\"1\">\n<li>画回溯树</li>\n<li>创建存放所有路径的二维数组（一般情况）</li>\n<li>写回溯函数\n<ol type=\"1\">\n<li>确定回溯结束条件，当一条路径结束，将该路径新创建一份，放到二维数组中</li>\n<li>对当前层遍历，减枝（去重：一般的，如果要求路径不能重复，则当前层一些重复值不能向下遍历）</li>\n<li>向下一层遍历，减枝（去重：与之前路径中不能重复，一般用起始位置，或直接在路径中判断是否存在）</li>\n<li>向上一层回溯（路径减去最后一个元素）</li>\n</ol></li>\n<li>返回带有所有路径的二维数组</li>\n</ol>\n","tags":["回溯"]},{"title":"硬件层面多 CPU 下的可见性问题","url":"/2023/02/02/computer-organization/cpu-memory-visibility/","content":"<blockquote>\n<p>本文介绍硬件层面多 CPU 下的可见性问题，主要包括：</p>\n<ol type=\"1\">\n<li>cpu 的多级缓存</li>\n<li>什么是可见性问题</li>\n<li>缓存一致性协议 MESI</li>\n<li>MESI 的问题与优化</li>\n<li>什么是指令重排以及指令重排产生的原因</li>\n<li>cpu 内存屏障</li>\n<li>伪共享问题</li>\n</ol>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"为什么会导致-cpu-内存可见性问题\">为什么会导致 CPU\n内存可见性问题</h2>\n<blockquote>\n<p>在讨论 CPU 内存可见性问题之前，首先介绍下 cpu 的多级缓存</p>\n</blockquote>\n<h3 id=\"cpu-多级缓存\">cpu 多级缓存</h3>\n<h4 id=\"来历\">来历</h4>\n<p>CPU 负责执行程序的指令，内存负责存数据。在很多年前，CPU\n的频率与内存总线的频率在同一层面上，内存的访问速度仅比寄存器慢一些。但是，上世纪\n90 年代 CPU\n的频率大大提升，但内存总线的频率与内存芯片的性能却没有得到成比例的提升。并不是因为造不出更快的内存，只是因为太贵了，内存如果要达到目前\nCPU 那样的速度，那么它的造价恐怕要贵上好几个数量级。所以，CPU\n的运算速度要比内存读写速度快很多。这样会使 CPU\n花费很长的时间等待数据的到来或把数据写入到内存中。所以，<strong>为了解决\nCPU\n运算速度与内存读写速度不匹配的矛盾</strong>，就出现了<strong>CPU缓存</strong></p>\n<h4 id=\"概念\">概念</h4>\n<p>CPU缓存：CPU与内存之间的数据交换器，它的容量比内存小的多但是交换速度却比内存要快得多，CPU缓存一般直接跟CPU芯片集成或位于主板总线互连的独立芯片上</p>\n<h4 id=\"作用\">作用</h4>\n<p>减小相应时间：CPU往往需要重复处理相同的数据、重复执行相同的指令，如果这部分数据、指令\nCPU 能在 CPU 缓存中找到，CPU\n就不需要从内存或硬盘中再读取数据、指令，从而减少了整机的响应时间。</p>\n<p>缓存的作用满足以下两种<strong>局部性原理</strong>：</p>\n<ul>\n<li><strong>时间局部性（Temporal\nLocality）</strong>：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</li>\n<li><strong>空间局部性（Spatial\nLocality）</strong>：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</li>\n</ul>\n<h4 id=\"结构\">结构</h4>\n<p>CPU 存在三级缓存：L1, L2, L3，其中，L1 又分为 L1d (L1 Data\nCache，用于存储数据) 和 L1i (L1 Instruction Cache，用于存储指令)，L2\n缓存比 L1 大一些，一般是每个 CPU 都有一个独立的 L2 缓存，L3\n是最大的一级，在同一个 CPU 插槽的 CPU 共享一个 L3 缓存</p>\n<figure>\n<img src=\"/images/jvm/cpu_cache.drawio.png\" alt=\"cpu_cache.drawio\">\n<figcaption aria-hidden=\"true\">cpu_cache.drawio</figcaption>\n</figure>\n<p>不同层级缓存读取数据速度的差异如下：</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: left;\">从CPU到</th>\n<th style=\"text-align: left;\">大约需要的CPU周期</th>\n<th style=\"text-align: left;\">大约需要的时间(单位ns)</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">寄存器</td>\n<td style=\"text-align: left;\">1 cycle</td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">L1 Cache</td>\n<td style=\"text-align: left;\">~3-4 cycles</td>\n<td style=\"text-align: left;\">~0.5-1 ns</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">L2 Cache</td>\n<td style=\"text-align: left;\">~10-20 cycles</td>\n<td style=\"text-align: left;\">~3-7 ns</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">L3 Cache</td>\n<td style=\"text-align: left;\">~40-45 cycles</td>\n<td style=\"text-align: left;\">~15 ns</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">跨槽传输</td>\n<td style=\"text-align: left;\"></td>\n<td style=\"text-align: left;\">~20 ns</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\">内存</td>\n<td style=\"text-align: left;\">~120-240 cycles</td>\n<td style=\"text-align: left;\">~60-120ns</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>速度比较：100 * L1 = 20 * L2 = 8 * L3 = 内存</p>\n</blockquote>\n<p>CPU\n获取数据，首先会在最快的缓存中找数据，如果缓存没有命中，则往下一级找，直到三级缓存都找不到，再到内存找数据</p>\n<h4 id=\"数据流\">数据流</h4>\n<ol type=\"1\">\n<li>程序以及数据被加载到主内存</li>\n<li>指令和数据被加载到 CPU 的高速缓存</li>\n<li>CPU 执行指令，把结果写到高速缓存</li>\n<li>高速缓存中的数据写回主内存</li>\n</ol>\n<p>在这个过程中，如果 CPU\n在高速缓存中已经找到数据，则不会到主内存中加载，这样多个 CPU\n同时工作，就可能产生同一份数据，在多个 CPU\n中值不一致的问题，我们称之为<strong>内存可见性问题</strong></p>\n<p>为了解决<strong>内存可见性问题</strong>，有两个办法，一个是总线锁，一个是使用一致性协议</p>\n<h3 id=\"硬件层面-cpu-内存可见性问题的解决方案\">硬件层面 CPU\n内存可见性问题的解决方案</h3>\n<h4 id=\"总线锁\">总线锁</h4>\n<p>涉及共享的变量存储的时候，总线锁使用处理器提供的一个 LOCK#\n信号，当一个处理器在总线上输出此信号时，对总线加锁，禁止其他线程读取内存；变量值写入到主内存变量后，才会解锁</p>\n<blockquote>\n<p>这里是不是还要清空其他 CPU 缓存中的变量</p>\n</blockquote>\n<p>由于总线锁会锁住整个内存，其他线程只能等待，效率太低，所以有了缓存一致性协议</p>\n<p>缓存一致性协议有 MSI，MESI，MOSI 等，下面介绍下 MESI</p>\n<h4 id=\"cpu缓存一致性协议mesi\">CPU缓存一致性协议(MESI)</h4>\n<h5 id=\"缓存行-cache-line\">缓存行 Cache line</h5>\n<p>在 L1，L2，L3\n中存储的数据不是以变量单独存储的，在每级缓存里以缓存行为单位存储，每个缓存行大小在32字节-256字节之间，缓存行大小通常为64字节（工业经验得出）</p>\n<p>缓存每次更新都是从主存中加载连续的 64 个字节</p>\n<p>下面介绍的 MESI 协议是基于一个 Cache line 的</p>\n<h5 id=\"mesi-协议的状态\">MESI 协议的状态</h5>\n<p>每个 Cache line 抽出 2bit 的位置，用来表示 4 个状态：M，E，S，I</p>\n<table>\n<colgroup>\n<col style=\"width: 17%\">\n<col style=\"width: 48%\">\n<col style=\"width: 11%\">\n<col style=\"width: 9%\">\n<col style=\"width: 13%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>状态</th>\n<th>含义</th>\n<th>缓存行是否有效</th>\n<th>数据存在位置</th>\n<th>与内存数据的比较</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>M 修改 Modified</td>\n<td>当前 CPU 缓存有最新数据， 其他 CPU 拥有失效数据，当前 CPU\n数据与内存不一致，但以当前 CPU 数据为准</td>\n<td>有效</td>\n<td>只在本缓存行</td>\n<td>不一致</td>\n</tr>\n<tr class=\"even\">\n<td>E 独享/互斥 Exclusize</td>\n<td>只有当前 CPU 有数据，其他 CPU 没有该数据，当前 CPU\n数据与内存数据一致</td>\n<td>有效</td>\n<td>只在本缓存行</td>\n<td>一致</td>\n</tr>\n<tr class=\"odd\">\n<td>S 共享 Shared</td>\n<td>当前 CPU 与其他 CPU 拥有相同数据，并与内存中数据一致</td>\n<td>有效</td>\n<td>多个缓存行</td>\n<td>一致</td>\n</tr>\n<tr class=\"even\">\n<td>I 无效 Invalid</td>\n<td>当前 CPU 数据失效，其他 CPU\n数据可能有可能无，数据应从内存中读取，且当前 CPU 与 内存数据不一致</td>\n<td>无效</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<p>对于 Cache line 的操作分为以下四种：</p>\n<ol type=\"1\">\n<li>Local Read（LR）：当前 CPU 读</li>\n<li>Local Write（LW）：当前 CPU 写</li>\n<li>Remote Read（RR）：其他 CPU 读</li>\n<li>Remote Write（RW）：其他 CPU 写</li>\n</ol>\n<blockquote>\n<p>当前 CPU 读写表示 CPU 操作自己的缓存行，其他 CPU 读写表示 CPU\n操作其他 CPU 的缓存行</p>\n<p>MESI\n是针对单个缓存行进行处理，如果数据超过一个缓存行的大小，无法使用缓存一致性对该数据控制，只能使用锁总线的方式</p>\n</blockquote>\n<p>那么当一个缓存行对应的内存被执行上面四种操作后，缓存行的状态会发生什么变化呢？各状态的转移如下图所示</p>\n<figure>\n<img src=\"/images/jvm/knk_2023-01-27_14-02-07.jpeg\" alt=\"knk_2023-01-27 14-02-07\">\n<figcaption aria-hidden=\"true\">knk_2023-01-27 14-02-07</figcaption>\n</figure>\n<p>说明：</p>\n<table>\n<colgroup>\n<col style=\"width: 13%\">\n<col style=\"width: 86%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>状态</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Modified</td>\n<td><strong>LR</strong>: 当前 CPU\n缓存中有最新数据，状态不变<br><strong>LW</strong>: 直接修改当前 CPU\n缓存，修改后仍拥有最新数据，状态不变<br><strong>RR</strong>: 其他 CPU\n方式读操作，为了保证一致性，当前 CPU 将数据写回内存，随后 RR\n将数据通知其他 CPU 更新缓存，使其他 CPU 拥有和当前 CPU\n相同的数据，状态改为 S<br><strong>RW</strong>: 其他 CPU\n写，本缓存失效，状态改为 I</td>\n</tr>\n<tr class=\"even\">\n<td>Exclusive</td>\n<td><strong>LR</strong>: 当前 CPU\n缓存中独享最新数据，状态不变<br><strong>LW</strong>: 修改当前 CPU\n缓存值，状态改为 M<br><strong>RR</strong>: 其他 CPU 读后，多个 CPU\n数据都与内存一致，状态改为 S<br><strong>RW</strong>: 其他 CPU\n写操作，其他 CPU 数据为最新，当前 CPU 数据失效，状态改为 I</td>\n</tr>\n<tr class=\"odd\">\n<td>Shared</td>\n<td><strong>LR</strong>: 当前 CPU\n读数据，状态不变<br><strong>LW</strong>: 当前 CPU\n写操作，并不会将数据立即写回内存，为了保证一致性，将状态修改为\nM<br><strong>RR</strong>: 其他 CPU 读操作，因为多个 CPU\n数据都与内存一致，状态不变<br><strong>RW</strong>: 其他 CPU\n写操作，其他 CPU 数据为最新，当前 CPU 数据失效，状态改为 I</td>\n</tr>\n<tr class=\"even\">\n<td>Invalid</td>\n<td><strong>LR</strong>: 当前 CPU 读，当前缓存不可用，需读内存，若其他\nCPU 无数据，当前 CPU 独享，状态改为 E；若其他 CPU 有数据且状态为\nS、E，状态改为 S；其他 CPU 有数据且状态为 M，其他 CPU\n先将数据写回内存，随后当前 CPU 读数据，状态改为\nS<br><strong>LW</strong>: 当前 CPU 写，状态变为\nM<br><strong>RR</strong>: 其他 CPU 读，与当前 CPU\n缓存无关，状态不变<br><strong>RW</strong>: 其他 CPU 写，与当前 CPU\n缓存无关，状态不变</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>总的来说，对于 MESI 协议，从 CPU 读写角度来说会遵循以下原则：</p>\n<p>CPU 读请求：缓存处于 M、E、S 状态都可以被读取，I 状态 CPU\n只能从主存中读取数据</p>\n<p>CPU 写请求：缓存处于 M、E 状态才可以被写。对于 S 状态的写，需要将其他\nCPU 中缓存行置为无效才可写</p>\n</blockquote>\n<h5 id=\"多核缓存协同操作的过程\">多核缓存协同操作的过程</h5>\n<p><strong>两个CPU同时读：</strong></p>\n<figure>\n<img src=\"/images/jvm/多核缓存协同过程-同时读.drawio.png\" alt=\"多核缓存协同过程-同时读.drawio\">\n<figcaption aria-hidden=\"true\">多核缓存协同过程-同时读.drawio</figcaption>\n</figure>\n<p><strong>一个CPU写，一个CPU读：</strong></p>\n<figure>\n<img src=\"/images/jvm/多核缓存一致性-修改.drawio.png\" alt=\"多核缓存一致性-修改.drawio\">\n<figcaption aria-hidden=\"true\">多核缓存一致性-修改.drawio</figcaption>\n</figure>\n<p><strong>两个CPU同时写：</strong></p>\n<figure>\n<img src=\"/images/jvm/多核缓存一致性-同时写.drawio.png\" alt=\"多核缓存一致性-同时写.drawio\">\n<figcaption aria-hidden=\"true\">多核缓存一致性-同时写.drawio</figcaption>\n</figure>\n<h4 id=\"mesi-的问题与优化\">MESI 的问题与优化</h4>\n<p>严格按照 MESI 协议，会有严重的性能问题，如：</p>\n<ol type=\"1\">\n<li>若 CPU0 发生 LW，首先要通知其他 CPU 将对应缓存行的状态改为\nI，等待其他 CPU 的确认回执，CPU0 在这段时间内都是阻塞状态</li>\n<li>若 CPU1 发生 RW，CPU0 需要将自身缓存失效并发送确认回执，当 RW\n事件很多时，实时处理时效时间存在很难，会有一定的延迟</li>\n</ol>\n<p>为了解决上述问题，引入了写缓冲区（Load Buffer）和失效队列（Invalid\nQueue）</p>\n<h5 id=\"写缓冲区load-buffer\">写缓冲区（Load Buffer）</h5>\n<p>写缓冲区是属于每个 CPU 的，当使用了写缓冲区后，每当发生 LW，当前 CPU\n不再阻塞地等待其他 CPU\n的确认回执，而是直接将更新的值写入写缓冲区，然后继续执行后续指令</p>\n<p>在进行 LR 时，CPU\n会先在写缓冲区中查询记录是否存在，如果存在则会从写缓冲区中直接获取，这一机制即是\nStore Fowarding</p>\n<h5 id=\"失效队列invalid-queue\">失效队列（Invalid Queue）</h5>\n<p>失效队列也是属于每个 CPU 的，使用失效队列后，发生 RW 对应的 CPU\n缓存不再同步地将自身缓存失效并发送确认回执，而是将失效消息放入失效队列，立即发送确认回执</p>\n<p>后续 CPU 会在空闲是对失效队列中的消息进行处理，将对应的 CPU\n缓存失效</p>\n<p>Ref：<a href=\"https://blog.csdn.net/weixin_52163830/article/details/126652300\">缓存一致性协议硬核讲解</a></p>\n<h4 id=\"指令重排\">指令重排</h4>\n<p>引入 Load Buffer\n后，即使读写指令本身是按照顺序执行的，但最终可能乱序执行，我们称这个问题为<strong>指令重排</strong></p>\n<h5 id=\"指令重排的原因\">指令重排的原因</h5>\n<p>由于 CPU0 发现 LW 时，在通知其他 CPU\n失效并等待回执的过程中是阻塞状态，影响了性能</p>\n<figure>\n<img src=\"/images/jvm/cpu_mesi_invalidate_ack.drawio.png\" alt=\"cpu_mesi_invalidate_ack.drawio\">\n<figcaption aria-hidden=\"true\">cpu_mesi_invalidate_ack.drawio</figcaption>\n</figure>\n<p>故使用 store buffer 来优化：CPU0 在 LW 时，将内容写入 store\nbuffer，同时通知其他 CPU 失效，然后就可以处理其他指令；当收到了所有其他\nCPU 的 ack 后，再将 store buffer 中的数据写入 cache line 中。当 cache\nline 对应的内存发生 RR 时再将数据从 cache line 写入主存</p>\n<figure>\n<img src=\"/images/jvm/store_buffer.drawio.png\" alt=\"store_buffer.drawio\">\n<figcaption aria-hidden=\"true\">store_buffer.drawio</figcaption>\n</figure>\n<p>在上图的流程中，假设指令 A 是写操作（LW），指令 B 是读操作（LR）；CPU\n先执行 A，写的内容会先放到 store buffer，而不在内存中；执行完 A 接着执行\nB，这样给外界的感觉就是，先执行了 B，后执行了 A</p>\n<p>Ref：<a href=\"https://www.shuzhiduo.com/A/kvJ3QQ0gdg/\">指令重排的原理</a></p>\n<h5 id=\"指令重排的验证\">指令重排的验证</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InstructionReOrderTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            a = <span class=\"number\">0</span>;</span><br><span class=\"line\">            b = <span class=\"number\">0</span>;</span><br><span class=\"line\">            x = <span class=\"number\">0</span>;</span><br><span class=\"line\">            y = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">//创建2个CyclicBarrier对象,执行完后执行当前类的run方法</span></span><br><span class=\"line\">            <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">cb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        cb.await();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    a = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    y = b;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        cb.await();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    b = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    x = a;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span> &amp;&amp; y == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;第&quot;</span> + i + <span class=\"string\">&quot;次发生了指令重排，执行结果x=&quot;</span> + x + <span class=\"string\">&quot;;y=&quot;</span> + y;</span><br><span class=\"line\">                System.out.println(result);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"/images/jvm/image-20230201134939715.png\" alt=\"image-20230201134939715\">\n<figcaption aria-hidden=\"true\">image-20230201134939715</figcaption>\n</figure>\n<p>如上面的例子，如果严格按照顺序执行，无论哪个线程先被执行，x 和 y\n的值必有一个为 1，结果显示却出现了 x 和 y 都为 0\n的结果，只可能是两个线程内都发生了指令重排导致的</p>\n<p>Ref：<a href=\"https://www.suibibk.com/topic/834114165822980096\">并发(三)、Java实现一段简单的会导致指令重排的例子</a></p>\n<p>Ref：<a href=\"https://blog.csdn.net/fu123123fu/article/details/103731228\">CyclicBarrier用法</a></p>\n<h5 id=\"指令重排带来哪些问题\">指令重排带来哪些问题</h5>\n<ol type=\"1\">\n<li>并发情况下影响原有的业务逻辑</li>\n<li>导致单例模式失效</li>\n</ol>\n<blockquote>\n<p>对于 MESI 优化带来的问题，下面讨论在硬件层面的解决办法</p>\n</blockquote>\n<h4 id=\"cpu-内存屏障\">CPU 内存屏障</h4>\n<blockquote>\n<p>为什么要使用 CPU 内存屏障？</p>\n<p>MESI\n原本是<strong>强一致性的</strong>，但经过优化后，弱化成<strong>最终一致性</strong>，在某些中间状态下，多个\nCPU\n之间的数据并不一致，还可能出现乱序执行的情况；内存屏障就是用于禁止指令重排</p>\n</blockquote>\n<p>每种 CPU 的屏障指令是不一样，例如 Intel 的 CPU 设计中有 3\n条指令：</p>\n<ul>\n<li>sfence：save\nfence，写屏障指令。在sfence指令前的写操作必须在sfence指令后的写操作前完成</li>\n<li>lfence：load\nfence，读屏障指令。在lfence指令前的读操作必须在lfence指令后的读操作前完成</li>\n<li>mfence：在mfence指令前得读写操作必须在mfence指令后的读写操作前完成</li>\n</ul>\n<p>Ref：<a href=\"https://www.jianshu.com/p/819f26a321ce\">内存屏障</a></p>\n<blockquote>\n<p>小节：上面介绍了 cpu\n可见性问题的产生原因，可见性问题在硬件层面的解决方案，CPU 缓存一致性协议\nMESI，以及 MESI 在使用写缓冲区优化性能而引发的指令重排问题</p>\n</blockquote>\n<blockquote>\n<p>上文主要讨论了可见性问题，在硬件层面使用了缓存行 +\n缓存一致性协议来解决，不过这带来了一个性能问题：伪共享问题</p>\n</blockquote>\n<h2 id=\"伪共享问题\">伪共享问题</h2>\n<p>上面提到了缓存行和缓存一致性协议，看下面的场景：</p>\n<p>主存中有 <code>a</code> <code>b</code> 两个变量，CPU A 中的线程在对\n<code>a</code> 修改，CPU B 的线程对 <code>b</code> 读取，当前者修改\n<code>a</code> 后，会把 <code>a</code> 所在的缓存行写回主存，令 CPU B\n中对应的缓存行失效。这时 CPU B 读取 <code>b</code>\n时在缓存中找不到，需要从主存重新加载；</p>\n<p>（双写的场景会咋样呢？）</p>\n<figure>\n<img src=\"/images/jvm/缓存行.drawio.png\" alt=\"缓存行.drawio\">\n<figcaption aria-hidden=\"true\">缓存行.drawio</figcaption>\n</figure>\n<p>这样就出现了一个问题，<code>b</code> 与 <code>a</code>\n不相关，每次却要因为 <code>a</code> 的更新而到主存中重新读取</p>\n<p>当多线程修改相互独立的数据时，如果这些数据共享同一个缓存行，会无意中影响彼此的性能，这就是<strong>伪共享</strong></p>\n<h3 id=\"伪共享的例子\">伪共享的例子</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"type\">long</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"type\">long</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FalseSharingExample</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Counter</span> <span class=\"variable\">counter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Counter</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">iterations</span> <span class=\"operator\">=</span> <span class=\"number\">1_000_000_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">long</span> i=<span class=\"number\">0</span>; i&lt;iterations; i++) &#123;</span><br><span class=\"line\">                counter.x++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">endTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;total time: &quot;</span> + (endTime - startTime));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">long</span> i=<span class=\"number\">0</span>; i&lt;iterations; i++) &#123;</span><br><span class=\"line\">                counter.y++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">endTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;total time: &quot;</span> + (endTime - startTime));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 运行结果</span></span><br><span class=\"line\"><span class=\"comment\">// total time: 29909</span></span><br><span class=\"line\"><span class=\"comment\">// total time: 29922</span></span><br></pre></td></tr></table></figure>\n<p>将数据结构改为如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"type\">long</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"type\">long</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 运行结果</span></span><br><span class=\"line\"><span class=\"comment\">// total time: 7271</span></span><br><span class=\"line\"><span class=\"comment\">// total time: 7276</span></span><br></pre></td></tr></table></figure>\n<p>加入了 7 个long类型数值，使得 <code>x</code> 与 <code>y</code>\n中间产生了 56 字节（一个 long 类型占 8 字节），这样保证 <code>x</code>\n与 <code>y</code> 不会在一个缓存行中，而从避免了伪共享的问题</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<p><a href=\"https://www.jianshu.com/p/d34666a0d3d9\">理解jvm之多线程数据一致性问题</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/2048302\">CPU多级缓存</a></p>\n<p><a href=\"https://blog.csdn.net/denglin12315/article/details/122639341\">缓存一致性协议(MESI)——缓存加锁\n协议</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/467782159\">全知乎最详细的并发研究之CPU缓存一致性协议(MESI)有这一篇就够了！</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_52163830/article/details/126652300\">缓存一致性协议硬核讲解</a></p>\n<p><a href=\"https://www.shuzhiduo.com/A/kvJ3QQ0gdg/\">cpu指令重排序的原理</a></p>\n","tags":["计算机组成"]},{"title":"docker 镜像构建篇","url":"/2023/01/26/docker/docker-image-build/","content":"<blockquote>\n<p>本文介绍 Docker 镜像构建中的注意事项</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"docker-的使用场景\">Docker 的使用场景</h2>\n<p><strong>构建运行环境</strong></p>\n<p>一个程序的运行环境往往很复杂，如深度学习程序的运行环境，可能需要指定版本的操作系统，CUDA，cuDNN，gcc，python，各种依赖等等，自己从头搭建一个运行环境是很麻烦的，这时有人将运行环境构建成\nbase 镜像，然后基于 base 镜像运行程序，省去了自己搭建环境的过程</p>\n<p>比如想使用 paddle\n的训练、源码编译，直接运行对应的环境镜像，将代码挂载进去，就可以直接训练和编译了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run --name paddle -itd -v $PWD:/paddle registry.baidubce.com/paddlepaddle/paddle:2.4.1 /bin/bash</span><br></pre></td></tr></table></figure>\n<p>不过要注意，base镜像使用的 kernal\n指令还是宿主机提供的，所以如果要求的操作系统是 Linux，而宿主机是\nMac，即使在 Mac 上运行了 centos 或 ubantu 的 base\n镜像，也是无法运行的</p>\n<p><strong>临时的文件下载服务</strong></p>\n<p>在公司远程服务器上需要下载文件时，出于安全考虑，不能通过 xftp\n等软件连接，这时想从服务器上下载一个文件，就比较麻烦了，这时可以用\ndocker 创建一个 httpserver 容器，临时开通一个 http 服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -itd --name my-apache-app -p 8080:80 -v <span class=\"string\">&quot;<span class=\"variable\">$PWD</span>&quot;</span>:/usr/local/apache2/htdocs/ httpd:2.4</span><br></pre></td></tr></table></figure>\n<p>下载完文件记得关闭这个容器，防止产生安全问题</p>\n<p><strong>服务部署</strong></p>\n<p>k8s 管理 docker 容器完成服务部署、调度、扩缩容等</p>\n<h2 id=\"镜像\">镜像</h2>\n<h3 id=\"镜像的分层结构\">镜像的分层结构</h3>\n<figure>\n<img src=\"/images/docker/docker_layers.drawio.png\" alt=\"docker_layers.drawio\">\n<figcaption aria-hidden=\"true\">docker_layers.drawio</figcaption>\n</figure>\n<p>镜像分层最大的一个好处就是<strong>共享资源</strong></p>\n<p>比如：有多个镜像都从相同的 base\n镜像构建而来，那么宿主机只需在磁盘上保存一份 base\n镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了</p>\n<blockquote>\n<p>Q：如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如\n/etc 下的文件，这时其他容器的 /etc 是否也会被修改？</p>\n<p>A：不会的，修改会被限制在单个容器内，这就是容器的<strong>写时复制</strong></p>\n</blockquote>\n<h4 id=\"镜像是如何被多个容器共享的\">镜像是如何被多个容器共享的</h4>\n<p>当容器启动时，一个新的可写层被加载到镜像顶部，称为容器层，容器层之下的叫做镜像层</p>\n<p><strong>只有容器层是可写的，容器层下面的所有镜像层都是只读的</strong>，所以对容器文件的改动都只会发生在容器层中</p>\n<blockquote>\n<p>镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如\n/etc，上层的 /etc 会覆盖下层的 /etc，也就是说用户只能访问到上层中的文件\n/etc。在容器层中，用户看到的是一个叠加之后的文件系统</p>\n</blockquote>\n<p><strong>容器层如何变更文件</strong></p>\n<table>\n<colgroup>\n<col style=\"width: 11%\">\n<col style=\"width: 88%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>操作</th>\n<th>实现</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>添加文件</td>\n<td>新文件被写到容器层</td>\n</tr>\n<tr class=\"even\">\n<td>读取文件</td>\n<td>从上往下依次在各镜像层中查找此文件，找到后，打开并读入内存</td>\n</tr>\n<tr class=\"odd\">\n<td>修改文件</td>\n<td>从上往下依次在各镜像层中查找此文件，找到后，将其复制到容器层，然后修改</td>\n</tr>\n<tr class=\"even\">\n<td>删除文件</td>\n<td>从上往下依次在各镜像层中查找此文件，找到后，会在容器层中记录此删除操作</td>\n</tr>\n</tbody>\n</table>\n<p><strong>写时复制 Copy On Write</strong></p>\n<p>只有当需要修改时才复制一份数据，这种特性被称作 Copy on\nWrite。容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改</p>\n<h2 id=\"dockerfile\">Dockerfile</h2>\n<p>部署服务时，需要使用我们自己服务的镜像，就要用到 Dockerfile</p>\n<h3 id=\"dockerfile-常用指令\">Dockerfile 常用指令</h3>\n<table>\n<colgroup>\n<col style=\"width: 14%\">\n<col style=\"width: 85%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>指令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>FROM</td>\n<td>指定 base 镜像</td>\n</tr>\n<tr class=\"even\">\n<td>MAINTAINER</td>\n<td>设置镜像的作者</td>\n</tr>\n<tr class=\"odd\">\n<td>WORKDIR</td>\n<td>为后面的 RUN, CMD, ENTRYPOINT, ADD 或 COPY\n指令设置镜像中的当前工作目录。</td>\n</tr>\n<tr class=\"even\">\n<td>COPY</td>\n<td>将文件从 build context 复制到镜像内</td>\n</tr>\n<tr class=\"odd\">\n<td>ADD</td>\n<td>与 COPY 类似，不同的是，如果 src 是归档文件（tar, zip, tgz, xz\n等），文件会被自动解压</td>\n</tr>\n<tr class=\"even\">\n<td>ENV</td>\n<td>设置环境变量</td>\n</tr>\n<tr class=\"odd\">\n<td>EXPOSE</td>\n<td>指定容器中的进程会监听某个端口</td>\n</tr>\n<tr class=\"even\">\n<td>VOLUME</td>\n<td>将文件或目录声明为 volume</td>\n</tr>\n<tr class=\"odd\">\n<td>RUN</td>\n<td>在容器中运行指定的命令</td>\n</tr>\n<tr class=\"even\">\n<td>CMD</td>\n<td>容器启动时运行指定的命令<br>Dockerfile 中可以有多个 CMD\n指令，但只有最后一个生效<br>CMD 可以被 docker run 之后的参数替换</td>\n</tr>\n<tr class=\"odd\">\n<td>ENTRYPOINT</td>\n<td>设置容器启动时运行的命令。<br>Dockerfile 中可以有多个 ENTRYPOINT\n指令，但只有最后一个生效。CMD 或 docker run 之后的参数会被当做参数传递给\nENTRYPOINT</td>\n</tr>\n</tbody>\n</table>\n<p>在执行 <code>docker build -t &#123;app&#125;:&#123;version&#125; .</code> 命令末尾的\n<code>.</code> 指明 build context 为当前目录。Docker 默认会从 build\ncontext 寻找 Dockerfile 文件，也可以通过 <code>-f</code> 指定 Dockerfile\n的位置</p>\n<p>如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y vim</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"dockerfile-构建过程\">Dockerfile 构建过程</h3>\n<blockquote>\n<p>以上面dockerfile内容为例</p>\n</blockquote>\n<ol type=\"1\">\n<li>Docker 将 build context 中的所有文件发送给 Docker daemon</li>\n<li>执行 FROM，下载 base 镜像</li>\n<li>执行 RUN，创建临时容器 A，在临时容器中执行\n<code>apt-get update</code></li>\n<li>执行成功后，将容器 A 保存为临时镜像 B</li>\n<li>通过临时镜像 B，创建临时容器\nC，在临时容器中执行<code>apt-get install -y vim</code></li>\n<li>执行成功后，将容器 C 保存为临时镜像 D</li>\n<li>删除临时容器</li>\n<li>镜像构建成功，最终镜像为镜像D</li>\n</ol>\n<h3 id=\"dockerfile-的最佳实践\">Dockerfile 的最佳实践</h3>\n<h4 id=\"base-镜像的选择\">base 镜像的选择</h4>\n<ol type=\"1\">\n<li>使用固定版本的 base 镜像，不使用 latest 版本</li>\n<li>使用轻量级 alpine 的发行版</li>\n</ol>\n<h4 id=\"尽量利用镜像层缓冲\">尽量利用镜像层缓冲</h4>\n<blockquote>\n<p>在执行 build\n时，每个镜像层都会被缓存下来，当需要构建时，若某一层指令或内容没有发生变更，会直接利用缓存层，提高构建速度</p>\n<p>若某一层的命令或内容发生了变更，意味着后面的所有的镜像层缓存都不可被复用</p>\n</blockquote>\n<blockquote>\n<p>Q：为什么某一层发生变更，后面的镜像层就不能被复用了呢？</p>\n<p>A：先说下 git commit，这个命令用于创建镜像，在用 dockerfile\n构建镜像时，底层是用 git commit\n不断的创建镜像，包括若干临时镜像和一个最终镜像；比如在构建过程中，临时镜像A包括镜像层1-4，那么在执行下一个构建语句时，需要通过镜像A运行容器C，在容器C中执行相应的命令，再将容器C保存为镜像B，这样镜像B就包含了镜像层1-5。所以，如果某一层发生变更，该层对应的临时镜像以及后面的临时镜像都变了，无法复用</p>\n<p>所以这个问题是带有欺骗性的，看起来是镜像层的复用，实际上是临时镜像的复用，在构建过程中，只有临时镜像被保存，没有镜像层被保存</p>\n</blockquote>\n<ol start=\"3\" type=\"1\">\n<li>将 dockerfile\n涉及到的文件或内容，从最少变更步骤到最频繁变更进行排序，不频繁的放在上面，来提高缓存层复用率，提高镜像的构建速度</li>\n</ol>\n<blockquote>\n<p>例如，有些 dockerfile\n需要将项目文件拷贝到镜像中，这些文件是频繁变更的，要尽量往后放</p>\n</blockquote>\n<h4 id=\"镜像层尽量少\">镜像层尽量少</h4>\n<blockquote>\n<p>dockerfile中的每条指定都会创建一个镜像层（待验证），有些相同类型的操作，如果分开写，会导致生成的镜像文件存在多个镜像层中</p>\n</blockquote>\n<ol start=\"4\" type=\"1\">\n<li>将同类型的操作用 <code>&amp;&amp;</code> 和 <code>\\</code>\n来结合，减少镜像层，便于维护</li>\n</ol>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENV</span> GO111MODULE=on \\</span><br><span class=\"line\">    GOPROXY=<span class=\"string\">&quot;https://goproxy.io&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> yum makecache &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    yum -y install nginx mysql</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-.dockerignore-文件\">使用 .dockerignore 文件</h4>\n<blockquote>\n<p>在构建镜像时，Docker Client 会将 build context 中的所有文件发送给\nDocker daemon，如果 build context\n下的文件体积很大，会导致编译时间很长甚至失败，还可能导致镜像体积过大</p>\n<p>本人遇到的一个项目，由于上线流水线不健全，需要本地打镜像，当时本地日志打在项目目录下，且缺少\n.dockerignore 文件，每次构建镜像时，都会将日志文件发送给 Docker\ndaemon，还会 COPY 到镜像内，不仅编译时间长，且镜像体积大</p>\n<p>如果通过流水线从代码库拉代码，正常情况下是不会有本地产物的，不过也可以通过\n.dockeringore 文件去掉一些镜像不需要的文件，加快构建速度</p>\n</blockquote>\n<ol start=\"5\" type=\"1\">\n<li>在根目录下，可使用 .dockerfileignore\n文件，排除掉无需加入的目录或文件，其编写的方式和 .gitignore\n相同，加快构建速度</li>\n</ol>\n<h4 id=\"安全性\">安全性</h4>\n<ol start=\"6\" type=\"1\">\n<li>容器中使用非 root 用户启动应用</li>\n</ol>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">17.0</span>.<span class=\"number\">1</span>-alpine</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">USER</span> work</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h4 id=\"其他方面\">其他方面</h4>\n<ol start=\"7\" type=\"1\">\n<li>使用 <code>RUN</code> 指令安装依赖和软件包</li>\n<li>不要使用 <code>RUN apt-get upgrade</code></li>\n<li>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code>\n不要分成两个 RUN</li>\n<li>清理掉 apt 缓存 <code>rm -rf /var/lib/apt/lists/*</code>\n减少镜像体积</li>\n<li>用于安装依赖的文件单独 COPY，如 requirements.txt</li>\n</ol>\n<p>下面是一个完整的栗子</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:alpine3.<span class=\"number\">17</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; apt-get install -y \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    aufs-tools \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    automake \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    build-essential \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    curl \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    dpkg-sig \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    libcap-dev \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    libsqlite3-dev \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    mercurial \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    reprepro \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    ruby1.9.1 \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    ruby1.9.1-dev \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    s3cmd=1.1.* \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    &amp;&amp; <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class=\"line\"><span class=\"keyword\">USER</span> work</span><br><span class=\"line\">WOKRDIR /home/work</span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install --requirement requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> app .</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8000</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;manage.py&quot;</span>, <span class=\"string\">&quot;runserver&quot;</span>, <span class=\"string\">&quot;0.0.0.0:8000&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://blog.csdn.net/weixin_44966641/article/details/124212367\">Dockerfile最佳实践</a></p>\n<p><a href=\"https://blog.51cto.com/windchasereric/4796157\">dockerfile\n最佳实践</a></p>\n","tags":["docker"]},{"title":"面试分享-1","url":"/2022/10/22/interview/interview-question-1/","content":"<blockquote>\n<p>面试题分享~ No.1</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>题目：</p>\n<ol type=\"1\">\n<li>【Java】线程池如何使用，参数有哪些【必问】</li>\n<li>【Java】强引用、弱引用的区别和应用</li>\n<li>【MySQL】如何优化慢SQL【必问】</li>\n<li>【MySQL】索引失效的场景</li>\n<li>【MySQL】Innodb 索引的数据结构是什么，为什么</li>\n<li>【Redis】key的TTL如何实现</li>\n<li>【Redis】缓存穿透的解决方案</li>\n<li>【算法题】如何动态找中位数</li>\n</ol>\n</blockquote>\n<h3 id=\"线程池如何使用参数有哪些\">线程池如何使用，参数有哪些</h3>\n<p>结合项目，哪个业务用了线程池</p>\n<p>参数说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"type\">int</span> corePoolSize,\t// 核心线程数</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">int</span> maximumPoolSize,\t// 最大线程数</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">long</span> keepAliveTime,\t// 空闲的多余线程最大存活时间</span></span><br><span class=\"line\"><span class=\"params\">                          TimeUnit unit,\t// 存活时间单位</span></span><br><span class=\"line\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,\t// 工作队列</span></span><br><span class=\"line\"><span class=\"params\">                          ThreadFactory threadFactory,\t// 线程工厂</span></span><br><span class=\"line\"><span class=\"params\">                          RejectedExecutionHandler handler)</span>\t<span class=\"comment\">// 拒绝策略</span></span><br></pre></td></tr></table></figure>\n<p>corePoolSize：线程池长期维持的线程数，不会回收</p>\n<p>maximumPoolSize: 线程数上限</p>\n<p>keepAliveTime：非核心线程的存活时间，超过该时间被回收</p>\n<p>unit：收回时间的单位</p>\n<p>workQueue：任务的工作队列（队列的最大长度默认值看源码：Integer.MAX_VALUE=2^23-1）</p>\n<p>threadFactory：生产新线程的工厂</p>\n<p>handler：拒绝策略</p>\n<h4 id=\"为什么要用线程池\">为什么要用线程池</h4>\n<ol type=\"1\">\n<li>降低资源消耗：使用单独的线程需要频繁创建和销毁线程，线程池可以复用已创建的线程</li>\n<li>提高相应速度：当任务到达时，不需要等线程创建，就可以执行</li>\n<li>提高资源的管理：控制创建线程的数量</li>\n</ol>\n<h4 id=\"线程池中任务的执行流程\">线程池中任务的执行流程</h4>\n<blockquote>\n<p>见 ThreadPoolExecutor.java 中 execute 函数</p>\n</blockquote>\n<ol type=\"1\">\n<li>当线程池中线程数小于corePoolSize，直接执行</li>\n<li>当线程数大于等于 corePoolSize，则将任务放入\nworkQueue，随着线程池中核心线程们不断执行任务，只要有空闲的线程，就从workQueue中取任务并执行</li>\n<li>当 workQueue\n已满，放不下新的任务，则新建非核心线程入池并处理，直到线程数达到\nmaximumPoolSize</li>\n<li>如果线程池中线程数大于 maximumPoolSize 则使用拒绝策略拒绝处理</li>\n</ol>\n<figure>\n<img src=\"/images/java/线程池执行流程.png\" alt=\"线程池执行流程\">\n<figcaption aria-hidden=\"true\">线程池执行流程</figcaption>\n</figure>\n<h4 id=\"拒绝策略\">拒绝策略</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>策略</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>ThreadPoolExecutor.AbortPolicy</td>\n<td>抛出异常</td>\n</tr>\n<tr class=\"even\">\n<td>ThreadPoolExecutor.CallerRunsPolicy</td>\n<td>重试</td>\n</tr>\n<tr class=\"odd\">\n<td>ThreadPoolExecutor.DiscardPolicy</td>\n<td>丢弃当前任务</td>\n</tr>\n<tr class=\"even\">\n<td>ThreadPoolExecutor.DiscardOldestPolicy</td>\n<td>丢弃工作队列头部任务</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"线程池的种类\">线程池的种类</h4>\n<p><em>Executors线程池工具类为我们提供了一些API用于返回不同类型的线程池</em></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>CachedThreadPool</td>\n<td>线程数无上限，可以接收无上限的任务</td>\n</tr>\n<tr class=\"even\">\n<td>FixedThreadPool</td>\n<td>线程数固定，可以接收无上限的任务</td>\n</tr>\n<tr class=\"odd\">\n<td>ScheduledThreadPool</td>\n<td>定期执行任务</td>\n</tr>\n<tr class=\"even\">\n<td>SingleThreadExcutor</td>\n<td>只有一个线程</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"例子\">例子</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zjm.thread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Task</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 工作队列</span></span><br><span class=\"line\">        BlockingQueue&lt;Runnable&gt; workQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 拒绝策略</span></span><br><span class=\"line\">        <span class=\"type\">RejectedExecutionHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.AbortPolicy();</span><br><span class=\"line\">        <span class=\"type\">ThreadPoolExecutor</span> <span class=\"variable\">threadPoolExecutor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">100</span>,</span><br><span class=\"line\">                TimeUnit.SECONDS, workQueue, handler);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Task</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Task</span>();</span><br><span class=\"line\">            threadPoolExecutor.execute(task);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threadPoolExecutor.shutdown();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!threadPoolExecutor.isTerminated());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;all task run finished !&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Ref：https://www.cnblogs.com/kxxiaomutou/p/15968431.html</p>\n<h3 id=\"强引用弱引用的区别和应用\">强引用、弱引用的区别和应用</h3>\n<table>\n<colgroup>\n<col style=\"width: 6%\">\n<col style=\"width: 46%\">\n<col style=\"width: 46%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>引用类型</th>\n<th>创建方式</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>强引用</td>\n<td>Object o = new Object();</td>\n<td>如果有根对象指向它，触发GC时，不会回收这类对象；如果没有根对象指向它，会被GC收回</td>\n</tr>\n<tr class=\"even\">\n<td>弱引用</td>\n<td>SoftReference<String> stringSoftReference = new\nSoftReference&lt;&gt;(\"Hello\");</String></td>\n<td>当内存空间不足的时候，如果就会回收这些对象</td>\n</tr>\n<tr class=\"odd\">\n<td>软引用</td>\n<td>WeakReference<String> weakReference = new\nWeakReference&lt;&gt;(\"Hello\");</String></td>\n<td>不管当前内存空间是否足够，都会回收</td>\n</tr>\n</tbody>\n</table>\n<p>引发问题：</p>\n<ol type=\"1\">\n<li>怎么判断一个强引用对象是否可以被回收</li>\n<li>哪些对象是根对象</li>\n<li>弱引用的应用</li>\n</ol>\n<h3 id=\"如何优化慢sql\">如何优化慢SQL</h3>\n<ol type=\"1\">\n<li><p>开启慢SQL统计：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"keyword\">on</span>;\t<span class=\"operator\">/</span><span class=\"operator\">/</span> 开启慢<span class=\"keyword\">SQL</span>统计</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">1</span>;\t<span class=\"operator\">/</span><span class=\"operator\">/</span> 设置超过<span class=\"number\">1</span>s的请求为慢<span class=\"keyword\">SQL</span></span><br></pre></td></tr></table></figure></li>\n<li><p>查看执行计划，判断是否走到索引</p>\n<p>如何查看执行计划：<code>explain select ... from ... where ...</code></p>\n<p>关注执行计划中的<strong>type</strong>字段：</p>\n<table>\n<colgroup>\n<col style=\"width: 11%\">\n<col style=\"width: 88%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>type类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>ALL</td>\n<td>全表扫描</td>\n</tr>\n<tr class=\"even\">\n<td>INDEX</td>\n<td>全索引扫描</td>\n</tr>\n<tr class=\"odd\">\n<td>range</td>\n<td>索引范围查询</td>\n</tr>\n<tr class=\"even\">\n<td>ref</td>\n<td>使用普通索引或唯一索引的部分前缀，可能找到多个符合条件的记录</td>\n</tr>\n<tr class=\"odd\">\n<td>eq_ref</td>\n<td>primary key或unique key索引</td>\n</tr>\n<tr class=\"even\">\n<td>const</td>\n<td>最多只有一行记录匹配。当联合主键或唯一索引的所有字段跟常量值比较时，join类型为const</td>\n</tr>\n<tr class=\"odd\">\n<td>system</td>\n<td>表中只有一行数据或者是空表，这是const类型的一个特例，且只能用于myisam和memory</td>\n</tr>\n</tbody>\n</table></li>\n<li><p>根据查询计划，查看实际使用的索引</p>\n<p>查看<strong>key</strong>字段</p></li>\n<li><p>如果没有走到索引，分析原因</p>\n<ol type=\"1\">\n<li>没有建立索引：创建对应的索引（考虑回表、索引下推的优化）</li>\n<li>建了索引，而索引失效：分析索引失效的原因</li>\n</ol></li>\n</ol>\n<h4 id=\"索引失效的场景\">索引失效的场景</h4>\n<p>在查询条件中：</p>\n<ol type=\"1\">\n<li>联合索引中忽略了最左匹配原则</li>\n<li>前缀模糊查询：like '%baidu'</li>\n<li>使用了不等号</li>\n<li>使用了表达式、函数操作，如MONTH(create_time)</li>\n<li>索引是否有区分度</li>\n<li>大量子查询</li>\n</ol>\n<h4 id=\"常见的优化策略\">常见的优化策略</h4>\n<ol type=\"1\">\n<li>不返回不必要的字段，增加索引覆盖的概率（不刻意的建立联合索引可能蒙中索引覆盖吗...）</li>\n<li>减少子查询（子查询会创建临时表，查询完毕删除临时表）</li>\n<li>调整where子句的连接顺序，将过滤数据多的条件放在前面，最快速度缩小结果集（MySQL不会自己优化吗）</li>\n<li>一次查询的结果最好不要过大，分页查询</li>\n<li>在推理索引错误的情况下，可以强制命中一个索引</li>\n</ol>\n<p>Ref：https://blog.csdn.net/y1250056491/article/details/125465583</p>\n<h3 id=\"innodb-索引的数据结构是什么为什么\">Innodb\n索引的数据结构是什么，为什么</h3>\n<ol type=\"1\">\n<li><p>前置知识：Innodb每次IO读取的数据是16kb</p></li>\n<li><p>对索引可以用到的数据结构进行对比：</p>\n<p>哈希表、二叉平衡树、AVL树、红黑树、B树、B+树</p>\n<p>对比：</p>\n<table>\n<colgroup>\n<col style=\"width: 17%\">\n<col style=\"width: 41%\">\n<col style=\"width: 41%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>数据结构</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>哈希表</td>\n<td>等值查询O(1)复杂度；</td>\n<td>范围查询需要全量遍历</td>\n</tr>\n<tr class=\"even\">\n<td>二叉平衡树、AVL树、红黑树</td>\n<td>查询时间复杂度为O(logn)，比B树和B+树的时间复杂度低</td>\n<td>因为高，与磁盘的IO次数多</td>\n</tr>\n<tr class=\"odd\">\n<td>B树</td>\n<td>与磁盘的IO次数比平衡树低</td>\n<td>数据在所有节点上，导致每个数据页能存放的向下指针（就是degree）是较少的（一个数据页大小固定为16kb），导致树高度增大，IO次数增多</td>\n</tr>\n<tr class=\"even\">\n<td>B+树</td>\n<td>数据仅在叶子节点上，每个数据页可以存放更多的指针，使得树高度降低，IO次数降低；由于数据都在叶子节点，范围查询更快</td>\n<td>时间复杂度比平衡树和B树要低</td>\n</tr>\n</tbody>\n</table></li>\n</ol>\n<p>B树</p>\n<figure>\n<img src=\"/images/java/image-20221022212557034.png\" alt=\"image-20221022212557034\">\n<figcaption aria-hidden=\"true\">image-20221022212557034</figcaption>\n</figure>\n<p>B+树</p>\n<figure>\n<img src=\"/images/java/image-20221022212146552.png\" alt=\"image-20221022212146552\">\n<figcaption aria-hidden=\"true\">image-20221022212146552</figcaption>\n</figure>\n<p>Ref：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</p>\n<h3 id=\"key的ttl如何实现\">key的TTL如何实现</h3>\n<ol type=\"1\">\n<li><p>主动失效</p>\n<p>定时任务周期性执行：</p>\n<ol type=\"i\">\n<li><p>从有失效机制的Key中随机取出20个key</p></li>\n<li><p>删除已过期的key</p></li>\n<li><p>判断是否超过1/4的key已经失效，如果没有，执行第i步</p></li>\n</ol></li>\n<li><p>被动失效</p>\n<p>当客户端获取key时，判断key是否失效</p></li>\n</ol>\n<p>Ref：https://blog.csdn.net/m0_37939214/article/details/107794344</p>\n<h3 id=\"缓存穿透的解决方案\">缓存穿透的解决方案</h3>\n<ol type=\"1\">\n<li><p>简述什么是缓存穿透</p></li>\n<li><p>解决方案：</p>\n<ol type=\"1\">\n<li>缓存空值</li>\n<li>布隆过滤器</li>\n</ol></li>\n<li><p>【引发问题】如果在高并发场景中，一个数据库中不存在的key，布隆过滤器漏了过去（存在误判），缓存中还没有设置空值，由于redis是串行计算的，在设置空值之前会有大量请求打到数据库，对DB造成压力，如何解决</p>\n<p>发现缓存中没有，先争抢一把锁，谁抢到再访问DB，设置空值，没有抢到的返回用户【sorry，请重试】</p></li>\n</ol>\n<p>Ref：https://blog.csdn.net/a898712940/article/details/116212825</p>\n<h3 id=\"数据流中的中位数\">数据流中的中位数</h3>\n<p>对顶堆</p>\n<blockquote>\n<p>思路：</p>\n<p>个数为奇数时，应该往大顶堆插入，需要判断要插入的数据，是否大于小顶堆的堆顶元素，说明小堆顶的对顶元素应该出队，入队大顶堆中，而要插入的数据实际应该入队小顶堆；</p>\n<p>个数为偶数时，应该往小顶堆插入数据，需要判断，要插入的数据，是否小于大顶堆的堆顶元素，说明大堆顶的元素要出队，入队小顶堆中，而要插入的数据实际应该入队大顶堆；</p>\n</blockquote>\n<p>Ref：https://www.jianshu.com/p/f7e2ed52052d</p>\n","categories":["interview"],"tags":["interview"]},{"title":"面试分享-2","url":"/2022/10/29/interview/interview-question-2/","content":"<blockquote>\n<p>面试分享~No.2</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>题目：</p>\n<ol type=\"1\">\n<li>【Java】JVM 内存模型【热】</li>\n<li>【Java】JVM启动参数</li>\n<li>【Redis】数据持久化的方式</li>\n<li>【Redis】单线程速度快的原因【热】</li>\n<li>【MySQL】隔离级别</li>\n<li>【算法题】反转链表【热】</li>\n</ol>\n</blockquote>\n<h2 id=\"jvm内存模型\">JVM内存模型</h2>\n<figure>\n<img src=\"/images/java/738b4710b912c8fcd86d7ee514729b4cd78821f2.png\" alt=\"img\">\n<figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>线程私有：JVM栈，本地方法栈，程序计数器</p>\n<p>线程共有：堆，方法区</p>\n<h3 id=\"堆\">堆</h3>\n<p><img src=\"/images/interview/3933885090-5d4e2af6232ab.png\"></p>\n<h3 id=\"方法区\">方法区</h3>\n<p>存放已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</p>\n<h3 id=\"jvm栈\">JVM栈</h3>\n<h4 id=\"栈的构成\">栈的构成</h4>\n<p>栈中存放的是<strong>栈帧</strong>，一个方法就是一个栈帧</p>\n<p>栈帧中包含：局部变量表，操作数栈，动态链接，方法返回地址</p>\n<p>下面通过几个例子简述局部变量表和操作数栈</p>\n<p>例子1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    i = i ++;</span><br><span class=\"line\">    System.out.println(i);\t<span class=\"comment\">// 打印10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用jclasslib查看函数的字节码</p>\n<figure>\n<img src=\"/images/java/image-20221029015255730.png\" alt=\"image-20221029015255730\">\n<figcaption aria-hidden=\"true\">image-20221029015255730</figcaption>\n</figure>\n<p>字节码的执行过程</p>\n<figure>\n<img src=\"/images/java/image-20221029021930363.png\" alt=\"image-20221029022135161\">\n<figcaption aria-hidden=\"true\">image-20221029022135161</figcaption>\n</figure>\n<ol type=\"1\">\n<li>将10压入操作数栈</li>\n<li>将操作数栈弹出，写入局部变量表位置为1的变量</li>\n<li>将局部变量表位置为1的变量值压入栈</li>\n<li>将局部变量表位置为1的变量值加1</li>\n<li>将操作数栈弹出，写入局部变量表位置为1的变量</li>\n</ol>\n<p>例子2：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    i = ++i;</span><br><span class=\"line\">    System.out.println(i);\t<span class=\"comment\">// 11</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字节码：</p>\n<figure>\n<img src=\"/images/java/image-20221029022643983.png\" alt=\"image-20221029022643983\">\n<figcaption aria-hidden=\"true\">image-20221029022643983</figcaption>\n</figure>\n<p>字节码执行过程：</p>\n<ol type=\"1\">\n<li>将10入栈（操作数栈的简称）</li>\n<li>出栈，写入局部变量表下标1的变量</li>\n<li>局部变量表下标为1的变量加1</li>\n<li>局部变量表下标为1的变量入栈</li>\n<li>出栈，写入局部变量表下标1的变量</li>\n</ol>\n<figure>\n<img src=\"/images/java/image-20221029023333672.png\" alt=\"image-20221029023333672\">\n<figcaption aria-hidden=\"true\">image-20221029023333672</figcaption>\n</figure>\n<p>例子3：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> a + b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c * m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"/images/java/image-20221029032740793.png\" alt=\"image-20221029033520031\">\n<figcaption aria-hidden=\"true\">image-20221029033520031</figcaption>\n</figure>\n<p>字节码执行流程：</p>\n<figure>\n<img src=\"/images/java/image-20221029035724340.png\" alt=\"image-20221029035724340\">\n<figcaption aria-hidden=\"true\">image-20221029035724340</figcaption>\n</figure>\n<p>动态链接：指向常量池中的一个对象</p>\n<p>方法返回值：栈帧弹出后，下一个栈帧执行的位置</p>\n<h3 id=\"本地方法栈\">本地方法栈</h3>\n<p>存放虚拟机使用到的 Native 方法</p>\n<h3 id=\"程序计数器\">程序计数器</h3>\n<p>记录程序当前执行的字节码的位置</p>\n<p>https://blog.csdn.net/m0_71777195/article/details/126247090</p>\n<h2 id=\"jvm常用启动参数\">JVM常用启动参数</h2>\n<table>\n<thead>\n<tr class=\"header\">\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>-Xmx3000m</td>\n<td>设置JVM堆最大空间为3000M</td>\n</tr>\n<tr class=\"even\">\n<td>-Xms3000m</td>\n<td>设置JVM堆初始大小为3000M，建议与Xmx值相同</td>\n</tr>\n<tr class=\"odd\">\n<td>-Xss</td>\n<td>设置线程栈大小</td>\n</tr>\n<tr class=\"even\">\n<td>-XX:NewSize=1024m</td>\n<td>设置年轻代初始值为1024M</td>\n</tr>\n<tr class=\"odd\">\n<td>-XX:MaxNewSize=1024m</td>\n<td>设置年轻代最大值为1024M</td>\n</tr>\n<tr class=\"even\">\n<td>-XX:-PrintGC</td>\n<td>每次GC打印日志</td>\n</tr>\n</tbody>\n</table>\n<p>Ref: https://blog.csdn.net/LC181119/article/details/122972834</p>\n<h2 id=\"redis-数据持久化方式\">Redis 数据持久化方式</h2>\n<h3 id=\"rdb-redis-database\">RDB (Redis DataBase)</h3>\n<p>将某一时刻的数据（快照）持久化到磁盘</p>\n<ol type=\"1\">\n<li><p>RDB文件的创建：SAVE，BGSAVE</p>\n<p>其中，SAVE会阻塞服务进程，导致服务无法处理任何请求；BGSAVE不会阻塞服务进程，而是fork一个子进程，由子进程创建RDB文件</p></li>\n<li><p>RDB文件的载入</p>\n<p>服务器启动时自动执行</p></li>\n<li><p>RDB的执行周期</p>\n<p>默认配置：<code>save 900 1</code> 900秒内执行一次</p></li>\n</ol>\n<p>由于RDB是周期性的，如果服务突然挂了，最新的数据就会丢失</p>\n<h3 id=\"aof-append-only-file\">AOF (Append Only File)</h3>\n<p>将写命令写到日志中</p>\n<h4 id=\"aof的实现\">AOF的实现</h4>\n<ol type=\"1\">\n<li>命令追加：将命令追加到AOF缓冲区末尾</li>\n<li>文件写入：将AOF缓存区内容写入到日志文件缓存区</li>\n<li>文件同步：将日志文件缓存区写入磁盘</li>\n</ol>\n<h4 id=\"flushappendonlyfile\">flushAppendOnlyFile</h4>\n<p>每个事件执行之后，都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf内容写入和同步到AOF日志中，flushAppendOnlyFile函数的行为由服务配置的appendfsync选项值来决定：</p>\n<table>\n<colgroup>\n<col style=\"width: 21%\">\n<col style=\"width: 78%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>appendfsync值</th>\n<th>flushAppendOnlyFile行为</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>always</td>\n<td>将aof_buf所有内容写入并同步到AOF文件</td>\n</tr>\n<tr class=\"even\">\n<td>everysec（默认）</td>\n<td>将aof_buf所有内容写入AOF文件，如果上次同步AOF文件的时间距离超过1秒，对AOF文件进行同步</td>\n</tr>\n<tr class=\"odd\">\n<td>no</td>\n<td>将aof_buf所有内容写入AOF文件缓冲区，不对AOF文件磁盘进行同步，何时同步由操作系统来决定</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"aof-文件重写\">AOF 文件重写</h4>\n<p>解决AOF文件体积膨胀的问题，将一些冗余指令合并，缩小文件体积</p>\n<p>实现方式：</p>\n<p>读取、分析AOF文件的效率低，Redis采用的方式为：直接读当前数据，这样存在问题是，操作过程中进来的指令无法写入到新的AOF文件中，如何不阻塞主进程</p>\n<p>Redis\n将AOF重写的操作放到子进程中执行（为啥不能是线程中，而是fork一个进程）</p>\n<p>目的是：</p>\n<ol type=\"1\">\n<li>子进程进行 AOF 重写期间，服务器（父进程）可以继续处理命令请求</li>\n<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性（Why）</li>\n</ol>\n<h4 id=\"如何解决aof重写过程中遗漏的指令\">如何解决AOF重写过程中遗漏的指令</h4>\n<ol type=\"1\">\n<li>创建子进程后，将指令写入到AOF重写缓冲区</li>\n<li>子进程完成AOF重写后，向父进程发送一个信号，父进程收到信号后，不处理请求，执行：\n<ol type=\"1\">\n<li>将AOF重写缓冲区的内容写入新的AOF文件</li>\n<li>对新的AOF文件重命名，覆盖旧的AOF文件</li>\n</ol></li>\n<li>父进程继续处理请求</li>\n</ol>\n<p>上述过程中，第２步会阻塞请求的执行</p>\n<p>Ref:</p>\n<p>https://zhuanlan.zhihu.com/p/55236400</p>\n<p>https://blog.csdn.net/weixin_44743841/article/details/107915188</p>\n<h2 id=\"redis-单线程速度快的原因\">Redis 单线程速度快的原因</h2>\n<ol type=\"1\">\n<li>基于内存，底层采用了高效的数据结构，比如哈希表、跳表</li>\n<li>单线程避免了上下文切换</li>\n<li>避免共享资源加锁导致的性能损耗</li>\n<li>采用多路复用的IO模型（epoll）</li>\n<li>非CPU密集型任务，Redis的大部分操作瓶颈在内存和网络带宽</li>\n</ol>\n<p>Ref: https://blog.csdn.net/m0_67401134/article/details/123862847</p>\n<h2 id=\"mysql-事务隔离级别\">MySQL 事务隔离级别</h2>\n<table>\n<thead>\n<tr class=\"header\">\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>读未提交（Read uncommitted）</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>读提交（read committed）</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>可重复读（repeatable read）</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>串行化（Serializable）</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody>\n</table>\n<p>MySQL 语句的默认事务隔离级别：RR\n可重复读，通过<code>SELECT @@transaction_isolation;</code>查看</p>\n<p>修改隔离级别：<code>SET SESSION transaction_isolation = 'READ-UNCOMMITTED';</code></p>\n<p><em>引发问题：</em></p>\n<h3 id=\"如何实现rr隔离级别\">如何实现RR隔离级别</h3>\n<p>使用MVCC来实现可重复读，实现原理为：</p>\n<p>依赖于记录中的三个隐藏字段（row_id，trx_id, rollback_ptr），undo\nlog，read view</p>\n<p>trx_id：该记录最新修改的事务号</p>\n<p>rollback_ptr：上一个版本指针</p>\n<p>undo log：回滚日志</p>\n<p>read view：可见性</p>\n<figure>\n<img src=\"/images/mysql/mvcc.png\" alt=\"image-20220714030233959\">\n<figcaption aria-hidden=\"true\">image-20220714030233959</figcaption>\n</figure>\n<p>如上图，事务5来读取某一行数据，如那行数据的row_id=24，记录中trx_id\n&gt; 5，对事务5不可见，通过rollback_ptr在undo\nlog中找上个版本的记录，发现trx_id &gt; 5，再找上个版本的记录，发现trx_id\n&lt; 5，则该记录是事务5可见的最新版本，读数据</p>\n<h3 id=\"mvcc-下的两种读方式\">MVCC 下的两种读方式</h3>\n<p><strong>当前读</strong>：从数据表中，不同语句根据隔离级别，使用悲观锁处理冲突，如<code>select ... in share mode</code>，<code>select ... for update</code></p>\n<p><strong>快照读</strong>：使用MVCC，从表或undo\nlog中读数据，不需要使用悲观锁，如<code>select ...</code></p>\n<p>RR是通过快照读来实现可重复读</p>\n<h2 id=\"反转链表\">反转链表</h2>\n<p>要求：空间复杂度O(1)，时间复杂度O(n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reverseLinkedList</span><span class=\"params\">(Node head)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        next = cur.next;</span><br><span class=\"line\">        cur.next = pre;</span><br><span class=\"line\">        pre = cur;</span><br><span class=\"line\">        cur = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["interview"],"tags":["interview"]},{"title":"Java 注解原理","url":"/2023/04/02/java/annotation/","content":"<blockquote>\n<p>本文简述 Java 注解原理</p>\n<p>你可以收获：</p>\n<ol type=\"1\">\n<li>Java 文件的编译过程</li>\n<li>插入式注解的原理</li>\n<li>什么是抽象语法树</li>\n<li>如何自己实现一个 lombok</li>\n<li>运行时注解的原理</li>\n</ol>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"注解的分类\">注解的分类</h2>\n<p>根据注解的生命周期，可以分为三类：</p>\n<ul>\n<li>SOURCE：编译器可见，不会写入 class 文件</li>\n<li>CLASS：会写入 class 文件，在类加载阶段丢弃</li>\n<li>RUNTIME：会加载到 JVM</li>\n</ul>\n<p>根据注解的操作形式，可以分为两类：</p>\n<ul>\n<li>插入式注解：插入式注解（也叫编译时注解）内容只存在源文件，在编译期间被丢弃，不能通过JVM获取注解信息，Retention=SOURCE\n或 CLASS</li>\n<li>运行时注解：编译时被写入字节码文件中，可以通过 JVM\n运行时获取注解信息（Retention=RUNTIME）</li>\n</ul>\n<h2 id=\"注解的作用与好处\">注解的作用与好处</h2>\n<p>作用：</p>\n<ul>\n<li>生成文档：如 <span class=\"citation\" data-cites=\"authr\">@authr</span>\n<span class=\"citation\" data-cites=\"version\">@version</span></li>\n<li>标注说明：如 <span class=\"citation\" data-cites=\"Override\">@Override</span> <span class=\"citation\" data-cites=\"Deprecated\">@Deprecated</span></li>\n<li>实现能力：如 lombok、AspectJ 框架 以注解方式提供功能</li>\n</ul>\n<p>好处：</p>\n<ul>\n<li>减少手动实现冗余代码，使代码简洁，如 lombok、BufferKnife 等</li>\n<li>对业务代码低侵入，如 BTrace 追踪工具</li>\n</ul>\n<h2 id=\"编译过程\">编译过程</h2>\n<blockquote>\n<p>在介绍插入式注解，需要先了解 java 的编译过程</p>\n</blockquote>\n<p>编译：将便于人编写、阅读、维护的高级计算机语言写的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序的过程。负责这一过程的处理的工具叫做<strong>编译器</strong></p>\n<p>简单理解，<strong>编译</strong> = 高级语言源代码 → 分析 + 翻译 + 优化\n→ 低级语言机器码</p>\n<p>源码编译流程如图所示：</p>\n<figure>\n<img src=\"/images/java/image-20230326135858492.png\" alt=\"image-20230326135858492\">\n<figcaption aria-hidden=\"true\">image-20230326135858492</figcaption>\n</figure>\n<p>其中【中间代码】指的就是字节码（.class文件），字节码无法被机器识别，还需要\nJVM 再将字节码转为机器码</p>\n<p>编译阶段的编译器和对应任务如下：</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>编译器</th>\n<th>任务</th>\n<th>代表</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>前端编译器</td>\n<td>.java → .class</td>\n<td>javac</td>\n</tr>\n<tr class=\"even\">\n<td>后端编译器</td>\n<td>.class → 机器码</td>\n<td>HotSpot 的 C1、C2 编译器</td>\n</tr>\n</tbody>\n</table>\n<p>Ref：https://rensifei.site/2017/03/javac/</p>\n<h3 id=\"前端编译\">前端编译</h3>\n<p>大致可以分为3个过程：</p>\n<ol type=\"1\">\n<li>解析与填充符号表（Parse and Enter）</li>\n<li>注解处理（Annotation Processing）</li>\n<li>语义分析与字节码生成（Analyse and Generate）</li>\n</ol>\n<figure>\n<img src=\"/images/java/编译阶段.drawio.png\" alt=\"编译阶段.drawio\">\n<figcaption aria-hidden=\"true\">编译阶段.drawio</figcaption>\n</figure>\n<h4 id=\"parse-and-enter\">Parse and Enter</h4>\n<p>该阶段将源码解析构建抽象语法树（Abstract Syntax\nTree，AST）。从功能上分为词法分析和语法分析</p>\n<table>\n<colgroup>\n<col style=\"width: 6%\">\n<col style=\"width: 10%\">\n<col style=\"width: 14%\">\n<col style=\"width: 30%\">\n<col style=\"width: 38%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>功能</th>\n<th>输入</th>\n<th>输出</th>\n<th>处理范围</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>词法分析</td>\n<td>源代码字符流</td>\n<td>标记（Token）集合</td>\n<td>关键字、变量名、字面量、运算符</td>\n<td>将Java源代码按照Java关键字、自定义关键字、符号等按顺序分解为了可识别的Token流</td>\n</tr>\n<tr class=\"even\">\n<td>语法分析</td>\n<td>标记（Token）集合</td>\n<td>抽象语法树（AST）</td>\n<td>包、类型、运算符、修饰符、接口、返回值、代码注释</td>\n<td>将Token流组装成更结构化的<strong>语法树</strong>，描述程序代码语法结构，检查是否符合Java语言规范</td>\n</tr>\n<tr class=\"odd\">\n<td>填充符号表</td>\n<td></td>\n<td>符号表（Symbol Table）</td>\n<td></td>\n<td>由 com.sun.tools.javac.comp.Enter\n按照递归向下的顺序解析语法树，将所有类中出现的符号输入到自身的符号表，并将这些符号都存储到一个To\ndo List中。将这个To do List中的所有类都解析到各自的符号列表中（@-<span class=\"citation\" data-cites=\"不懂\">@不懂</span>）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"annotation-processing\">Annotation Processing</h4>\n<p>插入式注解处理器的处理过程，通过操作语法树，实现功能，具体的在后面讨论</p>\n<h4 id=\"analyse-and-generate\">Analyse and Generate</h4>\n<table>\n<colgroup>\n<col style=\"width: 7%\">\n<col style=\"width: 27%\">\n<col style=\"width: 21%\">\n<col style=\"width: 43%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>功能</th>\n<th>输入</th>\n<th>输出</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>语义分析</td>\n<td>抽象语法树</td>\n<td>标注检查和数据流分析后的语法树</td>\n<td>进行标注检查（变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配），数据及控制流分析（局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理）</td>\n</tr>\n<tr class=\"even\">\n<td>解语法糖</td>\n<td>泛型、变长参数、自动装箱/拆箱、断言等</td>\n<td>还原回简单的基础语法结构</td>\n<td>语法糖对语言的功能没有任何影响，只是更方便使用，让程序更简洁和可读性。JVM运行时不支持这些语法糖语法，需要在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖</td>\n</tr>\n<tr class=\"odd\">\n<td>字节码生成</td>\n<td>抽象语法树、符号表</td>\n<td>字节码文件</td>\n<td>前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中</td>\n</tr>\n</tbody>\n</table>\n<p>Ref: <a href=\"https://www.cnblogs.com/qingshanli/p/9375040.html\">浅析java中的语法糖</a></p>\n<h3 id=\"后端编译\">后端编译</h3>\n<p>目前 JVM 采用解释器和 JIT（Just-In-Time Compiler）混和模式</p>\n<p>没有 JIT 的情况下，javac 将源码编译为字节码，JVM\n解释器逐条读入字节码，逐条解释，翻译成对应的机器指令。经过解释，执行速度必然比可执行的二进制码程序执行慢；为了提高执行速度，引入了\nJIT。JIT 会把热点代码（Hot Spot\nCode）翻译过的机器码保存起来，已备下次使用</p>\n<blockquote>\n<p>所以 Java 是解释型还是编译型语言呢？</p>\n<p>答：前端阶段属于编译，后端阶段属于解释 + 编译的混合模式</p>\n</blockquote>\n<h2 id=\"插入式注解\">插入式注解</h2>\n<blockquote>\n<p>插入式注解（也叫编译时注解）内容只存在源文件，在编译期间被丢弃，不能通过JVM获取注解信息，Retention=SOURCE\n或 CLASS</p>\n</blockquote>\n<h3 id=\"原理\">原理</h3>\n<p>由上面介绍的Java源码编译过程可知，插入式注解，是处于前端编译的Annotation\nProcessing步骤，通过操作抽象语法树（AST）实现对应的方法</p>\n<h3 id=\"认识抽象语法树\">认识抽象语法树</h3>\n<p>使用 JDT AST 插件，对下面的代码生成语法树</p>\n<figure>\n<img src=\"/images/java/image-20230326204009345.png\" alt=\"image-20230326204009345\">\n<figcaption aria-hidden=\"true\">image-20230326204009345</figcaption>\n</figure>\n<p>新增了 getName 方法，重新生成语法树，查看区别</p>\n<figure>\n<img src=\"/images/java/image-20230326204126350.png\" alt=\"image-20230326204126350\">\n<figcaption aria-hidden=\"true\">image-20230326204126350</figcaption>\n</figure>\n<p>所以操作语法树，创建 MethodDeclaration\n节点，就相当于新增了一个方法</p>\n<p>下面介绍如何操作语法树</p>\n<h3 id=\"操作抽象语法树\">操作抽象语法树</h3>\n<h4 id=\"jctree\">JCTree</h4>\n<p>JCTree 是语法树元素的基类，JCTree 的一个子类就是 java\n语法中的一个节点，类、方法、字段等这些都被封装成了一个JCTree子类</p>\n<p>JCTree\n包含一个重要的字段<code>pos</code>，该字段用于指明当前节点在语法树中的位置，不能直接用new关键字来创建语法树节点，因为不指明\npos 的节点是没有意义的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class=\"line\">        Set&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span>&gt; elementSet = roundEnv.getElementsAnnotatedWith(Getter.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        elementSet.forEach(element -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取元素的JCTree对象</span></span><br><span class=\"line\">            <span class=\"type\">JCTree</span> <span class=\"variable\">jcTree</span> <span class=\"operator\">=</span> trees.getTree(element);</span><br><span class=\"line\">            jcTree.accept(<span class=\"keyword\">new</span> <span class=\"title class_\">TreeTranslator</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitClassDef</span><span class=\"params\">(JCTree.JCClassDecl jcClassDecl)</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (JCTree tree : jcClassDecl.defs) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (tree.getKind().equals(Tree.Kind.VARIABLE)) &#123;</span><br><span class=\"line\">                            JCTree.<span class=\"type\">JCVariableDecl</span> <span class=\"variable\">variable</span> <span class=\"operator\">=</span> (JCTree.JCVariableDecl) tree;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;variable &quot;</span> + variable.getName() + <span class=\"string\">&quot;\\t pos &quot;</span> + variable.getPreferredPosition());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (tree.getKind().equals(Tree.Kind.METHOD)) &#123;</span><br><span class=\"line\">                            JCTree.<span class=\"type\">JCMethodDecl</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> (JCTree.JCMethodDecl) tree;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;method &quot;</span> + method.getName() + <span class=\"string\">&quot;\\t pos &quot;</span> + method.getPreferredPosition());</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"built_in\">super</span>.visitClassDef(jcClassDecl);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 打印被 @Getter 修饰的 Dog.class 类的属性和方法：</span></span><br><span class=\"line\">variable name\t pos <span class=\"number\">74</span></span><br><span class=\"line\">variable age\t pos <span class=\"number\">101</span></span><br><span class=\"line\">variable color\t pos <span class=\"number\">126</span></span><br><span class=\"line\">method &lt;init&gt;\t pos <span class=\"number\">145</span></span><br><span class=\"line\">method say\t pos <span class=\"number\">213</span></span><br><span class=\"line\">method jump\t pos <span class=\"number\">284</span></span><br><span class=\"line\">method toString\t pos <span class=\"number\">333</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子可以看到，通过遍历 JCTree\n可以得到类的属性、方法节点，JCTree 的子类的含义如下：</p>\n<figure>\n<img src=\"/images/java/image-20230329001730499.png\" alt=\"image-20230329001730499\">\n<figcaption aria-hidden=\"true\">image-20230329001730499</figcaption>\n</figure>\n<p>JCTree 利用访问者模式，来操作 JCTree\n节点，目的是将数据与数据的处理进行解耦</p>\n<blockquote>\n<p>简单说下访问者模式：数据与数据的处理进行解耦</p>\n<p>现有数据是鸡🐔，对鸡的处理有很多：老张想养做宠物，小春想用来下蛋，小红想做宫保鸡丁，小王想咖喱鸡块，坤坤想...（很多很多人，对鸡的处理都不一样），这样在实现时，需要写很多的\nif 判断。用访问者模式，可以让鸡提供一个 accept(Vistor)\n方法，不同的人是不同的 Visitor，具体的处理是 Visior.visit(鸡)\n方法，当老张来处理，则 鸡.accept(老张)，accept 里会调用\n老张.visit(this)，然后执行老张的处理逻辑</p>\n<p>具体见：<a href=\"https://www.jianshu.com/p/1f1049d0a0f4\">访问者模式</a></p>\n</blockquote>\n<p>Ref：<a href=\"https://blog.csdn.net/a__int__/article/details/127485001\">java\nAbstractProcessor 编译时注解（API）</a></p>\n<h4 id=\"treemaker\">TreeMaker</h4>\n<p>TreeMaker 用于创建一系列的语法树节点，上面说了创建 JCTree\n不能直接使用 new 关键字来创建，所以 Java 为我们提供了一个工具，就是\nTreeMaker，必须使用上下文相关的TreeMaker对象来创建语法树节点，它在创建时为我们创建的\nJCTree 对象设置 pos 字段</p>\n<p>TreeMaker 常用方法见下面链接</p>\n<p>Ref：<a href=\"https://www.imooc.com/article/321973\">Java\n中的屠龙之术：如何修改语法树？</a></p>\n<h3 id=\"注解处理器\">注解处理器</h3>\n<p>注解处理器（Annotation Processing\nTool，简称APT），是JDK提供的工具，用于在编译阶段未生成class之前对源码中的注解进行扫描和处理</p>\n<p>处理方式对注解修饰的类的 AST 进行修改，生成新的 AST</p>\n<h3 id=\"实例演示\">实例演示</h3>\n<h4 id=\"demo1.-javac-编译版\">Demo1. Javac 编译版</h4>\n<blockquote>\n<p>下面通过开发注解处理器，给一个类自动生成 Getter 方法，实现类似 lombok\n的效果</p>\n</blockquote>\n<p>首先声明一个注解类，生命周期在 SOURCE 或 CLASS 都可以</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Getter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写Getter注解处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.sun.source.tree.Tree;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.api.JavacTrees;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.code.Flags;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.processing.JavacProcessingEnvironment;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.tree.JCTree;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.tree.TreeMaker;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.tree.TreeTranslator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.ListBuffer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Name;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.sun.tools.javac.util.Names;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.processing.AbstractProcessor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.processing.Messager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.processing.ProcessingEnvironment;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.processing.RoundEnvironment;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.processing.SupportedAnnotationTypes;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.processing.SupportedSourceVersion;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.lang.model.SourceVersion;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.lang.model.element.Element;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.lang.model.element.TypeElement;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.tools.Diagnostic;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Getter注解处理器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedAnnotationTypes(&quot;org.example.anno.Getter&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GetterProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractProcessor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messager messager;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 待处理的抽象语法树</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JavacTrees trees;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 封装了操作AST的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeMaker treeMaker;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 提供了创建标识符的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Names names;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(ProcessingEnvironment processingEnv)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.init(processingEnv);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.messager = processingEnv.getMessager();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.trees = JavacTrees.instance(processingEnv);</span><br><span class=\"line\">        <span class=\"type\">Context</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> ((JavacProcessingEnvironment)processingEnv).getContext();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.treeMaker = TreeMaker.instance(context);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.names = Names.instance(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 操作 AST</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class=\"line\">        Set&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Element</span>&gt; set = roundEnv.getElementsAnnotatedWith(Getter.class);</span><br><span class=\"line\">        set.forEach(element -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">JCTree</span> <span class=\"variable\">jcTree</span> <span class=\"operator\">=</span> trees.getTree(element);</span><br><span class=\"line\">            jcTree.accept(<span class=\"keyword\">new</span> <span class=\"title class_\">TreeTranslator</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">visitClassDef</span><span class=\"params\">(JCTree.JCClassDecl jcClassDecl)</span> &#123;</span><br><span class=\"line\">                    List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (JCTree tree : jcClassDecl.defs) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (tree.getKind().equals(Tree.Kind.VARIABLE)) &#123;</span><br><span class=\"line\">                            JCTree.<span class=\"type\">JCVariableDecl</span> <span class=\"variable\">jcVariableDecl</span> <span class=\"operator\">=</span> (JCTree.JCVariableDecl) tree;</span><br><span class=\"line\">                            jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    jcVariableDeclList.forEach(jcVariableDecl -&gt; &#123;</span><br><span class=\"line\">                        messager.printMessage(Diagnostic.Kind.NOTE, jcVariableDecl.getName() + <span class=\"string\">&quot; has been processed&quot;</span>);</span><br><span class=\"line\">                        jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                    <span class=\"built_in\">super</span>.visitClassDef(jcClassDecl);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JCTree.JCMethodDecl <span class=\"title function_\">makeGetterMethodDecl</span><span class=\"params\">(JCTree.JCVariableDecl jcVariableDecl)</span> &#123;</span><br><span class=\"line\">        ListBuffer&lt;JCTree.JCStatement&gt; statements = <span class=\"keyword\">new</span> <span class=\"title class_\">ListBuffer</span>&lt;&gt;();</span><br><span class=\"line\">        statements.append(treeMaker.Return(treeMaker.Select(treeMaker.Ident(names.fromString(<span class=\"string\">&quot;this&quot;</span>)), jcVariableDecl.getName())));</span><br><span class=\"line\">        JCTree.<span class=\"type\">JCBlock</span> <span class=\"variable\">body</span> <span class=\"operator\">=</span> treeMaker.Block(<span class=\"number\">0</span>, statements.toList());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> treeMaker.MethodDef(treeMaker.Modifiers(Flags.PUBLIC), getNewMethodName(jcVariableDecl.getName()), jcVariableDecl.vartype, List.nil(), List.nil(), List.nil(), body, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Name <span class=\"title function_\">getNewMethodName</span><span class=\"params\">(Name name)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> name.toString();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> names.fromString(<span class=\"string\">&quot;get&quot;</span> + s.substring(<span class=\"number\">0</span>, <span class=\"number\">1</span>).toUpperCase() + s.substring(<span class=\"number\">1</span>, name.length()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Ref：<a href=\"https://blog.mythsman.com/post/5d2c11c767f841464434a3bf/\">Lombok原理分析与功能实现</a></p>\n<p>要生成 Getter 方法的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译 Dog.java，指定注解处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Run</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">commonPath</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;/Users/zhangjiaming/workspace/gitlab/java-agent-demo/anno-demo&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> commonPath + <span class=\"string\">&quot;/src/main/java/org/example/anno/Dog.java&quot;</span>;</span><br><span class=\"line\">        com.sun.tools.javac.main.<span class=\"type\">Main</span> <span class=\"variable\">compiler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">com</span>.sun.tools.javac.main.Main(<span class=\"string\">&quot;javac&quot;</span>);</span><br><span class=\"line\">        args = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[] &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;-processor&quot;</span>, <span class=\"string\">&quot;org.example.anno.GetterProcessor&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;-processorpath&quot;</span>, commonPath + <span class=\"string\">&quot;/src/main/java&quot;</span>,</span><br><span class=\"line\">          <span class=\"string\">&quot;-d&quot;</span>, commonPath + <span class=\"string\">&quot;/classes&quot;</span>,</span><br><span class=\"line\">          str</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rc</span> <span class=\"operator\">=</span> compiler.compile(args).exitCode;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;result code : &quot;</span> + rc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行后，查看Dog.class的反编译结果，发现已生成 getName 方法</p>\n<figure>\n<img src=\"/images/java/image-20230328142409017.png\" alt=\"image-20230328142409017\">\n<figcaption aria-hidden=\"true\">image-20230328142409017</figcaption>\n</figure>\n<h4 id=\"demo.2-mvn打包版\">Demo.2 mvn打包版</h4>\n<h5 id=\"注解工程\">注解工程</h5>\n<blockquote>\n<p>上面的例子需要在编译过程中指定注解处理器；下面尝试将注解处理器打包，由其他工程以\njar 包形式引入，真正达到 lombok 的效果</p>\n</blockquote>\n<p>项目结构如下</p>\n<figure>\n<img src=\"/images/java/image-20230330173700415.png\" alt=\"image-20230330173700415\">\n<figcaption aria-hidden=\"true\">image-20230330173700415</figcaption>\n</figure>\n<p>在 resources/META-INF/services下新建文件\n<code>javax.annotation.processing.Processor</code>，内容如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">org.example.anno.GetterProcessor</span></span><br><span class=\"line\"><span class=\"string\">org.example.anno.SetterProcessor</span></span><br></pre></td></tr></table></figure>\n<p>pom.xml中加入构建方式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">compilerArgument</span>&gt;</span></span><br><span class=\"line\">                      -proc:none</span><br><span class=\"line\">                  <span class=\"tag\">&lt;/<span class=\"name\">compilerArgument</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">source</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">source</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">target</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">target</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>构建，生成 jar 文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn clean package</span><br></pre></td></tr></table></figure>\n<h5 id=\"测试工程\">测试工程</h5>\n<p>将注解工程 jar 包引入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.example<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>anno-jar<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>system<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">systemPath</span>&gt;</span>/Users/zhangjiaming/workspace/gitlab/java-agent-demo/anno-jar/target/anno-jar-1.0-SNAPSHOT.jar<span class=\"tag\">&lt;/<span class=\"name\">systemPath</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>编写测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.example.model;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.example.anno.Getter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.example.anno.Setter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String color;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer weight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Boolean big;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Dog</span><span class=\"params\">(String name, String color, Integer weight)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.color = color;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.weight = weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Dog</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Dog</span> <span class=\"variable\">dog</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;zhangjiaming&quot;</span>, <span class=\"string\">&quot;white&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"> \t\t\t\tSystem.out.println(dog.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译并打包：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn clean <span class=\"keyword\">package</span></span><br></pre></td></tr></table></figure>\n<p>（运行指令报错，待研究）</p>\n<p>运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">javac org.example.model.Dog</span><br><span class=\"line\"><span class=\"comment\">// output: zhangjiaming</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"遇到问题\">遇到问题</h4>\n<p>在测试工程目录下执行 <code>mvn clean package</code> 报错如下</p>\n<figure>\n<img src=\"/images/java/image-20230401003903758.png\" alt=\"image-20230401003903758\">\n<figcaption aria-hidden=\"true\">image-20230401003903758</figcaption>\n</figure>\n<p>不过用 idea 的 maven package 工具打包成功，具体原因待研究</p>\n<p>完整项目见 github\n地址：https://github.com/Shaun2016/anno-practice</p>\n<h2 id=\"运行时注解\">运行时注解</h2>\n<blockquote>\n<p>运行时注解，在编译时被写入字节码文件中，可以通过 JVM\n运行时获取注解信息（Retention=RUNTIME）</p>\n</blockquote>\n<h3 id=\"原理-1\">原理</h3>\n<blockquote>\n<p>使用下面的例子方便说明</p>\n<p>注解：TestAnnotation</p>\n<p>注解实用类：Dog</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@interface</span> TestAnnotation &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">level</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    String <span class=\"title function_\">desc</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@TestAnnotation(</span></span><br><span class=\"line\"><span class=\"meta\">    level = 123,</span></span><br><span class=\"line\"><span class=\"meta\">    desc = &quot;This is a test annotation&quot;</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol type=\"1\">\n<li>编译 Dog.java，注解会被写入到被 Dog 类的字节码文件中</li>\n<li>类加载器将被 Dog 类加载到 JVM 中，并通过 RuntimeVisibleAnnotations\n等属性保存注解 key-value 关系，通过 Map 来保存</li>\n<li>通过 JDK 动态代理，将注解类（本质是一个接口）生成代理对象</li>\n<li>调用代理对象的对应的方法（level 和 desc 方法），会调用注解处理器的\ninvoke 方法</li>\n<li>注解处理器从 Dog Class 对象的 RuntimeVisibleAnnotations 等属性的 Map\n中找到对应的返回值</li>\n</ol>\n<h4 id=\"实例\">实例</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Class&lt;Dog&gt; clazz = Dog.class;</span><br><span class=\"line\">    <span class=\"type\">TestAnnotation</span> <span class=\"variable\">myAnnotation</span> <span class=\"operator\">=</span> clazz.getAnnotation(TestAnnotation.class);</span><br><span class=\"line\">    System.out.println(myAnnotation.desc());</span><br><span class=\"line\">    System.out.println(myAnnotation.level());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下文将针对运行时注解，介绍AOP相关的内容</p>\n<h2 id=\"总结\">总结</h2>\n<p>本文介绍了注解的分类：插入式注解和运行时注解，主要介绍了插入式注解的原理，为了更好的说清楚，引入了\njava\n的编译过程，并介绍了插入式注解在编译过程中的哪个阶段；插入式注解主要是操作了AST，JCTree\n用来封装 AST 节点，TreeMaker 是操作 AST的工具，并自己模拟实现了 lombok\n的 getter 和 setter 注解，最终自动生成了 getter 和 setter\n方法；最后简单介绍了运行时注解的原理</p>\n<h2 id=\"引文\">引文</h2>\n<p><a href=\"https://rensifei.site/2017/03/javac/\">javac源码笔记与简单的编译原理</a></p>\n<p><a href=\"https://blog.csdn.net/havedream_one/article/details/124141251\">java\n抽象语法树（AST）系列一：概述</a></p>\n<p><a href=\"https://blog.mythsman.com/post/5d2c11c767f841464434a3bf/\">Lombok原理分析与功能实现</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_38860401/article/details/126593388\">Java编译时注解学习，并简单实现Lombok</a></p>\n<p><a href=\"https://blog.csdn.net/u014454538/article/details/122531293\">3.\n自定义Java编译时注解处理器</a></p>\n<p><a href=\"https://heapdump.cn/c/2608464/lecture/2643150\">（第二讲）JVM字节码的探索与实践应用之《注解的原理与应用》</a></p>\n","tags":["java"]},{"title":"jvm 优雅停机","url":"/2023/07/21/java/graceful-shutdwon/","content":"<blockquote>\n<p>本文讨论如何让 jvm 优雅停机</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"什么是优雅停机\">什么是优雅停机</h2>\n<p>向应用进程发出停止指令之后，能保证正在执行的业务操作不受影响，直到操作运行完毕之后再停止进程</p>\n<h2 id=\"要解决的问题\">要解决的问题</h2>\n<ol type=\"1\">\n<li>停止接收新的请求，停止启动新的定时任务，停止接收消息</li>\n<li>正在处理的请求，等待请求处理完；正在执行的任务、消息，执行完毕</li>\n</ol>\n<h2 id=\"异常关闭应用程序的危害\">异常关闭应用程序的危害</h2>\n<p>如果暴力的关闭应用程序，比如通过<code>kill -9 &lt;pid&gt;</code>命令强制直接关闭应用程序进程，可能造成如下危害：</p>\n<ol type=\"1\">\n<li>正在执行的任务数据丢失或者产生中间数据</li>\n<li>任务所持有的全局资源等不到释放，比如当前任务持有 redis\n的锁，并没有设置过期时间</li>\n<li>注册中心场景，没有主动更新服务列表，导致一段时间内请求到不存在的实例</li>\n</ol>\n<h2 id=\"jvm-的停机场景\">JVM 的停机场景</h2>\n<p>导致 JVM 正常关闭的场景有：</p>\n<ol type=\"1\">\n<li>程序运行结束</li>\n<li>JVM 发生 OOM 而退出</li>\n<li>Java 程序执行 System.exit() 指令</li>\n<li>操作系统关闭</li>\n<li>kill pid（kill -15 pid）</li>\n<li>终端通过 Ctrl-C 终止进程</li>\n</ol>\n<p>导致 JVM 异常关闭的场景有：</p>\n<ol type=\"1\">\n<li>kill -9</li>\n<li>主机关机</li>\n<li>主机内存不够触发操作系统 OOM-KILLER</li>\n</ol>\n<h2 id=\"jvm-优雅停机的实现\">JVM 优雅停机的实现</h2>\n<h3 id=\"实现思路\">实现思路</h3>\n<ol type=\"1\">\n<li>利用 JDK 提供的 Runtime.getRuntime().addShutdownHook() 方法注册\nShutdown Hook，用来接收操作系统发送的停止信号；</li>\n<li>当接收到停止信号时，执行停机的处理逻辑：\n<ol type=\"1\">\n<li>拒绝接收新的请求、消息、任务</li>\n<li>处理已接收的请求、消息、任务</li>\n</ol></li>\n<li>注意超时和异常：在处理已有请求和执行停机逻辑时，可能有时间过长的时间，需要设置一个超时时间，避免进程一直无法退出；捕获异常防止停机逻辑中断</li>\n</ol>\n<h3 id=\"处理已有请求\">处理已有请求</h3>\n<p>注册JDK的ShutdownHook</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.example;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Integer redisLock;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hook</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Runtime.getRuntime().addShutdownHook(<span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Receive shutdown signal&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (redisLock == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;RedisLock not released&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">                redisLock = <span class=\"number\">0</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;redisLock is closed&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注册 shutdownHook</span></span><br><span class=\"line\">        hook();</span><br><span class=\"line\">        <span class=\"comment\">// 建立连接 占用锁资源</span></span><br><span class=\"line\">        redisLock = <span class=\"number\">1</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;running...&quot;</span>);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;exit&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 web\n服务中，需要等待已接收的请求处理完，请求都有超时时间，只要等待大于超时时间即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Runtime.getRuntime().addShutdownHook(<span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10000L</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;));</span><br></pre></td></tr></table></figure>\n<p>对于线程池</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hook</span><span class=\"params\">(ExecutorService executor)</span> &#123;</span><br><span class=\"line\">        Runtime.getRuntime().addShutdownHook(<span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                executor.shutdown();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;executor reject new tasks&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!executor.awaitTermination(<span class=\"number\">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">                    System.err.println(<span class=\"string\">&quot;Executor did not terminate in time.&quot;</span>);</span><br><span class=\"line\">                    executor.shutdownNow(); <span class=\"comment\">// 强制终止线程池</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;executor shutdown&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"拒绝新的请求\">拒绝新的请求</h3>\n<p>如何拒绝新的请求，不同的服务架构做法不同，下面例举几个常见的场景</p>\n<h4 id=\"nginx-挂载多服务实例\">Nginx 挂载多服务实例</h4>\n<p>先了解下 nginx 如何维护健康实例列表</p>\n<p>Nginx 支持两种健康检查模式：</p>\n<ol type=\"1\">\n<li><p>被动检查</p>\n<p>nginx 在代理请求过程中，会检测 upstream_server\n对请求的响应，如果得到某个 upstream_server\n在单位周期（fail_timeout）内失败次数超过阈值（max_fails，默认值为1），标记该\nupstream_server 为异常；等下一个\nfail_timeout，会再去请求一次，如果成功，将 upstream_server\n标记为可用</p>\n<p>upstream_server 不需要专门提供健康检查接口</p>\n<p>如果发现本次请求失败，nginx 会转发给其他节点处理</p></li>\n<li><p>主动检查</p>\n<p>Nginx 服务定时向 upstream_server 发出健康检查请求，验证各个\nupstream_server 的状态，同上</p>\n<p>upstream_server 需要专门给 nginx\n提供一个健康检查的低消耗接口</p></li>\n</ol>\n<p>使用 nginx 做负载均衡，执行shutdown Hook如下：</p>\n<ol type=\"1\">\n<li>停机实例拒绝 nginx 的健康检查，nginx\n将停机实例从均衡器列表中移除</li>\n<li>停机实例关闭服务的Server端监听，保证不接受请求</li>\n</ol>\n<h4 id=\"服务注册发现\">服务注册发现</h4>\n<p>当服务端实例停止后，由于服务端不会主动去更改注册中心的注册信息，注册中心需要40秒（目前应用到Zookeeper的会话超时时间配置）才能剔除这个异常配置，在这40秒内会不断尝试访问这个不存在的实例，导致产生大量业务报错，所以在停机时需要主动从注册中心下线</p>\n<ol type=\"1\">\n<li><p>从注册中心下线，断开与 zookeeper 的连接</p>\n<ol type=\"a\">\n<li><p>Provider 取消所有注册</p></li>\n<li><p>Consumer 取消所有订阅</p></li>\n</ol></li>\n<li><p>协议关闭（关闭心跳检测、关闭通道）</p>\n<ol type=\"a\">\n<li><p>关闭 provider 端的监听（server.close）</p></li>\n<li><p>关闭 consumer 对其他服务的引用（client.close）</p></li>\n</ol></li>\n</ol>\n<h4 id=\"消息发布\">消息发布</h4>\n<p>消费者：</p>\n<ol type=\"1\">\n<li>停止 poll 消息</li>\n<li>关闭 consumer 与 broker 的连接（consumer.close）</li>\n</ol>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"https://blog.csdn.net/qq_34050399/article/details/129352895\">项目上如何处理优雅启停的问题？</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/428393733\">实操：大规模微服务架构下的优雅停机</a></p>\n<p><a href=\"https://developer.aliyun.com/article/701258\">dubbo -\n优雅停机</a></p>\n<p>[Dubbo源代码分析九：优雅停机](</p>\n","tags":["jvm"]},{"title":"三种IO模型","url":"/2022/10/08/io/io-model/","content":"<blockquote>\n<p>本文简述三种IO模型</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"客户端与服务端建立连接的过程\">客户端与服务端建立连接的过程</h2>\n<h3 id=\"涉及到的内核调用\">涉及到的内核调用</h3>\n<h4 id=\"socket\">socket</h4>\n<p>功能：创建通信端点并返回描述符</p>\n<blockquote>\n<p>函数</p>\n<p><code>int socket(int domain, int type, int protocol)</code></p>\n<p>参数</p>\n<p>domain：通信域，选择用于通信的协议族，如ipv4，ipv6</p>\n<p>type：socket的类型，包括：SOCK_STREAM，SOCK_DGRAM等</p>\n<p>返回值</p>\n<p>成功，新创建的socket的文件描述符；失败，返回-1</p>\n</blockquote>\n<h4 id=\"bind\">bind</h4>\n<p>功能：为Socket分配地址，这个地址指向一个地址结构</p>\n<blockquote>\n<p>函数</p>\n<p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)</code></p>\n<p>参数</p>\n<p>sockfd：Socket的文件描述符</p>\n<p>addr：服务端通信的地址和端口</p>\n<p>addrlen：addr结构体的大小</p>\n<p>返回值</p>\n<p>成功，返回0，失败，返回-1</p>\n</blockquote>\n<h4 id=\"listen\">listen</h4>\n<p>功能：标记一个Socket的文件描述符为活跃状态，标记后，这个Socket可以用来接收连接请求</p>\n<blockquote>\n<p>函数</p>\n<p><code>int listen(int sockfd, int backlog);</code></p>\n<p>参数</p>\n<p>sockfd：Socket的文件描述符</p>\n<p>backlog：定义了sockfd的待接收的阻塞队列最大长度，如果连接请求在队列中已满，客户端会收到错误提示，或者重试连接</p>\n<p>返回</p>\n</blockquote>\n<h4 id=\"accept\">accept</h4>\n<p>功能：从阻塞连接队列中，拿出第一个连接请求，创建一个新的已连接状态的Socket</p>\n<blockquote>\n<p>函数</p>\n<p>int accept(int sockfd, struct sockaddr * addr, socklen_t\n*addrlen);</p>\n<p>int accept4(int sockfd, struct sockaddr <em>addr, socklen_t\n</em>addrlen, int flags)</p>\n<p>参数</p>\n<p>sockfd：通过socket，bind，listen创建的socket文件描述符</p>\n<p>sockaddr：指向sockaddr结构体，保存对端的地址</p>\n<p>addrlen：addr结构体的大小</p>\n<p>返回</p>\n<p>成功，返回非负数的已接收的文件描述符；失败，返回-1</p>\n</blockquote>\n<h2 id=\"客户端代码\">客户端代码</h2>\n<p>由于客户端在不同IO模型中都是通用的，所以先列举下客户端代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SocketClient</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">SERVER_IP</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;192.168.174.101&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">PORT</span> <span class=\"operator\">=</span> <span class=\"number\">9090</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>(SERVER_IP,PORT);</span><br><span class=\"line\">        <span class=\"type\">OutputStream</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> client.getOutputStream();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> System.in;</span><br><span class=\"line\">        <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(in));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> reader.readLine();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(line != <span class=\"literal\">null</span> )&#123;</span><br><span class=\"line\">                <span class=\"type\">byte</span>[] bb = line.getBytes();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">byte</span> b : bb) &#123;</span><br><span class=\"line\">                    out.write(b);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"bio\">BIO</h2>\n<h3 id=\"server-代码\">Server 代码</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.ServerSocket;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.Socket;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BIOServer</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">port</span> <span class=\"operator\">=</span> <span class=\"number\">9090</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">backlog</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// socket bind listen</span></span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">serverSocket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>(port, backlog);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;new socket &quot;</span> + port);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 监听 server accept，创建一个新的用来连接客户端Socket</span></span><br><span class=\"line\">            <span class=\"type\">Socket</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> serverSocket.accept();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;accept &quot;</span> + getClientInfo(client));</span><br><span class=\"line\">            <span class=\"comment\">// 创建线程从socket中一直读数据</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    inputStream = client.getInputStream();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(inputStream));</span><br><span class=\"line\">                    <span class=\"type\">char</span>[] data = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> reader.read(data);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (num &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;read some data is :&quot;</span> + num + <span class=\"string\">&quot; val :&quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(data, <span class=\"number\">0</span>, num));</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;read nothing&quot;</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;read &quot;</span> + num);</span><br><span class=\"line\">                            client.close();</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(getClientInfo(client) + <span class=\"string\">&quot; 端口连接&quot;</span>);</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"title function_\">getClientInfo</span><span class=\"params\">(Socket client)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;client: &quot;</span> + client.getInetAddress().getHostAddress() + client.getPort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">BIOServer</span> <span class=\"variable\">bioServer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BIOServer</span>();</span><br><span class=\"line\">        bioServer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"存在问题\">存在问题</h3>\n<ol type=\"1\">\n<li>每个连接都要创建一个线程，创建线程是要发起一个软中断，从用户态切换到内核态，调用内核指令（创建线程是一个很耗时的操作）</li>\n<li>当连接的客户端数量多时，线程数量增多，对内存的消耗大</li>\n</ol>\n<h2 id=\"nio\">NIO</h2>\n<h3 id=\"server-代码-1\">Server 代码</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NIOServer</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LinkedList&lt;SocketChannel&gt; clients = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">        ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">9090</span>));</span><br><span class=\"line\">        ssc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">SocketChannel</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> ssc.accept();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (client != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                client.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;accept client port: &quot;</span> + client.socket().getPort());</span><br><span class=\"line\">                clients.add(client);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">byteBuffer</span> <span class=\"operator\">=</span> ByteBuffer.allocateDirect(<span class=\"number\">4096</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (SocketChannel c : clients) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> c.read(byteBuffer);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (num &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    byteBuffer.flip();</span><br><span class=\"line\">                    <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[byteBuffer.limit()];</span><br><span class=\"line\">                    byteBuffer.get(bytes);</span><br><span class=\"line\">                    <span class=\"type\">String</span> <span class=\"variable\">rec</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(bytes);</span><br><span class=\"line\">                    System.out.println(c.socket().getPort() + <span class=\"string\">&quot;: &quot;</span> + rec);</span><br><span class=\"line\">                    byteBuffer.clear();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">NIOServer</span> <span class=\"variable\">nioServer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NIOServer</span>();</span><br><span class=\"line\">        nioServer.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"相比bio的改进\">相比BIO的改进</h3>\n<ol type=\"1\">\n<li>不需要创建多个线程，节省了创建线程和内存开销</li>\n</ol>\n<h3 id=\"存在问题-1\">存在问题</h3>\n<ol type=\"1\">\n<li>由客户端对所有连接执行系统调用<strong>read</strong>（软中断，用户态切换到内核态），其中很多连接中没有数据，导致很多read调用是无意义的，造成资源的浪费</li>\n<li>随着连接的客户端增多，每次循环都要O(n)复杂度的<strong>read系统调用</strong></li>\n</ol>\n<h2 id=\"select-poll-的多路复用\">select &amp; poll 的多路复用</h2>\n<h3 id=\"server-代码-2\">Server 代码</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SelectionKey;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.Selector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.StandardCharsets;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MultiplexServer</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        server = ServerSocketChannel.open();</span><br><span class=\"line\">        server.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        server.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">9090</span>));</span><br><span class=\"line\">        selector = Selector.open();</span><br><span class=\"line\">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        initServer();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            Set&lt;SelectionKey&gt; keySet = selector.keys();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (selector.select() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 返回有状态的fd集合</span></span><br><span class=\"line\">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class=\"line\">                <span class=\"comment\">// 遍历有状态的fds，判断是 listen 还是通信</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                    iterator.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                        acceptHandler(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                        readHandler(key);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isWritable()) &#123;</span><br><span class=\"line\">                        writeHandler(key);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acceptHandler</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">        <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> ssc.accept();</span><br><span class=\"line\">        channel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">byteBuffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">4096</span>);</span><br><span class=\"line\">        channel.register(selector, SelectionKey.OP_READ, byteBuffer);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;有新客户端连接：&quot;</span> + channel.getRemoteAddress());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readHandler</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuffer) key.attachment();</span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            read = channel.read(buffer);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (read &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;read client: &quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buffer.array(), <span class=\"number\">0</span>, read));</span><br><span class=\"line\">                channel.register(key.selector(), SelectionKey.OP_WRITE, buffer);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (read == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                channel.close();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;client: &quot;</span> + channel.getRemoteAddress() + <span class=\"string\">&quot; closed&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">writeHandler</span><span class=\"params\">(SelectionKey key)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;write handler&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">SocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sendText</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;response message ------&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuffer) key.attachment();</span><br><span class=\"line\">        buffer.put(sendText.getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">            ssc.write(buffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ssc.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">MultiplexServer</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MultiplexServer</span>();</span><br><span class=\"line\">        server.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"相比nio的改进\">相比NIO的改进</h3>\n<p>select&amp;poll的多路复用和NIO，都要遍历所有的连接询问状态，区别是，NIO的遍历由用户发起，涉及用户态到内核态的切换的系统调用；多路复用器只有一次系统调用，内核根据用户传过来的fds，遍历，返回所有有状态的fds，再由用户read</p>\n<h3 id=\"存在问题-2\">存在问题</h3>\n<ol type=\"1\">\n<li>每次select或poll都要传递所有的fds，其中，select要将整个fds列表传递给内核，有大量的内存拷贝</li>\n<li>内核需要遍历全量fds，O(N)的时间复杂度，不是所有的fd都有数据要读，所以有一定的浪费</li>\n</ol>\n<h2 id=\"epoll-的多路复用\">epoll 的多路复用</h2>\n<h3 id=\"epoll-的原理\">epoll 的原理</h3>\n<p>完成epoll操作一共有三个步骤，即三个函数互相配合：<code>epoll_create</code>，<code>epoll_ctl</code>，<code>epoll_wait</code></p>\n<p>先用<code>epoll_create</code>创建一个epoll对象epfd，再通过<code>epoll_ctl</code>将需要监视的socket添加到epfd中，最后调用<code>epoll_wait</code>等待数据。\n当执行<code>epoll_create</code>时\n，系统会在内核中创建一个红黑树和就绪链表。 当执行epoll_ctl放入socket时\n，epoll会检测上面的红黑树是否存在这个socket，存在的话就立即返回，不存在就添加。然后给内核中断处理程序注册一个回调函数，告诉内核，如果这个socket句柄的中断到了，就把它放到准备就绪list链表里。如果网卡有数据到达，向cpu发出中断信号，cpu响应中断，中断程序就会执行前面的回调函数。红黑树是自平衡的二叉排序树，适合频繁插入和删除的场景。增删查一般时间复杂度是\nO(logn)。</p>\n<p>epoll_wait就只检查就绪链表，如果链表不为空，就返回就绪链表中就绪的socket，否则就等待。只将有事件发生的\nSocket 集合传递给应用程序，不需要像 select/poll\n那样轮询扫描整个集合（包含有和无事件的 Socket\n），大大提高了检测的效率</p>\n<figure>\n<img src=\"/images/io/image-20221008035527210.png\" alt=\"image-20221008035527210\">\n<figcaption aria-hidden=\"true\">image-20221008035527210</figcaption>\n</figure>\n<h3 id=\"epoll-的实现流程\">epoll 的实现流程</h3>\n<p><img src=\"/images/io/epoll_原理.png\"></p>\n<h4 id=\"epoll_create-创建-epoll-对象\">epoll_create 创建 epoll 对象</h4>\n<p><code>epoll_create</code>是内核提供的一个创建epoll对象的系统调用，当用户进程调用\nepoll_create 时，内核会创建一个 struct eventpoll</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventpoll</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 等待队列，存放阻塞在epoll上的进程</span></span><br><span class=\"line\">    <span class=\"type\">wait_queue_head_t</span> wq;</span><br><span class=\"line\">    <span class=\"comment\">// 就绪队列，存放IO就绪的socket连接</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">rdllist</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 红黑树，用来管理所有监听的socket连接</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_root</span> <span class=\"title\">rbr</span>;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"epoll_ctl-向-epoll-对象中添加要监听的socket\">epoll_ctl 向 epoll\n对象中添加要监听的Socket</h4>\n<ol type=\"1\">\n<li><p>epoll中用<code>struct epitem</code>表示一个Socket连接，epoll\n使用红黑树管理大量的socket连接，<code>struct epitem</code>\n就是红黑树上的一个个节点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epitem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">//指向所属epoll对象</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventpoll</span> *<span class=\"title\">ep</span>;</span> </span><br><span class=\"line\">    <span class=\"comment\">//注册的感兴趣的事件,也就是用户空间的epoll_event     </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">event</span>;</span> </span><br><span class=\"line\">    <span class=\"comment\">//指向epoll对象中的就绪队列</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">rdllink</span>;</span>  </span><br><span class=\"line\">    <span class=\"comment\">//指向epoll中对应的红黑树节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">rbn</span>;</span>     </span><br><span class=\"line\">    <span class=\"comment\">//指向epitem所表示的socket-&gt;file结构以及对应的fd</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_filefd</span> <span class=\"title\">ffd</span>;</span>                  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在内核中创建完<code>struct epitem</code>后，在Socket中的等待队列上创建等待项<code>wait_queue_t</code>并注册epoll的回调函数<code>ep_poll_callback</code></p></li>\n<li><p>在<code>ep_poll_callback</code>中可以根据Socket等待队列中的等待项<code>wait</code>，通过<code>eppoll_entry</code>\n关联\n<code>epitem</code>后，将<code>epitem</code>插入到<code>epoll</code>中的红黑树<code>struct rb_root rbr</code>中</p></li>\n</ol>\n<h4 id=\"epoll_wait同步阻塞获取io就绪的socket\">epoll_wait同步阻塞获取IO就绪的Socket</h4>\n<ol type=\"1\">\n<li>用户程序调用<code>epoll_wait</code>后，内核查找epoll中的就绪队列<code>event_poll-&gt;rdllist</code>是否有IO就绪的epitem，如果有，将就绪的socket信息封装到<code>epoll_event</code>返回</li>\n</ol>\n<h3 id=\"相比于-selectpoll-的多路复用的改进\">相比于 select&amp;poll\n的多路复用的改进</h3>\n<ol type=\"1\">\n<li>不需要用户程序传递fds，由内核通过红黑树维护所有的fd，减少内存拷贝</li>\n<li>不需要内核遍历全量fds，而是通过callback将IO就绪的Socket放到就绪队列中，提高了性能</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<p>本文简述了三种IO模型，包括BIO、NIO、多路复用器，分别描述了三者的原理，比较了优缺点</p>\n<p>Todo1：本文没有对三者进行实验，未能产生数据上的比较分析，在实现细节上有很多地方还没有搞清楚，待后续学习并补充</p>\n<p>Todo2：本文未能从系统调用的过程进行分析，待补充</p>\n<h2 id=\"参考文献\">参考文献</h2>\n","categories":["IO"],"tags":["IO"]},{"title":"java8 链式编程","url":"/2023/02/18/java/java-lambda/","content":"<blockquote>\n<p>本文介绍 java8 lambda表达式的技巧</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"npe-的处理\">NPE 的处理</h2>\n<h3 id=\"入参判空\">入参判空</h3>\n<p>空引用空指针是无数个错误的来源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">DogDO</span> <span class=\"variable\">dogDO</span> <span class=\"operator\">=</span> getDog();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dogDO != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        System.out.println(dogDO.getName() + <span class=\"string\">&quot;, &quot;</span> + dogDO.getAge());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 Optional 是这样写的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">DogDO</span> <span class=\"variable\">dogDO</span> <span class=\"operator\">=</span> getDog();</span><br><span class=\"line\">    Optional.ofNullable(dogDO).ifPresent(d -&gt; System.out.println(d.getName() + <span class=\"string\">&quot;, &quot;</span> + d.getAge()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数返回值非空\">函数返回值非空</h3>\n<p>普通的写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> DogDO <span class=\"title function_\">playWithDog</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">DogDO</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (d != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DogDO</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们的函数返回时，保证不返回空，可以使用 orElse 与 orElseGet</p>\n<p>对象做默认值用 orElse，方法返回值做默认值用 orElseGet</p>\n<p>如下，确实简洁了很多</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> DogDO <span class=\"title function_\">playWithDog</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">DogDO</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">    <span class=\"comment\">// return Optional.ofNullable(d).orElseGet(this::getDefaultDog);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.ofNullable(d).orElse(<span class=\"keyword\">new</span> <span class=\"title class_\">DogDO</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对应的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Optional&lt;T&gt; <span class=\"title function_\">ofNullable</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value == <span class=\"literal\">null</span> ? empty() : of(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Optional&lt;T&gt; <span class=\"title function_\">of</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Optional</span>&lt;&gt;(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Optional&lt;T&gt; <span class=\"title function_\">empty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"title function_\">orElse</span><span class=\"params\">(T other)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value != <span class=\"literal\">null</span> ? value : other;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"title function_\">orElseGet</span><span class=\"params\">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value != <span class=\"literal\">null</span> ? value : other.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"集合处理\">集合处理</h2>\n<h3 id=\"将a类型集合转为b类型集合\">将A类型集合转为B类型集合</h3>\n<p>下面是集合中的对象：DO 狗和 DTO 狗</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DogDO</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DogDTO</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在要对一个 DogDO 列表，将符合条件的拿出来，转为 DogDTO\n列表，一般的写法是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 将 dogDOList 转为 DogDTOList</span><br><span class=\"line\"> */</span><br><span class=\"line\">public List&lt;DogDTO&gt; convert(List&lt;DogDO&gt; dogDOList) &#123;</span><br><span class=\"line\">\t\tList&lt;DogDTO&gt; dogDTOList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">\t\tif (CollectionUtils.isEmpty(dogDOList)) &#123;</span><br><span class=\"line\">\t\t\t\treturn dogDTOList;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">    for (DogDO dogDO : dogDOList) &#123;</span><br><span class=\"line\">    \t\t// 去掉空狗和未成年狗</span><br><span class=\"line\">        if (dogDO == null || dogDO.getAge() &lt; 18) &#123;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        DogDTO dogDTO = new DogDTO();</span><br><span class=\"line\">        dogDTO.setName(dogDO.getName());</span><br><span class=\"line\">        dogDTO.setAge(dogDO.getAge());</span><br><span class=\"line\">        dogDTOList.add(dogDTO);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dogDTOList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 lambda 表达式可改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;DogDTO&gt; <span class=\"title function_\">convert</span><span class=\"params\">(List&lt;DogDO&gt; dogDOList)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.ofNullable(dogDOList).orElse(Collections.emptyList()).stream().filter(Objects::nonNull).filter(d-&gt;d.getAge() &gt; <span class=\"number\">18</span>).map(e -&gt; &#123;</span><br><span class=\"line\">        <span class=\"type\">DogDTO</span> <span class=\"variable\">dogDTO</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DogDTO</span>();</span><br><span class=\"line\">        dogDTO.setName(e.getName());</span><br><span class=\"line\">        dogDTO.setAge(e.getAge());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogDTO;</span><br><span class=\"line\">    &#125;).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"提取单个属性\">提取单个属性</h3>\n<blockquote>\n<p>和上面的转换是一样的，只不过 map 中\n是类型转换还是直接返回某个属性值</p>\n</blockquote>\n<p>要从狗集合中抽出狗昵称，普通的写法是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从狗列表中提取狗昵称</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">getNamesFromDogs</span><span class=\"params\">(List&lt;DogDO&gt; dogDOList)</span> &#123;</span><br><span class=\"line\">  \tList&lt;String&gt; names = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dogDOList == <span class=\"literal\">null</span> || dogDOList.isEmpty()non) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> names;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (DogDO dogDO : dogDOList) &#123;</span><br><span class=\"line\">    \t\t<span class=\"comment\">// 去掉空狗</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dogDO == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        names.add(dogDO.getName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> names;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Lambda 写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从狗列表中提取狗昵称</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">getNamesFromDogs</span><span class=\"params\">(List&lt;DogDO&gt; dogDOList)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.ofNullable(dogDOList).orElse(Collections.emptyList()).stream().</span><br><span class=\"line\">            filter(Objects::nonNull).map(DogDO::getName).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出用 lambda\n表达式确实很简洁，逻辑上虽然没有普通写法那么清晰，不过习惯了还好</p>\n<h3 id=\"集合类型的转换\">集合类型的转换</h3>\n<blockquote>\n<p>List 转 Map</p>\n</blockquote>\n<h4 id=\"列表转属性-对象的字典\">列表转属性-对象的字典</h4>\n<p>现将一个狗列表转为 {id: 狗对象} 的字典，正常的写法如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Map&lt;Integer, DogDO&gt; <span class=\"title function_\">convertDogListToMap</span><span class=\"params\">(List&lt;DogDO&gt; dogDOList)</span> &#123;</span><br><span class=\"line\">    Map&lt;Integer, DogDO&gt; dogDOMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dogDOList == <span class=\"literal\">null</span> || dogDOList.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogDOMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (DogDO dogDO : dogDOList) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dogDO == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dogDOMap.containsKey(dogDO.getId())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dogDOMap.put(dogDO.getId(), dogDO);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dogDOMap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;1=DogDO&#123;name=&#x27;a&#x27;, age=1&#125;, 2=DogDO&#123;name=&#x27;b&#x27;, age=2&#125;, 3=DogDO&#123;name=&#x27;c&#x27;, age=3&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>使用 lambda 的写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Map&lt;Integer, DogDO&gt; <span class=\"title function_\">convertDogListToMap</span><span class=\"params\">(List&lt;DogDO&gt; dogDOList)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.ofNullable(dogDOList).orElse(Collections.emptyList()).stream().filter(Objects::nonNull).collect(Collectors.toMap(DogDO::getId, v -&gt; v, (p1, p2) -&gt; p1));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"列表转属性-属性的字典\">列表转属性-属性的字典</h4>\n<p>正常写法略，lambda写法如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Map&lt;Integer, String&gt; <span class=\"title function_\">convertDogListToMap</span><span class=\"params\">(List&lt;DogDO&gt; dogDOList)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.ofNullable(dogDOList).orElse(Collections.emptyList()).stream().filter(Objects::nonNull).collect(Collectors.toMap(DogDO::getId, DogDO::getName, (p1, p2) -&gt; p1));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;1=Shaun, 2=Spring, 3=Timmy&#125;</span></span><br></pre></td></tr></table></figure>\n<p>Set 转 Map 的过程同上</p>\n<h4 id=\"列表分组转字典\">列表分组转字典</h4>\n<h5 id=\"分成两组\">分成两组</h5>\n<p>现要按照是否大于18岁把狗子分成两组，正常的写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Map&lt;Boolean, List&lt;DogDO&gt;&gt; <span class=\"title function_\">groupByAge</span><span class=\"params\">(List&lt;DogDO&gt; dogDOList)</span> &#123;</span><br><span class=\"line\">        Map&lt;Boolean, List&lt;DogDO&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"literal\">true</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;());</span><br><span class=\"line\">        map.put(<span class=\"literal\">false</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dogDOList == <span class=\"literal\">null</span> || dogDOList.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (DogDO dogDO : dogDOList) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dogDO == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.get(dogDO.getAge() &gt; <span class=\"number\">18</span>).add(dogDO);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;false=[DogDO&#123;name=&#x27;Shaun&#x27;, age=18&#125;], true=[DogDO&#123;name=&#x27;Spring&#x27;, age=19&#125;, DogDO&#123;name=&#x27;Timmy&#x27;, age=20&#125;]&#125;</span></span><br></pre></td></tr></table></figure>\n<p>Lambda 写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Map&lt;Boolean, List&lt;DogDO&gt;&gt; <span class=\"title function_\">groupByAge1</span><span class=\"params\">(List&lt;DogDO&gt; dogDOList)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.ofNullable(dogDOList).orElse(Collections.emptyList()).stream().</span><br><span class=\"line\">            filter(Objects::nonNull).collect(Collectors.partitioningBy(p -&gt; p.getAge() &gt; <span class=\"number\">18</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"分成多组\">分成多组</h5>\n<p>现要将狗列表按照毛色分成若干组，正常写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Map&lt;String, List&lt;DogDO&gt;&gt; <span class=\"title function_\">groupByColor</span><span class=\"params\">(List&lt;DogDO&gt; dogDOList)</span> &#123;</span><br><span class=\"line\">        Map&lt;String, List&lt;DogDO&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dogDOList == <span class=\"literal\">null</span> || dogDOList.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (DogDO dogDO : dogDOList) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dogDO == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!map.containsKey(dogDO.getColor())) &#123;</span><br><span class=\"line\">                map.put(dogDO.getColor(), <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.get(dogDO.getColor()).add(dogDO);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// &#123;white=[DogDO&#123;name=&#x27;Shaun&#x27;, age=18&#125;, DogDO&#123;name=&#x27;Spring&#x27;, age=19&#125;], yellow=[DogDO&#123;name=&#x27;Timmy&#x27;, age=20&#125;]&#125;</span></span><br></pre></td></tr></table></figure>\n<p>Lambda 写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Map&lt;String, List&lt;DogDO&gt;&gt; <span class=\"title function_\">groupByColor1</span><span class=\"params\">(List&lt;DogDO&gt; dogDOList)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.ofNullable(dogDOList).orElse(Collections.emptyList()).stream().filter(Objects::nonNull).collect(Collectors.groupingBy(DogDO::getColor));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"聚合查询\">聚合查询</h3>\n<p>取集合中年龄最大的两只狗</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;DogDO&gt; top2Dogs = Optional.ofNullable(dogDOList).orElse(Collections.emptyList()).stream().filter(Objects::nonNull)</span><br><span class=\"line\">            .sorted(Comparator.comparingInt(DogDO::getAge)).limit(<span class=\"number\">2</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p>更多聚合查询见：<a href=\"https://baijiahao.baidu.com/s?id=1752563977677695105&amp;wfr=spider&amp;for=pc\">Java8之22个lambda表达式用法入门示例超简单，这还不会你就out了</a></p>\n<h2 id=\"参考\">参考</h2>\n<p><a href=\"https://blog.csdn.net/zjhred/article/details/84976734\">JAVA8之妙用Optional解决判断Null为空的问题</a></p>\n<p><a href=\"https://blog.csdn.net/qing_gee/article/details/104767082\">干货，一文彻底搞懂\nJava 的 Optional</a></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1752563977677695105&amp;wfr=spider&amp;for=pc\">Java8之22个lambda表达式用法入门示例超简单，这还不会你就out了</a></p>\n<p><a href=\"https://www.jb51.net/article/254353.htm\">Java 中的 Lambda\nList 转 Map 的多种方法详解</a></p>\n","tags":["java"]},{"title":"java 反射机制与代码走读","url":"/2023/03/25/java/java-reflect/","content":"<blockquote>\n<p>本文介绍 Java 的反射机制，源码走读</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"什么是反射\">什么是反射</h2>\n<blockquote>\n<p>先看正反的两个例子</p>\n</blockquote>\n<p>正向的例子：已知一个类，直接进行实例化，使用类对象进行操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Dog</span> <span class=\"variable\">dog</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\">dog.setFood(<span class=\"string\">&quot;meat&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>反射的例子：不知道是什么类，无法使用 new 关键字直接创建对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Class</span> <span class=\"variable\">clz</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;org.example.Dog&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> clz.getMethod(<span class=\"string\">&quot;setFood&quot;</span>, String.class);</span><br><span class=\"line\"><span class=\"type\">Constructor</span> <span class=\"variable\">constructor</span> <span class=\"operator\">=</span> clz.getConstructor();</span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> constructor.newInstance();</span><br><span class=\"line\">method.invoke(obj, <span class=\"string\">&quot;meat&quot;</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>你可能会有疑问，这两个例子不就是写法不同吗，都是已知这个类是什么；在反射的例子中，只不过是用反射的形式创建对象和调用方法。看上去是这样的，不过在实际使用中，是在程序运行过程中通过字符串变量值，才知道是什么类</p>\n</blockquote>\n<p>所以反射的概念可以理解为：<strong>运行时才知道要操作的类是什么，在运行时构造类的对象，调用其方法</strong></p>\n<h2 id=\"反射的步骤\">反射的步骤</h2>\n<p>一般情况下，可以归纳为下面几个步骤：</p>\n<ol type=\"1\">\n<li><p>获取类的 Class 对象实例</p>\n<p><code>Class clz = Class.forName(\"...\");</code></p></li>\n<li><p>根据 Class 对象实例获取 Constructor 对象</p>\n<p><code>Constructor constructor = clz.getConstructor();</code></p></li>\n<li><p>使用 Constructor 对象的 newInstance 方法获取</p>\n<p><code>Object obj = constructor.newInstance();</code></p></li>\n<li><p>获取对象实例方法</p>\n<p><code>Method method = clz.getMethod(\"eat\", String.class);</code></p></li>\n<li><p>调用对象实例方法</p>\n<p><code>method.invoke(obj, \"meat\");</code></p></li>\n</ol>\n<blockquote>\n<p>下面就这五个步骤，进行源码走读</p>\n</blockquote>\n<h2 id=\"源码走读\">源码走读</h2>\n<h3 id=\"class.forname\">Class.forName</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CallerSensitive</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Class&lt;?&gt; forName(String className)</span><br><span class=\"line\">                <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> forName0(className, <span class=\"literal\">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>根据类全路径获取类对象</p>\n<h3 id=\"clz.getmethod\">clz.getMethod</h3>\n<p>java.lang.Class#getMethod</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CallerSensitive</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Method <span class=\"title function_\">getMethod</span><span class=\"params\">(String name, Class&lt;?&gt;... parameterTypes)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> NoSuchMethodException, SecurityException &#123;</span><br><span class=\"line\">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> getMethod0(name, parameterTypes, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (method == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchMethodException</span>(getName() + <span class=\"string\">&quot;.&quot;</span> + name + argumentTypesToString(parameterTypes));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr class=\"header\">\n<th>方法</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>checkMemberAccess</td>\n<td>检查调用类是否有访问权限，默认是可以访问</td>\n</tr>\n<tr class=\"even\">\n<td>getMethod0</td>\n<td>根据方法名和参数列表查询目标方法</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Method <span class=\"title function_\">getMethod0</span><span class=\"params\">(String name, Class&lt;?&gt;[] parameterTypes, <span class=\"type\">boolean</span> includeStaticMethods)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">MethodArray</span> <span class=\"variable\">interfaceCandidates</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MethodArray</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span>  privateGetMethodRecursive(name, parameterTypes, includeStaticMethods, interfaceCandidates);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Not found on class or superclass directly</span></span><br><span class=\"line\">        interfaceCandidates.removeLessSpecifics();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> interfaceCandidates.getFirst(); <span class=\"comment\">// may be null</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>privateGetMethodRecursive：递归的根据方法名和参数类型寻找方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Method <span class=\"title function_\">privateGetMethodRecursive</span><span class=\"params\">(String name,</span></span><br><span class=\"line\"><span class=\"params\">            Class&lt;?&gt;[] parameterTypes,</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"type\">boolean</span> includeStaticMethods,</span></span><br><span class=\"line\"><span class=\"params\">            MethodArray allInterfaceCandidates)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Must _not_ return root methods</span></span><br><span class=\"line\">        Method res;</span><br><span class=\"line\">        <span class=\"comment\">// Search declared public methods</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((res = searchMethods(privateGetDeclaredMethods(<span class=\"literal\">true</span>),</span><br><span class=\"line\">                                 name,</span><br><span class=\"line\">                                 parameterTypes)) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (includeStaticMethods || !Modifier.isStatic(res.getModifiers()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Search superclass&#x27;s methods</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isInterface()) &#123;</span><br><span class=\"line\">            Class&lt;? <span class=\"built_in\">super</span> T&gt; c = getSuperclass();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((res = c.getMethod0(name, parameterTypes, <span class=\"literal\">true</span>)) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Search superinterfaces&#x27; methods</span></span><br><span class=\"line\">        Class&lt;?&gt;[] interfaces = getInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Class&lt;?&gt; c : interfaces)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((res = c.getMethod0(name, parameterTypes, <span class=\"literal\">false</span>)) != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                allInterfaceCandidates.add(res);</span><br><span class=\"line\">        <span class=\"comment\">// Not found</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>privateGetMethodRecursive 流程图如下</p>\n<figure>\n<img src=\"/images/java/反射流程图.drawio.svg\" alt=\"反射流程图.drawio\">\n<figcaption aria-hidden=\"true\">反射流程图.drawio</figcaption>\n</figure>\n<p>privateGetMethodRecursive 实现分析：</p>\n<table>\n<colgroup>\n<col style=\"width: 50%\">\n<col style=\"width: 50%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>方法</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>privateGetDeclaredMethods</td>\n<td>返回root方法数组</td>\n</tr>\n<tr class=\"even\">\n<td>searchMethods(Method[] methods, String name, Class&lt;?&gt;[]\nparameterTypes)</td>\n<td>在输入的方法列表中，查找方法名为name，参数为parameterTypes\n的方法</td>\n</tr>\n</tbody>\n</table>\n<p>privateGetDeclaredMethods：</p>\n<p>从缓存中获取方法，如果缓存中没有，从 VM 中获取</p>\n<p>类中的每个方法最初都是向 VM 请求获取的，从 VM 获取的这些 Method\n对象，称为类中方法对应的 Method Root（根方法对象），最终找到的方法，是\nMethod Root 拷贝的副本 Method 对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns an array of &quot;root&quot; methods. These Method objects must NOT</span></span><br><span class=\"line\">    <span class=\"comment\">// be propagated to the outside world, but must instead be copied</span></span><br><span class=\"line\">    <span class=\"comment\">// via ReflectionFactory.copyMethod.</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Method[] privateGetDeclaredMethods(<span class=\"type\">boolean</span> publicOnly) &#123;</span><br><span class=\"line\">        checkInitted();</span><br><span class=\"line\">        Method[] res;</span><br><span class=\"line\">        ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rd != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (res != <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// No cached value available; request value from VM</span></span><br><span class=\"line\">        res = Reflection.filterMethods(<span class=\"built_in\">this</span>, getDeclaredMethods0(publicOnly));</span><br><span class=\"line\">      \t<span class=\"comment\">// 写缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rd != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (publicOnly) &#123;</span><br><span class=\"line\">                rd.declaredPublicMethods = res;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                rd.declaredMethods = res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>涉及的方法分析：</p>\n<table>\n<colgroup>\n<col style=\"width: 31%\">\n<col style=\"width: 68%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>方法</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>checkInitted()</td>\n<td>读VM变量初始化参数（是否要读缓存 useCaches，是否完成初始化\ninitted）</td>\n</tr>\n<tr class=\"even\">\n<td>reflectionData()</td>\n<td>懒加载反射数据：如果缓存中存在反射数据，则返回；缓存中没有，创建一个空的反射数据，用于从VM加载后写缓存</td>\n</tr>\n<tr class=\"odd\">\n<td>getDeclaredMethods0(boolean)</td>\n<td>native方法，从VM中获取当前类的（公开/全部）方法</td>\n</tr>\n<tr class=\"even\">\n<td>Reflection.filterMethods()</td>\n<td>一些 unsafe 方法需要被过滤</td>\n</tr>\n</tbody>\n</table>\n<p>展开：reflectionData</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Lazily create and cache ReflectionData</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReflectionData&lt;T&gt; <span class=\"title function_\">reflectionData</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class=\"built_in\">this</span>.reflectionData;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">classRedefinedCount</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.classRedefinedCount;</span><br><span class=\"line\">        ReflectionData&lt;T&gt; rd;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (useCaches &amp;&amp;</span><br><span class=\"line\">            reflectionData != <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">            (rd = reflectionData.get()) != <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">            rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rd;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// else no SoftReference or cleared SoftReference or stale ReflectionData</span></span><br><span class=\"line\">        <span class=\"comment\">// -&gt; create and replace new instance</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> newReflectionData(reflectionData, classRedefinedCount);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>有了 privateGetDeclaredMethods 获取的公开方法，放到 searchMethods\n中，进行方法名和参数比较，如果最后发现 res\n为空，说明没有找到目标方法，如果 res 不为空，要拷贝 Root 方法，返回 root\n方法的副本</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method <span class=\"title function_\">searchMethods</span><span class=\"params\">(Method[] methods,</span></span><br><span class=\"line\"><span class=\"params\">                                        String name,</span></span><br><span class=\"line\"><span class=\"params\">                                        Class&lt;?&gt;[] parameterTypes)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">internedName</span> <span class=\"operator\">=</span> name.intern();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Method</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> methods[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.getName() == internedName</span><br><span class=\"line\">                &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())</span><br><span class=\"line\">                &amp;&amp; (res == <span class=\"literal\">null</span></span><br><span class=\"line\">                    || res.getReturnType().isAssignableFrom(m.getReturnType())))</span><br><span class=\"line\">                res = m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (res == <span class=\"literal\">null</span> ? res : getReflectionFactory().copyMethod(res));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>展开：getReflectionFactory().copyMethod(res) —— 根方法的拷贝</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Method <span class=\"title function_\">copyMethod</span><span class=\"params\">(Method arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg.copy();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>跟进去会调用：java.lang.reflect.Method#copy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Method <span class=\"title function_\">copy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// This routine enables sharing of MethodAccessor objects</span></span><br><span class=\"line\">        <span class=\"comment\">// among Method objects which refer to the same underlying</span></span><br><span class=\"line\">        <span class=\"comment\">// method in the VM. (All of this contortion is only necessary</span></span><br><span class=\"line\">        <span class=\"comment\">// because of the &quot;accessibility&quot; bit in AccessibleObject,</span></span><br><span class=\"line\">        <span class=\"comment\">// which implicitly requires that new java.lang.reflect</span></span><br><span class=\"line\">        <span class=\"comment\">// objects be fabricated for each reflective call on Class</span></span><br><span class=\"line\">        <span class=\"comment\">// objects.)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.root != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Can not copy a non-root Method&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Method</span>(clazz, name, parameterTypes, returnType,</span><br><span class=\"line\">                                exceptionTypes, modifiers, slot, signature,</span><br><span class=\"line\">                                annotations, parameterAnnotations, annotationDefault);</span><br><span class=\"line\">        res.root = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Might as well eagerly propagate this if already present</span></span><br><span class=\"line\">        res.methodAccessor = methodAccessor;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这里可以看到，拷贝的一定是根方法对象，然后用根方法对象（this）的所有参数创建了一个新的方法对象\nres，res 的 root 指向了根方法对象（this），并设置 methodAccessor</p>\n<blockquote>\n<p>问题：</p>\n<ol type=\"1\">\n<li>为什么要有 Method Root？</li>\n<li>Method Root为什么不能传播到外部，必须经过复制</li>\n<li>为什么 copy 的方法和根方法要用相同的 methodAccessor？</li>\n<li>methodAccessor 是做什么的？</li>\n</ol>\n</blockquote>\n<h3 id=\"method.invoke\">method.invoke</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object obj, Object... args)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class=\"line\">           InvocationTargetException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!override) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class=\"line\">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">MethodAccessor</span> <span class=\"variable\">ma</span> <span class=\"operator\">=</span> methodAccessor;             <span class=\"comment\">// read volatile</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ma == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        ma = acquireMethodAccessor();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ma.invoke(obj, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把 method.invoke 分为两个部分：Part1. acquireMethodAccessor 和 Part2.\nma.invoke</p>\n<h4 id=\"part1.-acquiremethodaccessor\">Part1. acquireMethodAccessor</h4>\n<p>检查方法对象的 methodAccessor（下面简称 ma）\n是否为空，如果为空，创建一个 ma</p>\n<figure>\n<img src=\"/images/java/image-20230323233830053.png\" alt=\"image-20230323233830053\">\n<figcaption aria-hidden=\"true\">image-20230323233830053</figcaption>\n</figure>\n<p>追踪 acquireMethodAccessor：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NOTE that there is no synchronization used here. It is correct</span></span><br><span class=\"line\"><span class=\"comment\">// (though not efficient) to generate more than one MethodAccessor</span></span><br><span class=\"line\"><span class=\"comment\">// for a given Method. However, avoiding synchronization will</span></span><br><span class=\"line\"><span class=\"comment\">// probably make the implementation more scalable.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> MethodAccessor <span class=\"title function_\">acquireMethodAccessor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// First check to see if one has been created yet, and take it</span></span><br><span class=\"line\">    <span class=\"comment\">// if so</span></span><br><span class=\"line\">    <span class=\"type\">MethodAccessor</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root != <span class=\"literal\">null</span>) tmp = root.getMethodAccessor();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        methodAccessor = tmp;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class=\"line\">        tmp = reflectionFactory.newMethodAccessor(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        setMethodAccessor(tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解读：先找父方法的 ma，如果父方法没有 ma，为父方法和自己创建\nma，返回这个 ma</p>\n<p>追踪：reflectionFactory.newMethodAccessor(this)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> MethodAccessor <span class=\"title function_\">newMethodAccessor</span><span class=\"params\">(Method var1)</span> &#123;</span><br><span class=\"line\">    checkInitted();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">MethodAccessorGenerator</span>()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NativeMethodAccessorImpl</span> <span class=\"variable\">var2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NativeMethodAccessorImpl</span>(var1);</span><br><span class=\"line\">        <span class=\"type\">DelegatingMethodAccessorImpl</span> <span class=\"variable\">var3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DelegatingMethodAccessorImpl</span>(var2);</span><br><span class=\"line\">        var2.setParent(var3);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> var3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解读：var1 为子方法，首先在 checkInitted()\n中进行初始化：ReflectionFactory.noInflation 和\nReflectionFactory.inflationThreshold 两个参数，其中 noInflation 默认为\nfalse 表示有膨胀机制，膨胀机制在后面会提到</p>\n<p>checkInitted 后，默认 noInflation 是\nfalse，则走到第二个分支，这里创建了两个对象：NativeMethodAccessorImpl 和\nDelegatingMethodAccessorImpl类型，这两个类型都是 MethodAccessor\n的实现类，var3 是 var2 的 parent，最后返回 var3。类之间关系如下：</p>\n<figure>\n<img src=\"/images/java/methodAccessor.drawio.png\" alt=\"methodAccessor.drawio\">\n<figcaption aria-hidden=\"true\">methodAccessor.drawio</figcaption>\n</figure>\n<p>var1, var2, var3 的引用关系如下：</p>\n<figure>\n<img src=\"/images/java/var123.drawio.png\" alt=\"var123.drawio\">\n<figcaption aria-hidden=\"true\">var123.drawio</figcaption>\n</figure>\n<p>追踪 setMethodAccessor\n（java.lang.reflect.Method#setMethodAccessor）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sets the MethodAccessor for this Method object and</span></span><br><span class=\"line\"><span class=\"comment\">// (recursively) its root</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">setMethodAccessor</span><span class=\"params\">(MethodAccessor accessor)</span> &#123;</span><br><span class=\"line\">    methodAccessor = accessor;</span><br><span class=\"line\">    <span class=\"comment\">// Propagate up</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        root.setMethodAccessor(accessor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 reflectionFactory.newMethodAccessor(this) 创建了新的 ma\n后，将这个 ma 递归的向上赋值给父方法，使得该方法类以及向上所有的方法类的\nma 都是一个（为什么要这样做呢？）</p>\n<h4 id=\"part2.-ma.invoke\">Part2. ma.invoke</h4>\n<figure>\n<img src=\"/images/java/image-20230323233748550.png\" alt=\"image-20230323233748550\">\n<figcaption aria-hidden=\"true\">image-20230323233748550</figcaption>\n</figure>\n<p>通过 Part1. acquireMethodAccessor 获取 ma 对象后，调用 ma 的 invoke\n方法，obj 是要反射的实例，args 是方法参数；我们知道 ma 是一个\nDelegatingMethodAccessorImlp 类型，追踪调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object var1, Object[] var2)</span> <span class=\"keyword\">throws</span> IllegalArgumentException, InvocationTargetException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.delegate.invoke(var1, var2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>this.delegate 是 NativeMethodAccessorImpl 类型，追踪调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object var1, Object[] var2)</span> <span class=\"keyword\">throws</span> IllegalArgumentException, InvocationTargetException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++<span class=\"built_in\">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class=\"built_in\">this</span>.method.getDeclaringClass())) &#123;</span><br><span class=\"line\">            <span class=\"type\">MethodAccessorImpl</span> <span class=\"variable\">var3</span> <span class=\"operator\">=</span> (MethodAccessorImpl)(<span class=\"keyword\">new</span> <span class=\"title class_\">MethodAccessorGenerator</span>()).generateMethod(<span class=\"built_in\">this</span>.method.getDeclaringClass(), <span class=\"built_in\">this</span>.method.getName(), <span class=\"built_in\">this</span>.method.getParameterTypes(), <span class=\"built_in\">this</span>.method.getReturnType(), <span class=\"built_in\">this</span>.method.getExceptionTypes(), <span class=\"built_in\">this</span>.method.getModifiers());</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.parent.setDelegate(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke0(<span class=\"built_in\">this</span>.method, var1, var2);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>解读：如果调用次数大于阈值，生成另一个 ma 对象，并将原来\nDelegatingMethodAccessorImpl 对象中的 delegate 属性指向最新的 ma\n对象；本次依旧会用 NativeMethodAccessorImpl 的 invoke0\n方法，不过下次调用会就不会再调用 NativeMethodAccessorImpl 的invoke()\n方法了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> Object <span class=\"title function_\">invoke0</span><span class=\"params\">(Method var0, Object var1, Object[] var2)</span>;</span><br></pre></td></tr></table></figure>\n<p>下面是执行 invoke 的时序图：</p>\n<figure>\n<img src=\"/images/java/invoke.drawio.png\" alt=\"invoke.drawio\">\n<figcaption aria-hidden=\"true\">invoke.drawio</figcaption>\n</figure>\n<p>当调用次数大于阈值（默认15），会将 DelegatingMethodAccessorImpl 的\ndelegate 属性更改为一个 GeneratedMethodAccessor，不去用\nNativeMethodAccessorImpl 的 invoke0 方法；这个\nGeneratedMethodAccessor.invoke\n的具体实现，我没有找到，GeneratedMethodAccessor 的类文件也没有找到，这个\nGeneratedMethodAccessor 是怎么来的，还要再讨论分析</p>\n<figure>\n<img src=\"/images/java/image-20230324153440404.png\" alt=\"image-20230324153440404\">\n<figcaption aria-hidden=\"true\">image-20230324153440404</figcaption>\n</figure>\n<p>根据注释所述：如注释所述，实际的MethodAccessor实现有两个版本，一个是Java实现的（GeneratedMethodAccessor.invoke），另一个是native\ncode（NativeMethodAccessorImpl.invoke0）实现的。Java\n实现的版本在初始化时需要较多时间，但长久来说性能较好；native\n版本正好相反，启动时相对较快，但运行时间长了之后速度就比不过 Java\n版了，为了权衡这两个版本的性能，引入了膨胀机制</p>\n<p>所谓膨胀机制是指：一开始先使用 native 的 ma 对象，等 native ma\n的调用次数达到了 ReflectionFactory.inflationThreshold\n设定的阈值后，动态生成 java 版本的 ma 对象来调用</p>\n<h4 id=\"实验分析-invoke-膨胀机制\">实验分析 invoke 膨胀机制</h4>\n<p>下面进行实验验证膨胀机制</p>\n<h5 id=\"实验设计\">实验设计</h5>\n<blockquote>\n<p>实验目的：比较 GeneratedMethodAccessor.invoke 和\nNativeMethodAccessorImpl.invoke0 两种 Invoke\n方法的执行时间和内存使用情况</p>\n<p>通过 -Dsun.reflect.inflationThreshold=0 或\n很大整数（保证实验中不会走到优化的分支）控制使用哪种方法：sun.reflect.inflationThreshold=0\n使用\nGeneratedMethodAccessor.invoke，sun.reflect.inflationThreshold=很大整数时使用\nNativeMethodAccessorImpl.invoke0</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReflectTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">RUN_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  \t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TURN_NUM</span> <span class=\"operator\">=</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> System.getProperty(<span class=\"string\">&quot;sun.reflect.inflationThreshold&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sun.reflect.inflationThreshold: &quot;</span> + s);</span><br><span class=\"line\">        Class&lt;?&gt; clz = Class.forName(<span class=\"string\">&quot;org.example.reflect.Dog&quot;</span>);</span><br><span class=\"line\">        Constructor&lt;?&gt; constructor = clz.getConstructor();</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> constructor.newInstance();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> clz.getMethod(<span class=\"string\">&quot;eat&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; TURN_NUM; i++) &#123;</span><br><span class=\"line\">            costTime(obj, method);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">costTime</span><span class=\"params\">(Object obj, Method method)</span> <span class=\"keyword\">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; RUN_TIME; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> method.invoke(obj, <span class=\"string\">&quot;meat&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;cost Time: &quot;</span> + (end - start) + <span class=\"string\">&quot; ns&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"耗时比较\">耗时比较</h5>\n<p>下面是第n次执行和耗时（单位：ns）的表格，比较发现：第一次运行，GeneratedMethodAccessor.invoke\n耗时是 Native Invoke\n的20倍，从第2次开始，两者耗时均下降明显，从18-25次，GeneratedMethodAccessor.invoke\n耗时均低于 Native Invoke</p>\n<figure>\n<img src=\"/images/java/image-20230325114624920.png\" alt=\"image-20230325114624920\">\n<figcaption aria-hidden=\"true\">image-20230325114624920</figcaption>\n</figure>\n<p>运行300次-350次的耗时比较，GeneratedMethodAccessor.invoke\n平均耗时在625ns，Native invoke 平均耗时在 910 ns</p>\n<figure>\n<img src=\"/images/java/image-20230325121200359.png\" alt=\"image-20230325121200359\">\n<figcaption aria-hidden=\"true\">image-20230325121200359</figcaption>\n</figure>\n<p>运行960次-1000次的耗时比较，GeneratedMethodAccessor.invoke\n平均耗时在125ns，Native invoke 平均耗时在 375 ns</p>\n<figure>\n<img src=\"/images/java/image-20230325115818285.png\" alt=\"image-20230325115818285\">\n<figcaption aria-hidden=\"true\">image-20230325115818285</figcaption>\n</figure>\n<h5 id=\"内存比较\">内存比较</h5>\n<blockquote>\n<p>使用 visualvm 工具查看-Dsun.reflect.inflationThreshold=0 或\n100000两种情况下的堆空间使用率</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReflectTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TURN_NUM</span> <span class=\"operator\">=</span> <span class=\"number\">10000000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, InterruptedException &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">15000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; TURN_NUM; i++) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; clz = Class.forName(<span class=\"string\">&quot;org.example.reflect.Dog&quot;</span>);</span><br><span class=\"line\">            Constructor&lt;?&gt; constructor = clz.getConstructor();</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> constructor.newInstance();</span><br><span class=\"line\">            <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> clz.getMethod(<span class=\"string\">&quot;eat&quot;</span>, String.class);</span><br><span class=\"line\">            method.invoke(obj, <span class=\"string\">&quot;meat&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">15000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下图为使用 GeneratedMethodAccessor.invoke 的堆空间使用情况，invoke\n执行过程中最大的 Used heap = 189.93M</p>\n<figure>\n<img src=\"/images/java/image-20230325133027796.png\" alt=\"image-20230325133027796\">\n<figcaption aria-hidden=\"true\">image-20230325133027796</figcaption>\n</figure>\n<p>下图为使用 Native Invoke 的堆空间使用情况，invoke 执行过程中最大 Used\nheap = 90.05M</p>\n<figure>\n<img src=\"/images/java/image-20230325133056066.png\" alt=\"image-20230325133056066\">\n<figcaption aria-hidden=\"true\">image-20230325133056066</figcaption>\n</figure>\n<p>可以发现 GeneratedMethodAccessor.invoke 比 native invoke\n占用更多的堆空间</p>\n<h2 id=\"问题\">问题</h2>\n<blockquote>\n<p>下面来看下走读过程中遇到的几个问题：</p>\n</blockquote>\n<p>问题：</p>\n<ol type=\"1\">\n<li><p>methodAccessor 是做什么的？</p>\n<p>答：用于 invoke 调用指定方法的</p></li>\n<li><p>为什么要有 Method Root？</p>\n<p>答：为了让同一个方法拷贝出来的多个 Method 对象，共享 method Accessor\n对象；当第一次调用 method.invoke 时，没有 method Accessor 对象，则取\nroot 的 Method Accessor，如果 root 的 method Accessor 为空，则新创建一个\nmethod Accessor，并给 root 赋值。又因为一个 Method 对象，一定是从 Method\nRoot 拷贝来的，在拷贝过程中，会赋 root.methodAccessor\n值（见java.lang.reflect.Method#copy），从而达到了共享 method Accessor\n的效果</p></li>\n<li><p>Method Root为什么不能传播到外部，必须经过复制，为什么 Method\n对象本身不能共享</p>\n<p>答：为了保持方法原有的样子，因为用户可以对拷贝出去的 Method\n对象setAccessible，如果修改了根方法的\naccessible，后面拷贝的方法都被修改了 setAccessible；同理，Method\n对象本身也不能共享一个，因为可能只修改某个Method的属性（个人理解）</p></li>\n<li><p>为什么 copy 的方法和根方法要用相同的 methodAccessor？</p>\n<p>答：首先 methodAccessor\n是用来执行指定方法的，从根方法拷贝出的多个副本，共享一个\nmethodAccessor，节省内存空间</p></li>\n</ol>\n<blockquote>\n<p>个人感受：第一遍看的时候，先看到 Method Root，拷贝Method Root，后看到\nmethodAccessor，这样无法理解为什么要这么做；第二编看的时候，大概理解了\nmethodAccessor 的作用后，再看 Method\nRoot，又有了新的认识，所以先理解MethodAccessor，对整个流程的理解比较重要</p>\n</blockquote>\n<h2 id=\"总结\">总结</h2>\n<p>本文介绍了什么是反射，进行了反射源码走读，主要是 clz.getMethod 和\nmethod.invoke\n两个函数的代码，以及其调用追踪，过了下整个反射过程，发现了两个重要的概念：Method\nRoot、Method\nAccessor，通过代码分析它们的作用，以及膨胀机制，通过实验对膨胀机制在运行时间和内存上进行比较；最后对阅读过程中发现的几个问题进行讨论</p>\n<h2 id=\"参考\">参考</h2>\n<p><a href=\"https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html#%E5%8F%8D%E5%B0%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\">大白话说Java反射：入门、使用、原理</a></p>\n<p><a href=\"https://www.jianshu.com/p/80bf493bbe4e\">java反射源码分析，思路超清晰</a></p>\n<p><a href=\"https://www.cnblogs.com/onlywujun/p/3519037.html\">JAVA深入研究——Method的Invoke方法</a></p>\n","tags":["java"]},{"title":"ThreadLocal 的功能、用法和注意事项","url":"/2022/11/06/java/threadlocal/","content":"<blockquote>\n<p>面试分享~No.3</p>\n</blockquote>\n<h3 id=\"要解决的问题\">要解决的问题</h3>\n<p>在多线程的场景下，使用共享变量，线程无法隔离单独的使用这个变量</p>\n<p>threadlocal可以让每个线程独享一份共享变量，实现共享变量的隔离</p>\n<span id=\"more\"></span>\n<h3 id=\"例子\">例子</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadLocalTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;String&gt; threadLocal1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;String&gt; threadLocal2 = <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            threadLocal1.set(<span class=\"string\">&quot;local1 A&quot;</span>);</span><br><span class=\"line\">            threadLocal2.set(<span class=\"string\">&quot;local2 A&quot;</span>);</span><br><span class=\"line\">            System.out.println(threadLocal1.get());</span><br><span class=\"line\">            System.out.println(threadLocal2.get());</span><br><span class=\"line\">            threadLocal1.remove();</span><br><span class=\"line\">            threadLocal2.remove();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            threadLocal1.set(<span class=\"string\">&quot;local1 B&quot;</span>);</span><br><span class=\"line\">            threadLocal2.set(<span class=\"string\">&quot;local2 B&quot;</span>);</span><br><span class=\"line\">            System.out.println(threadLocal1.get());</span><br><span class=\"line\">            System.out.println(threadLocal2.get());</span><br><span class=\"line\">            threadLocal1.remove();</span><br><span class=\"line\">            threadLocal2.remove();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"源码分析\">源码分析</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">set</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">    <span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"built_in\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> &#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocalMap</span>(<span class=\"built_in\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>[INITIAL_CAPACITY];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class=\"number\">1</span>);</span><br><span class=\"line\">    table[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>(firstKey, firstValue);</span><br><span class=\"line\">    size = <span class=\"number\">1</span>;</span><br><span class=\"line\">    setThreshold(INITIAL_CAPACITY);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">    <span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.<span class=\"type\">Entry</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> map.getEntry(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">            <span class=\"type\">T</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadLocalMap <span class=\"title function_\">getMap</span><span class=\"params\">(Thread t)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> T <span class=\"title function_\">setInitialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">T</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> initialValue();</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">    <span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"built_in\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">remove</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> getMap(Thread.currentThread());</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (m != <span class=\"literal\">null</span>)</span><br><span class=\"line\">         m.remove(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ThreadLocalMap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadLocalMap</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">        Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(k);</span><br><span class=\"line\">            value = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为什么Entry使用弱引用类型？</p>\n</blockquote>\n<h3 id=\"thread-与-threadlocalthreadlocalmap的关系\">Thread 与\nThreadLocal、ThreadLocalMap的关系</h3>\n<p>JDK8之前的设计</p>\n<figure>\n<img src=\"/images/java/image-20221105202929562.png\" alt=\"image-20221105202929562\">\n<figcaption aria-hidden=\"true\">image-20221105202929562</figcaption>\n</figure>\n<p>JDK8的设计</p>\n<figure>\n<img src=\"/images/java/image-20221105203046168.png\" alt=\"image-20221105203046168\">\n<figcaption aria-hidden=\"true\">image-20221105203046168</figcaption>\n</figure>\n<p>JDK8的设计说明：</p>\n<ol type=\"1\">\n<li>每个Thread对象中有一个ThreadLocalMap属性</li>\n<li>ThreadLocalMap是一个字典，key是ThreadLocal类型，value是要保存的变量</li>\n<li>Thread中没有提供操作ThreadLocalMap的方法，而是通过ThreadLocal操作的</li>\n</ol>\n<p>问题：</p>\n<ol type=\"1\">\n<li><p>JDK8之前的设计存在什么问题</p>\n<p>答：个人理解，Threadlocal 是为了将 Thread 和 value 进行关联，那么\nvalue 的生命周期应该与 Thread 保持一致，当 Thread 销毁了，value\n当然就不需要了。在JDK8之前，thread 是 map 的 key，当 thread\n销毁时，value 依旧是存在的，在 JDK8 之后，value 在 thread 内的\nthreadLocalMap 中，当 thread 销毁后，value 会自动销毁。另外，JDK8\n之前如果 threadlocal 对象销毁，则其下的所有 thread 和 value\n的关系都不在存在了，但是 thread\n对象可能依旧是存在的，这也是不合适的</p></li>\n<li><p>ThreadLocalMap做为Thread的属性，为什么不通过Thread对象来操作</p>\n<p>答：threadLocalMap 的 key 必须是 threadLocal 对象，如果允许通过\nthread 的方法操作，可能传入其他对象作为 key，破坏了设计思想</p></li>\n</ol>\n<h3 id=\"应用场景\">应用场景</h3>\n<ul>\n<li>存储全局信息，如用户Session</li>\n<li>处理数据库事务</li>\n<li>代替参数显式传递</li>\n</ul>\n<h3 id=\"threadlocal中内存泄漏的问题\">ThreadLocal中内存泄漏的问题</h3>\n<p>内存泄露：指程序中动态分配的堆内存由于某种原因没有被释放或者无法释放，造成系统内存的浪费</p>\n<p>弱引用：执行垃圾回收时，不管符不符合回收条件，都会回收</p>\n<h4 id=\"实验\">实验</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadLocalTest</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LocalVariable</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造5M大小的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">byte</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">5</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">ThreadPoolExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">6</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, TimeUnit.MINUTES, <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> ThreadLocal&lt;LocalVariable&gt; tl = <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        executor.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">LocalVariable</span> <span class=\"variable\">localVariable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LocalVariable</span>();</span><br><span class=\"line\">            ThreadLocalTest.tl.set(localVariable);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;thread name end: &quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;, value: &quot;</span> +</span><br><span class=\"line\">                    ThreadLocalTest.tl.get());</span><br><span class=\"line\"><span class=\"comment\">//                ThreadLocalTest.tl.remove();</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span> * <span class=\"number\">3600</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行GC，存在30M内存泄漏</p>\n<figure>\n<img src=\"/images/java/image-20221106020255849.png\" alt=\"image-20221106020255849\">\n<figcaption aria-hidden=\"true\">image-20221106020255849</figcaption>\n</figure>\n<p>将threadlocal remove掉，GC后没有内存泄漏</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ThreadLocalTest.tl.remove();</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"/images/java/image-20221106021947237.png\" alt=\"image-20221106021947237\">\n<figcaption aria-hidden=\"true\">image-20221106021947237</figcaption>\n</figure>\n<h4 id=\"引用关系分析\">引用关系分析</h4>\n<figure>\n<img src=\"/images/java/image-20221106135245970.png\" alt=\"image-20221106135245970\">\n<figcaption aria-hidden=\"true\">image-20221106135245970</figcaption>\n</figure>\n<h4 id=\"threadlocal-会产生内存泄漏吗\">Threadlocal\n会产生内存泄漏吗？</h4>\n<p><strong>前提：启动一个线程执行很多个计算任务，线程一直工作不会被销毁</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">    Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>threadlocal的引用有：</p>\n<ol type=\"1\">\n<li>创建threadlocal对象的强引用 tl</li>\n<li>threadLocalMap中的弱引用key</li>\n</ol>\n<p>object 的引用：</p>\n<ol type=\"1\">\n<li>threadlocalMap中的强引用value</li>\n</ol>\n<p>当tl=null时，threadlocal可以被回收；当value=null时，object可以被回收</p>\n<p><strong>讨论</strong></p>\n<p>假设我们线程池中有100个线程，和一个 threadLocal\n对象，我们用这100个线程执行100个数据任务对象（10M），并将数据任务通过\nthreadLocal set 到线程内的 threadLocalMap 中，这样每个线程中，都有一个\nmap，map\n中有一个长度为16的数组，数组中有一个元素，即数据任务。执行完所有数据任务后，假设这100个线程都是核心线程，线程池会保持线程，这时，数据任务是有强引用指向的，即\nEntry 的 value，不会被回收</p>\n<p>有说法称 threadlocal\n可能导致内存泄露，这个说法是不对的，顶多可以说是<strong>业务上的\"内存泄漏\"</strong>，因为在业务层面我们是不需要这份数据的，但这份数据不符合GC的条件，不会被回收，所以需要我们手动清理</p>\n<p>这种内存泄露会随着线程数量增大而增大，与线程执行次数无关</p>\n<h4 id=\"entry-的-key-为什么用弱引用\">Entry 的 key 为什么用弱引用</h4>\n<p>threadlocal 对象有两个引用，一个是强引用 tl，Entry 中用弱引用指向了\nthreadlocal，如果代码中令tl=null，则 threadlocal 对象可以在 GC\n时被回收</p>\n<h3 id=\"总结\">总结</h3>\n<p>本文介绍了threadlocal的使用场景，用法，注意事项：<strong>threadlocal使用后记得remove</strong></p>\n<h3 id=\"参考\">参考</h3>\n<p><a href=\"https://blog.csdn.net/weixin_44184990/article/details/122279854\">ThreadLocal原理及使用场景</a></p>\n<p><a href=\"https://blog.csdn.net/muyimo/article/details/121358094\">ThreadLocal内存泄漏分析</a></p>\n","categories":["java"],"tags":["java"]},{"title":"kubernates 架构","url":"/2022/04/04/k8s/architecture/","content":"<blockquote>\n<p>kubernates cluster由master和node组成，节点上运行若干k8s服务</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"master节点\">Master节点</h2>\n<table>\n<colgroup>\n<col style=\"width: 27%\">\n<col style=\"width: 72%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>服务</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>kube-apiserver</td>\n<td>提供HTTP Restful\nAPI，供客户端及其他组件调用管理cluster的各种资源</td>\n</tr>\n<tr class=\"even\">\n<td>kube-scheduler</td>\n<td>决定将Pod调度到哪个Node上运行</td>\n</tr>\n<tr class=\"odd\">\n<td>kube-controller-manager</td>\n<td>管理cluster各种资源</td>\n</tr>\n<tr class=\"even\">\n<td>etcd</td>\n<td>保持cluster的配置信息和各种资源状态，并在数据变化时，通知相关组件</td>\n</tr>\n<tr class=\"odd\">\n<td>pod网络</td>\n<td>使Pod之间相互通信，如flannel</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"node节点\">Node节点</h2>\n<table>\n<colgroup>\n<col style=\"width: 14%\">\n<col style=\"width: 85%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>服务</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>kubelet</td>\n<td>Node的agent，接收Scheduler发送过来的Pod配置信息，并根据配置信息创建和运行容器，并向Master报告运行状态</td>\n</tr>\n<tr class=\"even\">\n<td>kube-proxy</td>\n<td>将访问service的请求转发到容器，负载均衡</td>\n</tr>\n<tr class=\"odd\">\n<td>pod网络</td>\n<td>使Pod之间相互通信，如flannel</td>\n</tr>\n</tbody>\n</table>\n<figure>\n<img src=\"/images/k8s/70.png\" alt=\"img\">\n<figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n","categories":["k8s"],"tags":["k8s"]},{"title":"k8s概念","url":"/2022/04/04/k8s/conception/","content":"<h2 id=\"cluster\">cluster</h2>\n<p>集群</p>\n<span id=\"more\"></span>\n<h2 id=\"master\">master</h2>\n<p>cluster的大脑，负责调度</p>\n<h2 id=\"node\">node</h2>\n<p>运行容器的机器（物理机或虚机）</p>\n<h2 id=\"pod\">Pod</h2>\n<p>最小工作单位，每个pod中包含一个或多个容器（有关联的容器的集合），\n目的：</p>\n<ol type=\"1\">\n<li>方便管理一组容器</li>\n<li>方便通信和资源共享</li>\n</ol>\n<h2 id=\"controller\">controller</h2>\n<p>管理Pod</p>\n<h3 id=\"deployment\">Deployment</h3>\n<p>最常见的controller，负责部署应用，使用replicaSet管理pod多个副本</p>\n<h3 id=\"replicaset\">ReplicaSet</h3>\n<p>pod的多副本管理</p>\n<h3 id=\"daemonset\">DaemonSet</h3>\n<p>每个node最多只运行一个pod副本</p>\n<h3 id=\"statefulset\">StatefulSet</h3>\n<p>保证Pod的每个副本在整个生命周期中名称是不变的</p>\n<h3 id=\"job\">Job</h3>\n<p>运行结束就删除的应用</p>\n<h3 id=\"service\">Service</h3>\n<p>定义外界访问一组Pod的方式，Service有IP和Port，为Pod提供负载均衡</p>\n<h3 id=\"namespace\">Namespace</h3>\n<p>将cluster逻辑上分为多个虚拟cluster，不同namespace资源隔离</p>\n","categories":["k8s"],"tags":["k8s"]},{"title":"JVM篇 垃圾收集","url":"/2022/12/31/jvm/jvm-gc/","content":"<blockquote>\n<p>本文介绍 JVM 中的垃圾收集器</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"什么是垃圾\">什么是垃圾</h2>\n<p>没有引用指向的一个对象或者多个对象（循环引用）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例子：循环引用的垃圾</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">  Node next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">Node</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>();</span><br><span class=\"line\"><span class=\"type\">Node</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>();</span><br><span class=\"line\">a.next = b;</span><br><span class=\"line\">b.next = a;</span><br><span class=\"line\">a = <span class=\"literal\">null</span>;</span><br><span class=\"line\">b = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// 此时出现两个互相引用的垃圾对象</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"判断垃圾的方法\">判断垃圾的方法</h3>\n<ol type=\"1\">\n<li>引用计数：统计每个对象的引用个数，引用计数为0，标记为垃圾，存在循环引用的问题</li>\n<li>根可达算法：从GC\nRoots的对象开始遍历，可以达到的对象标记为存活，不可到达的对象标记为垃圾</li>\n</ol>\n<blockquote>\n<p>根对象有哪些？</p>\n<ol type=\"1\">\n<li>虚拟机栈中的引用（栈桢中的本地变量表）指向的对象</li>\n<li>方法区中静态引用指向的对象</li>\n<li>方法区中常量池中引用指向的对象</li>\n<li>本地方法栈 JNI 引用的对象</li>\n</ol>\n<p>还有一些不太理解的，没有一一列举</p>\n</blockquote>\n<figure>\n<img src=\"/images/jvm/image-20221228141331393.png\" alt=\"image-20221228141331393\">\n<figcaption aria-hidden=\"true\">image-20221228141331393</figcaption>\n</figure>\n<h2 id=\"gc常用垃圾清除算法\">GC常用垃圾清除算法</h2>\n<h3 id=\"标记清除\">标记清除</h3>\n<p>mark sweep</p>\n<p>容易产生碎片，效率偏低（扫描两遍，标记一遍，清除一遍）</p>\n<blockquote>\n<p>Q：为什么需要扫描两遍，为什么不能一边标记，一边清除？</p>\n<p>A：因为标记的是存活对象，从根对象开始找，找到不可回收的，然后再遍历一遍，发现没有被标记的再清理；如果标记的是垃圾，则一遍就可以了，不过引用计数是存在循环引用的问题的，所以不能这么做</p>\n</blockquote>\n<h3 id=\"拷贝\">拷贝</h3>\n<p>copying</p>\n<p>没有碎片，浪费空间，效率较高（扫描一遍）</p>\n<blockquote>\n<p>从 GC Root\n找到有用的对象，然后拷贝到另一边，从而引用的值也随之改变</p>\n</blockquote>\n<h3 id=\"标记压缩\">标记压缩</h3>\n<p>mark compact</p>\n<p>没有碎片，效率偏低（扫描两遍，移动内存，调整指针）</p>\n<blockquote>\n<p>从 GC Root 找到有用的对象，然后将有用的对象压缩到一起</p>\n</blockquote>\n<h2 id=\"逻辑分代模型\">逻辑分代模型</h2>\n<blockquote>\n<p>注：仅用于逻辑分代的垃圾回收器</p>\n<p>除 Epsilon ZGC Shenandoah 之外的GC都是使用逻辑分代模型</p>\n<p>G1是逻辑分代，物理不分代，除此之外不仅逻辑分代，而且物理分代</p>\n</blockquote>\n<p>新生代 + 老年代 + 永久代 Perm Generation（1.7）/元数据区\nMetaspace（1.8）</p>\n<figure>\n<img src=\"/images/jvm/image-20221228141433966.png\" alt=\"image-20221228141433966\">\n<figcaption aria-hidden=\"true\">image-20221228141433966</figcaption>\n</figure>\n<table>\n<colgroup>\n<col style=\"width: 8%\">\n<col style=\"width: 36%\">\n<col style=\"width: 7%\">\n<col style=\"width: 35%\">\n<col style=\"width: 12%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>分代区域</th>\n<th>大小</th>\n<th>GC算法</th>\n<th>存放的对象</th>\n<th>GC</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>新生代</td>\n<td>方法1: 通过 -Xmn256m 设置，同 -XX:NewSize=256m\n-XX:MaxNewSize=256m；方法2: 通过 -XX:NewRatio=3\n设置，新生代:老年代=1:3</td>\n<td>Copying</td>\n<td>年龄小于XX:MaxTenuringThreshold的对象</td>\n<td>Young GC（Minor GC）</td>\n</tr>\n<tr class=\"even\">\n<td>老年代</td>\n<td>堆减去新生代大小</td>\n<td>mark compact</td>\n<td>年龄超过XX:MaxTenuringThreshold的对象（最大15，用4bit表示）</td>\n<td>Full GC（Major GC）</td>\n</tr>\n<tr class=\"odd\">\n<td>永久代（1.7）</td>\n<td>通过-XX:PermSize=128m -XX:MaxPermSize=512m 指定</td>\n<td></td>\n<td>字符串常量，Class对象</td>\n<td>Full GC</td>\n</tr>\n<tr class=\"even\">\n<td>元数据（1.8+）</td>\n<td>不属于JVM内容，使用本地内存，也可以通过JVM参数限制\n-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m</td>\n<td></td>\n<td></td>\n<td>不需要GC</td>\n</tr>\n</tbody>\n</table>\n<ol type=\"1\">\n<li>老年代装满了触发Full GC</li>\n<li>永久代存放元数据，如Class对象</li>\n<li>永久代必须指定大小限制，元数据区可以不设置，受物理内存限制</li>\n<li>字符串常量在1.7中放在永久代，在1.8中在堆中</li>\n<li>MethodArea 是一个逻辑概念，代指永久代和元数据</li>\n<li>对象何时进入老年代\n<ol type=\"1\">\n<li>YGC 达到一定年龄后，Parallel Scavenge 15，CMS 6，G1 15</li>\n<li>动态年龄：s1 + eden 存活的对象放到 s2，超过 s2 空间的\n50%，把年龄最大的放到老年代</li>\n</ol></li>\n</ol>\n<h2 id=\"对象的分配过程\">对象的分配过程</h2>\n<figure>\n<img src=\"/images/jvm/image-20221228143657912.png\" alt=\"image-20221228143657912\">\n<figcaption aria-hidden=\"true\">image-20221228143657912</figcaption>\n</figure>\n<p>流程：</p>\n<ol type=\"1\">\n<li>首先尝试在栈上分配</li>\n<li>如果栈上分配不下\n<ol type=\"1\">\n<li>属于大对象，放到堆的老年代</li>\n<li>不属于大对象，尝试线程本地分配（TLAB：Thread Local Allocation\nBuffer）</li>\n</ol></li>\n<li>如果线程本地分配失败，放到堆的年轻代的Eden区</li>\n</ol>\n<blockquote>\n<p>什么是大对象？</p>\n<p>可以通过 -XX:PretenureSizeThreshold=5m指定，但仅用于 Serial 和\nParNew</p>\n</blockquote>\n<h3 id=\"栈上分配\">栈上分配</h3>\n<ol type=\"1\">\n<li>线程私有</li>\n<li>小对象</li>\n<li>无逃逸</li>\n<li>支持标量替换</li>\n</ol>\n<blockquote>\n<p>什么是<strong>标量替换</strong></p>\n<p><strong>标量</strong>是指不可再分的原始数据类型（int、long等数值类型及reference类型等）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Point</span> <span class=\"variable\">point</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;point x=&quot;</span> + point.x + <span class=\"string\">&quot;, y=&quot;</span> + point.y);</span><br></pre></td></tr></table></figure>\n<p>当point对象在后面的执行中未被用到，编译后会变成类似下面的结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;point x=&quot;</span> + x + <span class=\"string\">&quot;, y=&quot;</span> + y);</span><br></pre></td></tr></table></figure>\n<p>从而不去创建对象，减少了创建对象和GC的成本</p>\n</blockquote>\n<h3 id=\"线程本地分配-tlab\">线程本地分配 TLAB</h3>\n<p>TLAB（Thread Local Allocation Buffer）</p>\n<p>TLAB是虚拟机在<strong>堆内存</strong>的划分出来的一块专用空间，是线程专属的。在TLAB启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率</p>\n<h3 id=\"堆上分配\">堆上分配</h3>\n<p>分配到堆的年轻代的Eden区</p>\n<h2 id=\"垃圾回收器\">垃圾回收器</h2>\n<figure>\n<img src=\"/images/jvm/garbage_collectors.png\" alt=\"garbage_collectors\">\n<figcaption aria-hidden=\"true\">garbage_collectors</figcaption>\n</figure>\n<table>\n<colgroup>\n<col style=\"width: 16%\">\n<col style=\"width: 10%\">\n<col style=\"width: 9%\">\n<col style=\"width: 24%\">\n<col style=\"width: 39%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>垃圾收集器</th>\n<th>是否分代</th>\n<th>是否多线程</th>\n<th>是否存在和工作线程同时工作</th>\n<th>使用的算法</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Serial</td>\n<td>Young</td>\n<td>否</td>\n<td>否</td>\n<td>copying</td>\n</tr>\n<tr class=\"even\">\n<td>Parallel Scavenge</td>\n<td>Young</td>\n<td>是</td>\n<td>否</td>\n<td>copying</td>\n</tr>\n<tr class=\"odd\">\n<td>ParNew</td>\n<td>Young</td>\n<td>是</td>\n<td>否</td>\n<td>copying</td>\n</tr>\n<tr class=\"even\">\n<td>Serial Old</td>\n<td>Old</td>\n<td>否</td>\n<td>否</td>\n<td>Mark-sweep Or Mark Compact</td>\n</tr>\n<tr class=\"odd\">\n<td>Parallel Old</td>\n<td>Old</td>\n<td>是</td>\n<td>否</td>\n<td>Mark Compact</td>\n</tr>\n<tr class=\"even\">\n<td>CMS</td>\n<td>Old</td>\n<td>是</td>\n<td>是</td>\n<td>三色标记 + Incremental Update + Mark-sweep</td>\n</tr>\n<tr class=\"odd\">\n<td>G1</td>\n<td>Young + Old</td>\n<td>是</td>\n<td>是</td>\n<td>三色标记 + SATB</td>\n</tr>\n<tr class=\"even\">\n<td>ZGC</td>\n<td>不分代</td>\n<td>是</td>\n<td>是</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>CMS 与 Parallel Old 的最大区别是什么？</p>\n<p>CMS 的某个阶段可以和工作线程同时进行，不是全程STW；Parallel Old\n是多线程运行，但是全程STW</p>\n</blockquote>\n<h3 id=\"分代模型垃圾收集器的常见组合\">分代模型垃圾收集器的常见组合</h3>\n<table>\n<colgroup>\n<col style=\"width: 45%\">\n<col style=\"width: 54%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>垃圾收集器组合</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Serial + Serial Old</td>\n<td>单线程</td>\n</tr>\n<tr class=\"even\">\n<td>Parallel Scavenge + Parallel Old</td>\n<td>多线程</td>\n</tr>\n<tr class=\"odd\">\n<td>ParNew + CMS</td>\n<td>多线程 + 并发回收（与工作线程同时进行）</td>\n</tr>\n</tbody>\n</table>\n<p>Serial，Serial Old，Parallel Scavenge，Parallel\nOld的执行比较简单，就是在年轻代或老年代执行相对的算法</p>\n<p>下面主要介绍 CMS 和 G1 两款垃圾收集器的流程</p>\n<h3 id=\"cms\">CMS</h3>\n<h4 id=\"执行流程\">执行流程</h4>\n<h5 id=\"阶段1.-初始标记\">阶段1. 初始标记</h5>\n<p>从 GC Roots 遍历，找到直接可达的老年代对象，发生 STW</p>\n<figure>\n<img src=\"/images/jvm/image-20221229135335326.png\" alt=\"image-20221229135335326\">\n<figcaption aria-hidden=\"true\">image-20221229135335326</figcaption>\n</figure>\n<h5 id=\"阶段2.-并发标记\">阶段2. 并发标记</h5>\n<p>GC 线程和工作线程同时执行，不产生 STW</p>\n<p>从第一阶段标记的存活对象开始，继续向下遍历老年代，标记所有可达的老年代对象</p>\n<figure>\n<img src=\"/images/jvm/image-20221229135358877.png\" alt=\"image-20221229135358877\">\n<figcaption aria-hidden=\"true\">image-20221229135358877</figcaption>\n</figure>\n<p>在并发标记阶段，工作线程也在执行，所以可能产生新的对象或新的垃圾</p>\n<p>对于这些对象，需要重新标记以防被遗漏，本阶段会把这些发生变化的对象标记为\nDirty，后续只需要扫描这些 Dirty 对象，不需要扫描整个老年代</p>\n<h5 id=\"阶段3.-重新标记\">阶段3. 重新标记</h5>\n<p>来解决并发标记过程中产生的引用关系变化，需要 STW</p>\n<p>主要工作：</p>\n<ol type=\"1\">\n<li>遍历新生代对象，重新标记；（新生代会被分块，多线程扫描）</li>\n<li>根据 GC Roots，重新标记；</li>\n<li>遍历老年代的 Dirty 对象，重新标记</li>\n</ol>\n<h5 id=\"阶段4.-并发清理\">阶段4. 并发清理</h5>\n<p>并发执行 mark-sweep，清理所有未被标记的对象，不 STW</p>\n<h4 id=\"cms-存在的问题\">CMS 存在的问题</h4>\n<ol type=\"1\">\n<li>碎片化：mark-sweep 导致，如果无法分配，会使用 Serial Old\n单线程的清理，导致严重的STW</li>\n<li>产生浮动垃圾：阶段 4 还会产生垃圾，不会被清理</li>\n</ol>\n<h3 id=\"g1\">G1</h3>\n<h4 id=\"设计思想\">设计思想</h4>\n<blockquote>\n<p>分治</p>\n</blockquote>\n<p>经典的垃圾收集器都是对整个新生代或老年代进行垃圾回收，要扫描的对象太多了</p>\n<p>G1采用了开创性的<strong>局部收集</strong>的设计思路和以 Region\n为基本单位的内存布局方式，它将堆空间划分成多个大小相等的独立区域(Region)，JVM目标是总共不超过2048个Region</p>\n<figure>\n<img src=\"/images/jvm/image-20221231113100546.png\" alt=\"image-20221231113100546\">\n<figcaption aria-hidden=\"true\">image-20221231113100546</figcaption>\n</figure>\n<p>Region分为四种类型：Eden、Survivor、Old、Humongous</p>\n<p>新生代：Eden + Survivor，默认大小为堆的5%，最大为堆的60%，Eden 和\nSurvivor1，Survivor2 的比例为 8:1:1</p>\n<p>老年代：Old</p>\n<p>Humongous：超过一个Region大小的50%的对象</p>\n<blockquote>\n<p>新生代和老年代的比例是动态的，不需要指定</p>\n<p>G1 会根据STW时间来调整新老代的比例</p>\n</blockquote>\n<h4 id=\"g1-的垃圾回收过程\">G1 的垃圾回收过程</h4>\n<h5 id=\"young-gc\">Young GC</h5>\n<p>触发条件：Eden区放满，或者\nG1计算回收时间接近参数<code>-XX:MaxGCPauseMills</code>设定的值，那么就会触发\nYoung GC</p>\n<p>回收对象：Eden区的垃圾</p>\n<p>过程：将存活的 Eden Region 的对象拷贝到 Survior\nRegion，达到晋升年龄的就晋升到老年代Region，清空原Eden Region</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1824886\">G1垃圾收集器（6）之Young\nGC</a></p>\n<h5 id=\"mixed-gc\">Mixed GC</h5>\n<p>触发条件：老年代的堆空间内存占用达到了参数<code>-XX:InitiatingHeapOccupancyPercent</code>设定的值，默认是\n45%</p>\n<p>回收对象：所有新生代 + 部分老年代 +\nHomongous（根据优先级和设置的回收期望时间）</p>\n<p>Mixed GC 的过程如下：</p>\n<ol type=\"1\">\n<li>初始标记：暂定所有线程（STW），记录 GC Roots\n能直接引用的对象，速度很快。（与CMS的初始标记相同）</li>\n<li>并发标记：与工作线程一起工作，并发地进行可达性分析（与CMS的并发标记一样）</li>\n<li>最终标记（重新标记）：需要暂定所有线程（STW），根据三色标记 +\nSATB算法修复一些引用的状态（与CMS的标记算法不同）</li>\n<li>筛选回收：筛选回收阶段会对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿STW时间来制定回收计划，使用\nCopying\n算法，将一个Region中的存活对象移动到另一个空的Regin中，然后将之前的Region内存空间清空（相比于CMS内存碎片化程度降低很多，但依旧有碎片出现）</li>\n</ol>\n<blockquote>\n<p>如何制定回收计划？</p>\n<p>比如此时有1000个Region都满了，但根据用户设置的STW时间，本次垃圾回收只能停顿200毫秒，那么通过之前的回收成本计算（怎么计算？），200毫秒只能回收600个Region的内存空间，那么G1就会只回收这600个Region（Collection\nSet，要回收的Region集合）的内存空间，尽量把GC的停顿时间控制在用户指定的停顿时间内</p>\n</blockquote>\n<h5 id=\"full-gc\">Full GC</h5>\n<p>触发条件：无法分配对象</p>\n<p>回收对象：全部垃圾</p>\n<p>过程：使用单线程/多线程（jdk1.10后多线程）标记、清理和压缩整理</p>\n<h4 id=\"如何避免-g1-的-full-gc\">如何避免 G1 的 Full GC</h4>\n<ol type=\"1\">\n<li>扩内存</li>\n<li>提高 CPU 个数和性能</li>\n<li>降低 Mixed GC 触发的阈值，让 Mixed GC 提前触发</li>\n</ol>\n<h4 id=\"cms-与-g1-的并发标记算法\">CMS 与 G1 的并发标记算法</h4>\n<p>CMS 和 G1 最大的相同点便是它们的主要步骤都是：</p>\n<ol type=\"1\">\n<li>初始标记（inital marking）</li>\n<li>并发标记（concurrent marking）</li>\n<li>最终标记（final marking/remark）</li>\n<li>清理（cleanup）</li>\n</ol>\n<p>虽然标记过程类似，但其中对于<strong>并发标记</strong>过程中对象引用状态改变的处理是不同：</p>\n<p>CMS 使用的是三色标记 + Incremental Update 算法</p>\n<p>G1 使用的是三色标记 + Snapshot At The Begining（SATB）算法</p>\n<h5 id=\"三色标记\">三色标记</h5>\n<p>黑色：自身和成员变量均已标记完成\n灰色：自身被标记完成，成员变量未被标记 白色：未被标记的对象（垃圾）</p>\n<h5 id=\"扫描的过程\">扫描的过程</h5>\n<ol type=\"1\">\n<li>并发标记前都是白色对象</li>\n<li>并发标记开始，所有能被 GC Roots\n对象直达的对象被压到栈中，待向下搜索，标记为灰色</li>\n<li>灰色对象依次出栈，搜索其子对象，子对象标记为灰色，入栈</li>\n<li>当所有子对象都标记为灰色后，该对象标记为黑色</li>\n<li>并发标记结束后，灰色对象都没了，剩下的黑色对象为存活对象，白色对象为垃圾</li>\n</ol>\n<blockquote>\n<p>扫描过程中由于引用关系的变化，会发生<strong>漏标</strong>和<strong>多标</strong>两种情况</p>\n</blockquote>\n<h5 id=\"漏标的产生\">漏标的产生</h5>\n<p>在并发标记过程中，导致对象被漏标的两个充要条件是：</p>\n<ol type=\"1\">\n<li>插入了从 black 对象到 white 对象的引用</li>\n<li>删除了所有从 grey 对象到 white 对象的直接或者间接引用</li>\n</ol>\n<p><strong>举个栗子</strong></p>\n<p>在并发标记过程中，有一个新对象 A（白色）进入了老年代，它是灰色对象 C\n的属性，这时重新扫描是可以通过 C 找到 A 的，但是在并发标记过程中，A - C\n的引用断了，又建立了一个黑色对象 B 到 A 的关系，导致 A 被漏标</p>\n<blockquote>\n<p>Q：第二个条件，为什么一定要白色对象失去灰色对象到达它的引用路径呢？一个新加入到老年代的对象，没有灰色对象的引用，不会产生漏标吗？比如：在并发标记过程中，有一个新对象\nA（白色）进入了老年代，一个黑色对象 B 中的引用指向了 A，并且 A\n的引用指向了 null，那么我们只能从 B 找到 A了，由于 B\n是已标记的，不会被重新扫描，导致了 A 被漏标，误认为垃圾，惨遭清理\n:cry:</p>\n<p>A：针对并发标记过程中产生了新对象，直接全部当成黑色，本轮不会进行清除</p>\n</blockquote>\n<p>为了解决漏标的问题，CMS 使用了 Incremental Update，G1 使用了\nSATB（Snapshot at the begining）</p>\n<figure>\n<img src=\"/images/jvm/image-20230104110442201.png\" alt=\"image-20230104110442201\">\n<figcaption aria-hidden=\"true\">image-20230104110442201</figcaption>\n</figure>\n<figure>\n<img src=\"/images/jvm/image-20230104110612315.png\" alt=\"image-20230104110612315\">\n<figcaption aria-hidden=\"true\">image-20230104110612315</figcaption>\n</figure>\n<figure>\n<img src=\"/images/jvm/image-20230104110650643.png\" alt=\"image-20230104110650643\">\n<figcaption aria-hidden=\"true\">image-20230104110650643</figcaption>\n</figure>\n<h5 id=\"漏标的解决方案\">漏标的解决方案</h5>\n<h6 id=\"incremental-update\">Incremental Update</h6>\n<p>Incremental Update\n关注的是第一个条件的打破，即引用关系的插入。Incremental update 利用\nwrite barrier\n将所有新插入的引用关系都记录下来（如黑A-白C），最后以这些引用关系的 src\n为根 STW 地重新扫描一遍即避免了漏标问题</p>\n<h6 id=\"satb\">SATB</h6>\n<p>关注的是第二个条件的打破，即引用关系的删除。SATB 利用 pre write\nbarrier 将所有被删除的引用关系（如灰 B-白 C）推到 GC 的堆栈，保证 C\n还能被 GC 扫描到，在最终标记阶段扫描这些记录</p>\n<blockquote>\n<p>简单的讲，当引用关系变动时，Incremental Update\n把黑色对象标记为了灰色，SATB 把白色对象收集到堆栈中</p>\n</blockquote>\n<p>两种漏标解决方案的对比：</p>\n<ul>\n<li><p>Incremental Update算法关注的是引用的增加（A-&gt;C\n的引用）</p></li>\n<li><p>SATB算法关注的是引用的删除（B-&gt;C 的引用）</p></li>\n</ul>\n<h5 id=\"多标的产生\">多标的产生</h5>\n<figure>\n<img src=\"/images/jvm/image-20230105235613359.png\" alt=\"image-20230105235613359\">\n<figcaption aria-hidden=\"true\">image-20230105235613359</figcaption>\n</figure>\n<p>假设已经遍历到 E，E 变为灰色了，此时应用执行了\n<code>D.E = null</code></p>\n<p>对象 E、F、G 是应该被回收的，但由于 E\n变为灰色，其仍会被当作存活对象继续遍历下去 最终的结果是： E、F、G\n仍会被标记为存活，即本轮 GC 不会回收这部分内存</p>\n<p>这部分本应该回收但是没有回收到的内存，被称之为<strong>浮动垃圾</strong>\n浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除</p>\n<h5 id=\"问题汇总\">问题汇总</h5>\n<p>对于上面的描述，有以下几个问题</p>\n<h6 id=\"问题1.-satb-将白色对象放入堆栈后怎么重新标记白色对象\">问题1.\nSATB 将白色对象放入堆栈后，怎么重新标记白色对象？</h6>\n<p>最直接的思路，可以从 GC Roots\n重新遍历一遍，看有没有遍历到白色对象，但这样效率较低</p>\n<p>有没有更高效的思路呢，可以建立对象引用的倒排索引，即一个对象被谁引用了</p>\n<p>看下 G1 是如何实现的，先介绍下 Card Table 和 Remember Set</p>\n<p><strong>Card Table</strong></p>\n<p>Card Table 是一个数组，每个元素称为卡片/卡页（Page），一个 Page\n的大小为 1 字节。这个 Card Table 会映射整个堆空间，每个 Page 会对应堆的\n512B 空间</p>\n<figure>\n<img src=\"/images/jvm/image-20230104195019956.png\" alt=\"image-20230104195019956\">\n<figcaption aria-hidden=\"true\">image-20230104195019956</figcaption>\n</figure>\n<p>那么查找一个对象所在的 Card Page 只需要简单的计算就可以得出：(\n对象地址 - 堆开始地址 ) / 512 Page 标记为\n0，表示对应的区域中没有对新生代的引用；Page 标记为\n1（Dirty），表示有对新生代的引用。使用 Cart Table\n可以大大加快新生代的回收速度</p>\n<figure>\n<img src=\"/images/jvm/Card_table.drawio.png\" alt=\"Card_table.drawio\">\n<figcaption aria-hidden=\"true\">Card_table.drawio</figcaption>\n</figure>\n<blockquote>\n<p>Q: 为什么卡表中一页大小为一字节，一个 bit 不就行了吗？</p>\n<p>A:\n之所以使用byte数组而不是bit数组主要是速度上的考量，现代计算机硬件都是最小按字节寻址的，\n没有直接存储一个bit的指令</p>\n</blockquote>\n<blockquote>\n<p>Q：为什么要从 Cart Table 中 Dirty Page 指向的老年代对象出现，而不是从\nGC Roots 出发，怎么知道 Dirty Page\n指向的老年代对象不是垃圾呢？不会发生循环引用吗？</p>\n<p>A：不知道</p>\n</blockquote>\n<p><strong>Remember Set</strong></p>\n<p>G1 的每个 Region 中都有一个 <strong>Remember\nSet（RSet）</strong>，通过 hash 实现，这个 hash 表的 key\n是引用本区域的其他区域的地址，value\n是一个数组，数组的元素是引用方的对象所对应的 Card Page 在 Card Table\n中的下标</p>\n<p>如下图所示，区域 B 中的对象 b 引用了区域 A 中的对象\na，这个引用关系跨了两个区域。b 对象所在的 Card Page 为 122，在区域 A 的\nRSet 中，以区域 B 的地址作为 key，b 对象所在 Card Page 下标为 value\n记录了这个引用关系，这样就完成了这个跨区域引用的记录</p>\n<figure>\n<img src=\"/images/jvm/image-20230104201019369.png\" alt=\"image-20230104201019369\">\n<figcaption aria-hidden=\"true\">image-20230104201019369</figcaption>\n</figure>\n<blockquote>\n<p>Q：为什么RSet 的 value 不直接保存对象地址，而是保存 Card Page，再通过\nCard Page 对映射到一个地址区间？</p>\n<p>A：不知道  </p>\n</blockquote>\n<p>比如 Region M 中有一个对象 N，如果 RSet 没有记录其他 Region 对 N\n的索引，M 内部也没有对 N 的引用，那么 N 就是垃圾</p>\n<p>这样 G1 就不需要全量扫描了，只需要查 RSet 和本 Region 就可以了</p>\n<h6 id=\"问题2.-为什么-g1-选择-satb-而不是-incremental-update\">问题2.\n为什么 G1 选择 SATB 而不是 Incremental Update?</h6>\n<p>Incremental Update\n是将黑色标记为灰色，这样在重新标记灰色对象时，需要遍历它的全部属性，而我们关心的其实只是其中变化的引用关系，这样就产生了很多无用的工作；</p>\n<p>SATB 因为可以借助 RSet 和 Card Table，对引用发生变化的白色对象，在\nRSet 中查表即可了，所以效率更高</p>\n<h6 id=\"问题3.-怎么感知对象之间引用的变化\">问题3.\n怎么感知对象之间引用的变化</h6>\n<p>利用了<strong>写屏障</strong>，所谓写屏障，就是指给某个对象的成员变量赋值操作前后，加入一些处理（类似\nSpring AOP 的概念）</p>\n<h2 id=\"参考文献\">参考文献</h2>\n","categories":["jvm"],"tags":["gc"]},{"title":"jvm 类加载过程","url":"/2023/01/07/jvm/jvm-class-loader/","content":"<blockquote>\n<p>本文介绍 JVM 的类加载过程，以及类加载器</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"什么是类加载\">什么是类加载</h2>\n<p>java 的源码编译为字节码 Class 文件，需要加载到 JVM\n中才能运行，类加载过程就是如何将 Class 文件加载到 JVM 中的过程</p>\n<blockquote>\n<p>注：</p>\n<ol type=\"1\">\n<li>不要和对象的实例化搞混，这个过程不涉及创建对象</li>\n<li>只有第一次使用这个类时才会加载</li>\n</ol>\n</blockquote>\n<h2 id=\"加载流程\">加载流程</h2>\n<figure>\n<img src=\"/images/jvm/类加载过程.drawio.png\" alt=\"类加载过程.drawio\">\n<figcaption aria-hidden=\"true\">类加载过程.drawio</figcaption>\n</figure>\n<ol type=\"1\">\n<li><p>loading（加载）：</p>\n<ol type=\"1\">\n<li>将 class 文件（二进制数据）写入内存</li>\n<li>转化为 jvm 能识别的数据结构</li>\n<li>在内存中生成代表该类的 java.lang.Class\n对象，作为方法区访问该类的入口</li>\n</ol></li>\n<li><p>Linking（链接）：将内存中的 class 文件合并至 JVM\n中，分为验证、准备、解析三个阶段</p>\n<ol type=\"1\">\n<li><p>Verification（验证）：对 class\n文件进行合法校验，如：字节码格式、语法规范、引用验证</p></li>\n<li><p>Preparation（准备）：为类的<strong>静态变量</strong>分配内存（在方法区中），此时静态变量的值为默认值，如<code>static int A = 9;</code>这一步会为\nA 在方法区中申请 4 字节的空间，由于该空间的二进制位全 0，所以此时 A =\n0</p>\n<blockquote>\n<p>注：</p>\n<ol type=\"1\">\n<li><p>如果是<code>public final static int A = 9;</code>则此时 A =\n9，这是因为 static final 修饰的变量在编译期间会生成 ConstantValue\n属性，在类加载的准备阶段根据 ConstantValue 的值为该字段赋值</p>\n<p>static final\n变量没有默认值，必须显式地赋值，否则编译时会报错</p></li>\n<li><p>1.8之后，字符串常量放到堆空间中</p></li>\n</ol>\n</blockquote></li>\n<li><p>Resolution（解析）：将常量池中的符号引用解析为直接引用（目标的指针、偏移量、句柄）</p></li>\n</ol></li>\n<li><p>Initializing（初始化）：静态变量赋初始值，如<code>static int A = 9;</code>这一步会将\nA 赋为 9</p></li>\n</ol>\n<h2 id=\"类加载器\">类加载器</h2>\n<p>上面介绍了一个类加载到 JVM 内存的过程，类加载器执行其中的 loading\n过程</p>\n<h3 id=\"分类\">分类</h3>\n<ol type=\"1\">\n<li>Bootstrap</li>\n<li>Extension</li>\n<li>App</li>\n<li>Custom ClassLoader</li>\n</ol>\n<p>每个类加载器都有一块缓存，保存自己加载过的类</p>\n<figure>\n<img src=\"/images/jvm/类加载器.drawio.png\" alt=\"类加载器.drawio\">\n<figcaption aria-hidden=\"true\">类加载器.drawio</figcaption>\n</figure>\n<h3 id=\"双亲委派\">双亲委派</h3>\n<h4 id=\"工作原理\">工作原理</h4>\n<ol type=\"1\">\n<li>一个类加载器收到了类加载的请求，先到自己的缓存中查找是否加载过</li>\n<li>如果缓存中存在，则返回加载的类；如果缓存中不存在，交给父加载器</li>\n<li>如果父加载器的缓存中存在，则返回加载到JVM内存的地址；如果没有，继续交给父加载器，直到\nBootStrap</li>\n<li>如果 BootStrap 的缓存中也不存在，开始从负责的范围中寻找</li>\n<li>如果 BootStrap 负责的范围内找不到类的 Class\n文件，依次交给子加载器</li>\n<li>如果某个加载器在负责的范围内找到了要加载的类，写入自己的缓存区，并返回地址</li>\n</ol>\n<p>上述步骤，1-3 为自下而上，4-6 为自上而下</p>\n<h4 id=\"为什么要有双亲委派来加载类\">为什么要有双亲委派来加载类？</h4>\n<p>安全性：如果核心类如 java.lang.String\n可以由开发者自定义的类加载器加载，则开发者可以覆盖该类型，在里面执行恶意代码。如果使用双亲委派，自定义类加载器的缓存区中没有\njava.lang.String 类型，只能交给上层加载器，从而避免了这个问题</p>\n<h4 id=\"源码分析\">源码分析</h4>\n<p>类加载源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// java.lang.ClassLoader#loadClass(java.lang.String, boolean)</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"type\">boolean</span> resolve)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// First, check if the class has already been loaded</span></span><br><span class=\"line\">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">          \t<span class=\"comment\">// 缓存中没有，交给父加载器或Bootstrap</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">t0</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  \t<span class=\"comment\">// 有父类，交给父类</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        c = parent.loadClass(name, <span class=\"literal\">false</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                      \t<span class=\"comment\">// 没有父类，说明当前是 bootstrap，自己加载</span></span><br><span class=\"line\">                        c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></span><br><span class=\"line\">                    <span class=\"comment\">// from the non-null parent class loader</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"comment\">// 所有父加载器都没有找到，自己加载</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// If still not found, then invoke findClass in order</span></span><br><span class=\"line\">                    <span class=\"comment\">// to find the class.</span></span><br><span class=\"line\">                    <span class=\"type\">long</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                  \t<span class=\"comment\">// 到自己的指定范围内加载类</span></span><br><span class=\"line\">                    c = findClass(name);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// this is the defining class loader; record the stats</span></span><br><span class=\"line\">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">                resolveClass(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看一个类的加载器\">查看一个类的加载器</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"string\">&quot;String ClassLoader: &quot;</span> + String.class.getClassLoader());j</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义类加载器\">自定义类加载器</h3>\n<h4 id=\"为什么需要自定义类加载器\">为什么需要自定义类加载器</h4>\n<p>举几个自定义类加载器的应用场景：</p>\n<ol type=\"1\">\n<li>源码加密：Java\n代码可以被反编译，如果需要把自己的代码进行加密以防止反编译，可以先将编译后的代码用某种加密算法加密，类加密后就不能再用\nJVM 的 ClassLoader 去加载类了，这时就需要自定义 ClassLoader\n在加载类的时候先解密，然后再加载</li>\n<li>从非标准源加载代码：如果你的字节码是放在数据库、某个服务器，就可以自定义类加载器，从指定的来源加载类</li>\n<li>防止多个项目间出现重名的类：比如 Tomcat\n需要部署多个项目，无法保证不同项目之间没有重名（package +\n类名）的类，如果只有用一个加载器，无法同时加载多个重名的类（见下文例子）</li>\n<li>热加载（Hot\nSwap），热加载需要重新加载类，由于系统级别的加载器不能手动创建新的加载器对象，只要类加载过，就只能从缓存中读，不能清除缓存，无法重新加载，但是自定义的类加载器可以随意\nnew 新的，从而重新加载覆盖原有的类对象</li>\n</ol>\n<blockquote>\n<p>热加载是针对单个字节码文件，重新编译后，不需要重启进程，应用程序就可以使用新的class\n文件</p>\n</blockquote>\n<p>源来：<a href=\"https://www.baeldung.com/java-classloaders\">Class\nLoaders in Java</a> <a href=\"https://blog.csdn.net/t194978/article/details/125984471\">JVM——自定义类加载器</a>\n<a href=\"https://stackoverflow.com/questions/10828863/what-is-the-use-of-custom-class-loader\">What\nis the use of Custom Class Loader</a></p>\n<h4 id=\"如何自定义类加载器\">如何自定义类加载器</h4>\n<p>继承 ClassLoader，重写 findClass，不建议重写 loadClass，因为重写\nloadClass 如果打破了双亲委派，当要加载的类依赖于 java.lang.String\n等需要父加载器加载的类，则会因无法加载而报错</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.example;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.ByteArrayOutputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Constructor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.Channels;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.FileChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.WritableByteChannel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomerClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassLoader</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 类源文件编译产物的路径</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String classFilePath;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"keyword\">public</span> <span class=\"title function_\">customerClassLoader</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">customerClassLoader</span><span class=\"params\">(String classFilePath)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.classFilePath = classFilePath;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">byte</span>[] bytes = getClassBytes(<span class=\"built_in\">this</span>.classFilePath);</span><br><span class=\"line\">            Class&lt;?&gt; c = <span class=\"built_in\">this</span>.defineClass(name, bytes, <span class=\"number\">0</span>, bytes.length);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"comment\">// 读取 .Class 文件的二进制内容</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">byte</span>[] getClassBytes(String filePath) <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(filePath);</span><br><span class=\"line\">        <span class=\"type\">FileInputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(file);</span><br><span class=\"line\">        <span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> inputStream.getChannel();</span><br><span class=\"line\">        <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">outputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">        <span class=\"type\">WritableByteChannel</span> <span class=\"variable\">writableByteChannel</span> <span class=\"operator\">=</span> Channels.newChannel(outputStream);</span><br><span class=\"line\">        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">byteBuffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span>  channel.read(byteBuffer);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || i == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            byteBuffer.flip();</span><br><span class=\"line\">            writableByteChannel.write(byteBuffer);</span><br><span class=\"line\">            byteBuffer.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inputStream.close();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outputStream.toByteArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class=\"line\">        <span class=\"type\">CustomerClassLoader</span> <span class=\"variable\">customerClassLoader</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">customerClassLoader</span>(<span class=\"string\">&quot;/Users/zhangjiaming/Desktop/consumeClassLoader/People.class&quot;</span>);</span><br><span class=\"line\">        Class&lt;?&gt; clazz = customerClassLoader.loadClass(<span class=\"string\">&quot;People&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        Class&lt;?&gt; clazz = Class.forName(&quot;People&quot;, true, customerClassLoader);</span></span><br><span class=\"line\">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> constructor.newInstance(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">        System.out.println(obj.getClass().getClassLoader());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"/images/jvm/image-20230108134131391.png\" alt=\"image-20230108134131391\">\n<figcaption aria-hidden=\"true\">image-20230108134131391</figcaption>\n</figure>\n<h4 id=\"自定义类加载器的应用\">自定义类加载器的应用</h4>\n<h5 id=\"加载多个同名类\">加载多个同名类</h5>\n<h6 id=\"应用场景\">应用场景</h6>\n<p>比如一个方法有多个版本，我们希望同时使用多个版本的类；Tomcat\n中运行了多个项目，项目中存在重名的类</p>\n<blockquote>\n<p>一个类加载器为什么不能加载多个同名类？</p>\n<p>因为类加载器 L 会先到缓存中查找是否已加载，对于同名类（package +\n类名），当 A 项目中的 com.model.Dog.java 已经加载了，L 就不会再去加载 B\n项目中的 com.model.Dog.java，这样 B 项目用了错误的类，导致 B\n项目运行报错</p>\n</blockquote>\n<h6 id=\"验证\">验证</h6>\n<p>准备两个 java 文件，放到 A，B两个路径下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.zjm.model;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">People</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">People</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">// 第一个文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;I am a A people, my name is &quot;</span> + name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 第二个文件</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;I am a B people, my name is &quot;</span> + name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义类加载器用上文的，修改 main 函数，令一个类加载器加载</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">(String path, String className, CustomerClassLoader customerClassLoader)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    customerClassLoader.setClassFilePath(path);</span><br><span class=\"line\">    Class&lt;?&gt; clazz = customerClassLoader.loadClass(className);</span><br><span class=\"line\">    Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> constructor.newInstance(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">    System.out.println(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">CustomerClassLoader</span> <span class=\"variable\">customerClassLoader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CustomerClassLoader</span>();</span><br><span class=\"line\">    test(<span class=\"string\">&quot;/Users/zhangjiaming/Desktop/cunstomerClassLoader/A/People.class&quot;</span>, <span class=\"string\">&quot;com.zjm.model.People&quot;</span>, customerClassLoader);</span><br><span class=\"line\">    test(<span class=\"string\">&quot;/Users/zhangjiaming/Desktop/cunstomerClassLoader/B/People.class&quot;</span>, <span class=\"string\">&quot;com.zjm.model.People&quot;</span>, customerClassLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"/images/jvm/image-20230110140323056.png\" alt=\"image-20230110140323056\">\n<figcaption aria-hidden=\"true\">image-20230110140323056</figcaption>\n</figure>\n<p>可以发现，第二次没有加载新的类，而是使用了已加载的类，所以要使用不同的类加载器，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">ConsumerClassLoader</span> <span class=\"variable\">consumerClassLoader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConsumerClassLoader</span>();</span><br><span class=\"line\">        test(<span class=\"string\">&quot;/Users/zhangjiaming/Desktop/consumeClassLoader/A/People.class&quot;</span>, consumerClassLoader);</span><br><span class=\"line\">        <span class=\"type\">ConsumerClassLoader</span> <span class=\"variable\">consumerClassLoader1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConsumerClassLoader</span>();</span><br><span class=\"line\">        test(<span class=\"string\">&quot;/Users/zhangjiaming/Desktop/consumeClassLoader/B/People.class&quot;</span>, consumerClassLoader1);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"/images/jvm/image-20230110140449779.png\" alt=\"image-20230110140449779\">\n<figcaption aria-hidden=\"true\">image-20230110140449779</figcaption>\n</figure>\n<h5 id=\"热加载\">热加载</h5>\n<h6 id=\"应用场景-1\">应用场景</h6>\n<p>修改代码并编译后，不需要重启服务，直接生效</p>\n<h6 id=\"实现思路\">实现思路</h6>\n<p>监听 Class 文件变化，当 Class\n文件变化时，创建新的类加载器加载类，覆盖原来的 Class 对象</p>\n<h6 id=\"验证-1\">验证</h6>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">(String path)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    Class&lt;?&gt; clazz = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">ConsumerClassLoader</span> <span class=\"variable\">consumerClassLoader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConsumerClassLoader</span>();</span><br><span class=\"line\">        consumerClassLoader.setClassFilePath(path);</span><br><span class=\"line\">        clazz = consumerClassLoader.loadClass(<span class=\"string\">&quot;com.zjm.model.People&quot;</span>);</span><br><span class=\"line\">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> constructor.newInstance(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">        System.out.println(obj);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">   test(<span class=\"string\">&quot;/Users/zhangjiaming/Desktop/consumeClassLoader/A/People.class&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"/images/jvm/image-20230110192624216.png\" alt=\"image-20230110192624216\">\n<figcaption aria-hidden=\"true\">image-20230110192624216</figcaption>\n</figure>\n<blockquote>\n<p>这里只是一个简单的例子，要实现热加载还是有很多点要考虑，待后续讨论</p>\n</blockquote>\n<h6 id=\"字节码加密\">字节码加密</h6>\n<p>通过某种加密算法修改 Class 文件，然后通过解密算法解密，再加载</p>\n<h2 id=\"参考文献\">参考文献</h2>\n","categories":["jvm"],"tags":["jvm"]},{"title":"k8s-运行应用","url":"/2022/04/05/k8s/run-application/","content":"<h2 id=\"部署nginx服务\">部署nginx服务</h2>\n<h3 id=\"使用kubectl命令\">使用kubectl命令</h3>\n<p><code>kubectl run nginx-deployment --image=nginx:1.7.9  --replicas=2</code></p>\n<span id=\"more\"></span>\n<h3 id=\"使用配置文件\">使用配置文件</h3>\n<p>创建nginx.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.7.9</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br></pre></td></tr></table></figure>\n<p><code>kubectl apply -f nginx-deployment.yaml</code></p>\n<h3 id=\"配置文件中添加nginx服务配置\">配置文件中添加nginx服务配置</h3>\n<blockquote>\n<p>上面的配置文件，nginx的配置、html页面、日志在容器里，不方便修改和查看，下面设置挂载路径，将上述文件挂载到宿主机</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.7.9</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">        <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">conf</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/nginx/nginx.conf</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">confd</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/nginx/conf.d</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">log</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/var/log/nginx</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">html</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/nginx/html</span></span><br><span class=\"line\">      <span class=\"attr\">tolerations:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">&quot;key&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">operator:</span> <span class=\"string\">&quot;Equal&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">value:</span> <span class=\"string\">&quot;nginx&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">effect:</span> <span class=\"string\">&quot;NoSchedule&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">conf</span></span><br><span class=\"line\">        <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">          <span class=\"attr\">path:</span> <span class=\"string\">/home/work/kube/nginx/conf/nginx.conf</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">confd</span></span><br><span class=\"line\">        <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">          <span class=\"attr\">path:</span> <span class=\"string\">/home/work/kube/nginx/conf.d</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">log</span></span><br><span class=\"line\">        <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">          <span class=\"attr\">path:</span> <span class=\"string\">/home/work/kube/nginx/logs</span></span><br><span class=\"line\">          <span class=\"attr\">type:</span> <span class=\"string\">Directory</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">html</span></span><br><span class=\"line\">        <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">          <span class=\"attr\">path:</span> <span class=\"string\">/home/work/kube/nginx/html</span></span><br><span class=\"line\">          <span class=\"attr\">type:</span> <span class=\"string\">Directory</span></span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ol type=\"1\">\n<li>挂载的目录或文件需要先在宿主机上创建，其中nginx.conf从nginx容器中拷贝出来：<code>docker cp &#123;container-name&#125;:&#123;container-path&#125; &#123;host-path&#125;</code></li>\n<li></li>\n</ol>\n<p>（待补充）</p>\n<p>更新nginx应用：<code>kubectl apply -f nginx.yaml</code></p>\n<h3 id=\"创建service\">创建Service</h3>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">9000</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">nginx-service</span></span><br><span class=\"line\">    <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span></span><br><span class=\"line\">    <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">    <span class=\"attr\">nodePort:</span> <span class=\"number\">31090</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span></span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ol type=\"1\">\n<li><p>将Service的9000端口映射到Pod的80端口</p>\n<figure>\n<img src=\"/images/k8s/image-20220407004507010.png\" alt=\"image-20220407004507010\">\n<figcaption aria-hidden=\"true\">image-20220407004507010</figcaption>\n</figure></li>\n<li><p>nginx-svc被分配的cluster-ip 192.168.31.22 可通过该IP访问后端nginx\nPod</p>\n<figure>\n<img src=\"/images/k8s/image-20220407004725110.png\" alt=\"image-20220407004725110\">\n<figcaption aria-hidden=\"true\">image-20220407004725110</figcaption>\n</figure></li>\n<li><p><code>kubectl describe service nginx-svc</code>\n查看nginx-svc与pod的关系</p>\n<figure>\n<img src=\"/images/k8s/image-20220407004927642.png\" alt=\"image-20220407004927642\">\n<figcaption aria-hidden=\"true\">image-20220407004927642</figcaption>\n</figure>\n<p>Endpoints列举了两个Pod的IP和端口</p>\n<p>进入Pod\n<code>docker exec -it &#123;container_id&#125; /bin/bash</code>，查看ip地址\n<code>ip addr</code></p>\n<figure>\n<img src=\"/images/k8s/image-20220407005958681.png\" alt=\"image-20220407005958681\">\n<figcaption aria-hidden=\"true\">image-20220407005958681</figcaption>\n</figure></li>\n<li><p>Service的Cluster IP 是怎么映射到Pod IP 的？</p>\n<p>通过iptables的转发规则，将流量转发到Pod上，Cluster的每个节点都配置了相同的iptables规则</p>\n<p><code>iptables-save | grep nginx</code></p>\n<figure>\n<img src=\"/images/k8s/image-20220407011152220.png\" alt=\"image-20220407011152220\">\n<figcaption aria-hidden=\"true\">image-20220407011152220</figcaption>\n</figure>\n<p>其中，红框中两条规则：</p>\n<ul>\n<li>如果Cluster内的Pod要访问nginx-svc，则允许；</li>\n<li>其他源地址访问nginx-svc，跳转到规则<strong>KUBE-SVC-HL5LMXD5JFHQZ6LN</strong></li>\n</ul>\n<p><strong>KUBE-SVC-HL5LMXD5JFHQZ6LN</strong>规则为：</p>\n<figure>\n<img src=\"/images/k8s/image-20220407011429837.png\" alt=\"image-20220407011429837\">\n<figcaption aria-hidden=\"true\">image-20220407011429837</figcaption>\n</figure>\n<p>0.5的概率跳转到<strong>KUBE-SEP-RSXKIBUPEFSC7MO6</strong></p>\n<p>否则跳转到<strong>KUBE-SEP-NHHTLNEICZVNVOWJ</strong></p>\n<p>下面是<strong>KUBE-SEP-RSXKIBUPEFSC7MO6</strong>与<strong>KUBE-SEP-NHHTLNEICZVNVOWJ</strong>的转发规则，即转发到后端Pod</p>\n<figure>\n<img src=\"/images/k8s/image-20220407011738843.png\" alt=\"image-20220407011738843\">\n<figcaption aria-hidden=\"true\">image-20220407011738843</figcaption>\n</figure>\n<p>综上：iptables将访问Service的流量转发到后端Pod，并使用类似轮询的负载均衡策略</p></li>\n<li><p>只有集群内部的节点可以访问Service Cluster\nIP，比如在集群中，有服务A与B，A需要访问B，可以通过A的Service Cluster\nIP，但是这个IP是随机分配的，如果Service\nA销毁重建，B需要更改配置，很不方便</p></li>\n</ol>\n<h4 id=\"集群内访问nginx服务\">集群内访问nginx服务</h4>\n<h5 id=\"通过service的cluster-ip\">通过Service的Cluster IP</h5>\n<h5 id=\"通过dns访问\">通过DNS访问</h5>\n<figure>\n<img src=\"/images/k8s/image-20220407013135487.png\" alt=\"image-20220407013135487\">\n<figcaption aria-hidden=\"true\">image-20220407013135487</figcaption>\n</figure>\n<p>当有新的Service创建，coredns会添加该Service的DNS记录，Cluster中的Pod可以通过{serviceName}.{namespace}访问Service</p>\n<p>如：在一个临时的Pod中通过DNS访问nginx Service</p>\n<p><code>kubectl run busybox --rm -it --image=busybox /bin/sh</code></p>\n<p><code>wget &#123;serviceName&#125;.&#123;namespace&#125;:&#123;servicePort&#125;</code></p>\n<figure>\n<img src=\"/images/k8s/image-20220407014230058.png\" alt=\"image-20220407014230058\">\n<figcaption aria-hidden=\"true\">image-20220407014230058</figcaption>\n</figure>\n<p>由于namespace为default，故可以省略；其他namespace不可省略</p>\n<figure>\n<img src=\"/images/k8s/image-20220407014908696.png\" alt=\"image-20220407014908696\">\n<figcaption aria-hidden=\"true\">image-20220407014908696</figcaption>\n</figure>\n<p>nginx-svc.default.svc.cluster.local为完整域名</p>\n<p>这样，服务B访问A，通过A的serviceName就可以了，即使重新创建A的Service，也不需要修改B的配置</p>\n<h4 id=\"集群外部访问nginx服务\">集群外部访问nginx服务</h4>\n<blockquote>\n<p>外部用户如何访问nginx？</p>\n</blockquote>\n<h4 id=\"nodeport\">NodePort</h4>\n<p>Service绑定Cluster节点的静态端口对外提供服务，Cluster外部通过<code>&#123;NodeIP&#125;:&#123;NodePort&#125;</code>，如<code>master:31090</code>，<code>node1:31090</code></p>\n<p>如何将{NodeIP}:{NodePort}映射到Pod的？</p>\n<figure>\n<img src=\"/images/k8s/image-20220407020203297.png\" alt=\"image-20220407020203297\">\n<figcaption aria-hidden=\"true\">image-20220407020203297</figcaption>\n</figure>\n<p>使用iptabels，上面两条规则：当访问31090端口的请求转发到规则<strong>KUBE-SVC-HL5LMXD5JFHQZ6LN</strong></p>\n<figure>\n<img src=\"/images/k8s/image-20220407020414875.png\" alt=\"image-20220407020414875\">\n<figcaption aria-hidden=\"true\">image-20220407020414875</figcaption>\n</figure>\n<p><strong>KUBE-SVC-HL5LMXD5JFHQZ6LN</strong> 对Pod进行负载均衡</p>\n<h3 id=\"相关指令\">相关指令</h3>\n<table>\n<colgroup>\n<col style=\"width: 29%\">\n<col style=\"width: 70%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>动作</th>\n<th>指令</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>查看nginx的pods</td>\n<td><code>kubectl get pods -n namespace</code></td>\n</tr>\n<tr class=\"even\">\n<td>查看发布的deployment详情</td>\n<td><code>kubectl describe deployment nginx -n namespace</code></td>\n</tr>\n<tr class=\"odd\">\n<td>查看pod详情</td>\n<td><code>kubectl describe pod &#123;pod_name&#125; -n namespace</code></td>\n</tr>\n<tr class=\"even\">\n<td>删除pod</td>\n<td><code>kubectl delete -n default pod nginx-deployment</code></td>\n</tr>\n<tr class=\"odd\">\n<td>查询服务列表</td>\n<td><code>kubectl get services -n namespace</code></td>\n</tr>\n<tr class=\"even\">\n<td>查询服务详情</td>\n<td><code>kubectl describe service &#123;deployment-name&#125; -n namespace</code></td>\n</tr>\n<tr class=\"odd\">\n<td>删除一个service服务</td>\n<td><code>kubectl delete services &#123;deployment-name&#125; -n namespace</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"存在问题\">存在问题</h2>\n<ol type=\"1\">\n<li>挂载的路径和文件需要提前创建在宿主机，集群下无法确定在哪台机器上部署，不方便提前创建，如何解决？</li>\n<li>访问集群中的任意节点都按照相同的iptables进行转发到某个Pod，即访问每个节点都有负载均衡的效果，那外部域名应该绑定哪个节点ip呢？还是通过一个nginx对Cluster中的节点做分发（防止节点挂机，不是做负载均衡）</li>\n</ol>\n","categories":["k8s"],"tags":["k8s"]},{"title":"k8s-Helm","url":"/2022/04/21/k8s/helm/","content":"<p>背景：为什么要使用Helm，Helm解决了什么问题？</p>\n<span id=\"more\"></span>\n<p>在之前的例子中，可以看到部署一个应用，需要写很多yaml配置（deployment,\nservice, pv, pvc, secret,\nconfigmap），将这些配置保存到各自的文件中，或集中写进一个配置中，然后通过<code>kubectl apply -f .</code>部署。当应用多了起来，这种组织形式会带来以下问题：</p>\n<ol type=\"1\">\n<li>管理维护复杂</li>\n<li>无法将这些服务作为一个整体统一发布</li>\n<li>不能高效的共享和重用服务</li>\n<li>不支持应用级别的版本管理</li>\n<li>不支持对部署的应用状态进行验证</li>\n</ol>\n<p>（待补充）</p>\n<p>Helm的引入，就是为了解决这些问题</p>\n<ul>\n<li>使用Helm可以把这些YAML文件作为整体管理</li>\n<li>实现YAML文件高效复用</li>\n<li>使用helm应用级别的版本管理</li>\n</ul>\n<h2 id=\"helm架构\">Helm架构</h2>\n<h3 id=\"chart\">chart</h3>\n<p>chart是一个应用的信息集合，包括各种k8s对象的配置模板、参数定义、依赖关系、文档说明等；chart是应用部署的逻辑单元</p>\n<p>helm可以创建新的chart，或与存储chart的仓库交互、拉取、保存、更新chart</p>\n<h3 id=\"release\">release</h3>\n<p>release是chart的运行实例（应用），helm可以在k8s集群中安装、卸载、测试、更新、回滚release</p>\n<h3 id=\"架构\">架构</h3>\n<p>Helm采用客户端/服务端架构，组件如下</p>\n<ul>\n<li>Helm Client：客户端，在本地执行，用来：\n<ul>\n<li>本地开发chart</li>\n<li>管理chart仓库</li>\n<li>与Tiller服务器交互</li>\n<li>查看release信息</li>\n</ul></li>\n<li>Tiller：服务器端，在Kubernetes集群上运行，管理应用，用来：\n<ul>\n<li>与Helm客户端交互</li>\n<li>通过chart构建release</li>\n<li>通过 k8s API Server管理release</li>\n</ul></li>\n<li>Repository：Chart仓库，Helm客户端通过HTTP协议访问仓库中Chart索引文件和压缩包</li>\n</ul>\n<figure>\n<img src=\"/images/k8s/2135285-20211031143343404-1708578702.png\" alt=\"image-20201118171523403\">\n<figcaption aria-hidden=\"true\">image-20201118171523403</figcaption>\n</figure>\n<figure>\n<img src=\"/images/k8s/2135285-20211031143343065-1576414767.png\" alt=\"image-20201118171956054\">\n<figcaption aria-hidden=\"true\">image-20201118171956054</figcaption>\n</figure>\n<p>Think: Why remove tiller in V3？</p>\n<h2 id=\"部署helm\">部署Helm</h2>\n<h3 id=\"部署helm-client\">部署Helm Client</h3>\n<p><a href=\"https://helm.sh/docs/intro/quickstart/\">helm官网</a>\n下载安装包，解压，拷贝到/usr/bin目录下</p>\n<p><code>helm repo add bitnami https://charts.bitnami.com/bitnami</code></p>\n<h3 id=\"部署tiller-server\">部署Tiller Server</h3>\n<h2 id=\"使用helm\">使用Helm</h2>\n<p><a href=\"https://helm.sh/zh/docs/intro/using_helm/\">使用helm</a></p>\n<h3 id=\"chart目录结构\">chart目录结构</h3>\n<h3 id=\"chat模板\">chat模板</h3>\n<h3 id=\"开发chart\">开发chart</h3>\n<h3 id=\"实践安装wordpress\">实践：安装wordpress</h3>\n<h4 id=\"搜索wordpress-helm包\">搜索wordpress helm包</h4>\n<p><code>helm search repo wordpress</code></p>\n<figure>\n<img src=\"/images/image-20220417015525266.png\" alt=\"image-20220417015525266\">\n<figcaption aria-hidden=\"true\">image-20220417015525266</figcaption>\n</figure>\n<h4 id=\"执行安装命令\">执行安装命令</h4>\n<p><code>helm install happy-dog bitnami/wordpress</code></p>\n<figure>\n<img src=\"/images/image-20220417015525266.png\" alt=\"image-20220417033300848\">\n<figcaption aria-hidden=\"true\">image-20220417033300848</figcaption>\n</figure>\n<p><strong>遇到问题：无法创建pvc</strong></p>\n<figure>\n<img src=\"/images/k8s/image-20220417020330093.png\" alt=\"image-20220417020330093\">\n<figcaption aria-hidden=\"true\">image-20220417020330093</figcaption>\n</figure>\n<figure>\n<img src=\"/images/k8s/image-20220417020354987.png\" alt=\"image-20220417020354987\">\n<figcaption aria-hidden=\"true\">image-20220417020354987</figcaption>\n</figure>\n<p>猜测原因：chart中使用了动态pvc，但k8s集群没有安装动态pvc</p>\n<p>尝试安装动态pvc：</p>\n<p><code>helm install nfs-client-provisioner stable/nfs-client-provisioner --set nfs.server=node1 --set nfs.path=/home/work/nfs --set storageClass.defaultClass=true</code></p>\n<p>验证动态pv</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">cat</span> <span class=\"string\">&gt;</span> <span class=\"string\">test-pvc.yaml</span> <span class=\"string\">&lt;&lt;</span> <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">test-nfs-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">nfs-client</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n<p>pvc 状态为 pending</p>\n<figure>\n<img src=\"/images/k8s/image-20220417024141132.png\" alt=\"image-20220417024141132\">\n<figcaption aria-hidden=\"true\">image-20220417024141132</figcaption>\n</figure>\n<p>查看pvc描述 <code>kubectl describe pvc &#123;pvc-name&#125;</code></p>\n<p>查看 cluster.local/nfs-client-provisioner 日志</p>\n<figure>\n<img src=\"/images/k8s/image-20220417024322442.png\" alt=\"image-20220417024322442\">\n<figcaption aria-hidden=\"true\">image-20220417024322442</figcaption>\n</figure>\n<p>问题原因：k8s V1.20中移除了SelfLink\nhttps://github.com/kubernetes/enhancements/issues/1164</p>\n<p>解决方案 from\nhttps://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/pull/26#issuecomment-743745469\n覆盖 nfs-client-provisioner 的image，使用支持k8s 1.20版本的镜像：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">image:</span></span><br><span class=\"line\">  <span class=\"attr\">repository:</span> <span class=\"string\">rkevin/nfs-subdir-external-provisioner</span></span><br><span class=\"line\">  <span class=\"attr\">tag:</span> <span class=\"string\">fix-k8s-1.20</span></span><br></pre></td></tr></table></figure>\n<p><code>helm show values stable/nfs-client-provisioner</code></p>\n<p>替换方式使用<code>--set</code>（先uninstall）</p>\n<p><code>helm install nfs-client-provisioner stable/nfs-client-provisioner --set nfs.server=node1 --set nfs.path=/home/work/nfs --set storageClass.defaultClass=true --set image.repository=rkevin/nfs-subdir-external-provisioner --set image.tag=fix-k8s-1.20</code></p>\n<p>或者使用<code>--values</code>或<code>helm install -f values.yaml bitnami/wordpress --generate-name</code>\n见 <a href=\"https://helm.sh/zh/docs/intro/using_helm/\">using\nhelm</a></p>\n<p>问题解决 :+1:</p>\n<p>总结：helm安装release时动态pvc，如果pv使用nfs，需要安装nfs-client-provisioner</p>\n<h4 id=\"访问wordpress服务\">访问wordpress服务</h4>\n<p>查看service</p>\n<figure>\n<img src=\"/images/k8s/image-20220417033358303.png\" alt=\"image-20220417033358303\">\n<figcaption aria-hidden=\"true\">image-20220417033358303</figcaption>\n</figure>\n<p>在浏览器输入<code>master:32386</code>访问</p>\n<h3 id=\"实践自己创建chart包安装应用\">实践：自己创建chart包安装应用</h3>\n<h2 id=\"遇到问题\">遇到问题</h2>\n<ol type=\"1\">\n<li>在V3中为什么去掉了tiller模块？</li>\n<li>self-link 是什么，为什么要在v1.20中去掉</li>\n</ol>\n","categories":["k8s"],"tags":["k8s"]},{"title":"k8s-数据管理","url":"/2022/04/10/k8s/file-storage/","content":"<blockquote>\n<p>由于容器和Pod是短暂的，会被频繁销毁和创建，容器销毁时，内部的文件系统也会被清理。为了持久化保存容器的数据，可以使用Kubernates\nVolume</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"emptydir-volume\">emptyDir Volume</h3>\n<p>emptyDir是Host上的一个空目录，对于容器是持久化的，对于Pod不是。emptyDir\nVolume的生命周期与Pod一致</p>\n<p>适用场景：</p>\n<ol type=\"1\">\n<li><p>Pod中的容器需要通过文件传递数据</p></li>\n<li><p>Pod中的容器临时共享存储空间</p></li>\n</ol>\n<h3 id=\"hostpath-volume\">hostPath Volume</h3>\n<p>hostPath\nVolume将Host文件系统中已有的目录mount给Pod的容器，这样会将Pod与节点耦合，限制了Pod的创建</p>\n<p>适用场景：需要访问kubernetes或docker内部数据（配置文件或二进制文件）的应用</p>\n<h3 id=\"云存储\">云存储</h3>\n<p>如Elastic Block Store</p>\n<h3 id=\"pvpvc\">PV&amp;PVC</h3>\n<p>Persistent\nVolume（PV）是外部存储系统中的一块空间，由管理员创建和维护。具有持久性，生命周期独立于Pod</p>\n<p>Persistent Volume\nClaim（PVC）是对PV的申请，由普通账号创建和维护，需要为Pod分配存储资源时，用户创建一个PVC，指明存储资源的小大和访问权限等信息</p>\n<p>k8s支持的PV类型有：EBS，Ceph，NFS等</p>\n<p>Think：为什么不直接为Pod创建云存储空间，而是通过PV-PVC</p>\n<h4 id=\"nfs\">NFS</h4>\n<p>NFS（network file\nsystem）通过网络，使不同的机器不同的系统实现文件共享。NFS客户端可以将NFS服务器共享的目录挂载到本地的文件系统中，访问目录如同访问本地目录一样</p>\n<h5 id=\"创建nfs服务器\">创建NFS服务器</h5>\n<blockquote>\n<p>在node1节点安装nfs服务</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">安装nfs服务组件</span></span><br><span class=\"line\">yum install nfs-utils -y</span><br><span class=\"line\">mkdir /home/work/nfs</span><br><span class=\"line\">cat &gt; /etc/exports &lt;&lt;EOF</span><br><span class=\"line\">/home/work/nfs 192.168.174.0/24(rw,sync,no_root_squash)</span><br><span class=\"line\">EOF</span><br><span class=\"line\">systemctl start rpcbind</span><br><span class=\"line\">systemctl start nfs</span><br><span class=\"line\">cd /etc</span><br><span class=\"line\">exportfs -r</span><br><span class=\"line\">netstat -ntlp</span><br></pre></td></tr></table></figure>\n<h5 id=\"客户端配置\">客户端配置</h5>\n<p>搜索网络中可用的共享目录 <code>showmount -e node1</code></p>\n<p>创建本地目录并挂载共享目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /home/work/mnt</span><br><span class=\"line\">mount -t nfs node1:/home/work/nfs /home/work/mnt</span><br><span class=\"line\">cd /home/work/mnt &amp;&amp; ll</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建pv\">创建PV</h4>\n<p>编写配置文件 nfs-pv1.yml，手动创建PV的方式叫静态供给</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">pv-nginx-html</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">    <span class=\"attr\">capacity:</span></span><br><span class=\"line\">        <span class=\"attr\">storage:</span> <span class=\"string\">2Gi</span></span><br><span class=\"line\">    <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span></span><br><span class=\"line\">    <span class=\"attr\">persistentVolumeReclaimPolicy:</span> <span class=\"string\">Retain</span></span><br><span class=\"line\">    <span class=\"attr\">storageClassName:</span> <span class=\"string\">nginx-html</span></span><br><span class=\"line\">    <span class=\"attr\">nfs:</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/home/work/nfs/nginx/html</span></span><br><span class=\"line\">        <span class=\"attr\">server:</span> <span class=\"string\">node1</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">pv-nginx-log</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">    <span class=\"attr\">capacity:</span></span><br><span class=\"line\">        <span class=\"attr\">storage:</span> <span class=\"string\">2Gi</span></span><br><span class=\"line\">    <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span></span><br><span class=\"line\">    <span class=\"attr\">persistentVolumeReclaimPolicy:</span> <span class=\"string\">Retain</span></span><br><span class=\"line\">    <span class=\"attr\">storageClassName:</span> <span class=\"string\">nginx-log</span></span><br><span class=\"line\">    <span class=\"attr\">nfs:</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/home/work/nfs/nginx/log</span></span><br><span class=\"line\">        <span class=\"attr\">server:</span> <span class=\"string\">node1</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">pv-nginx-conf</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">    <span class=\"attr\">capacity:</span></span><br><span class=\"line\">        <span class=\"attr\">storage:</span> <span class=\"string\">2Gi</span></span><br><span class=\"line\">    <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span></span><br><span class=\"line\">    <span class=\"attr\">persistentVolumeReclaimPolicy:</span> <span class=\"string\">Retain</span></span><br><span class=\"line\">    <span class=\"attr\">storageClassName:</span> <span class=\"string\">nginx-conf</span></span><br><span class=\"line\">    <span class=\"attr\">nfs:</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/home/work/nfs/nginx/conf</span></span><br><span class=\"line\">        <span class=\"attr\">server:</span> <span class=\"string\">node1</span></span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ol type=\"1\">\n<li>capacity指定PV容量</li>\n<li>accessModes 指定访问模式：\n<ol type=\"1\">\n<li>ReadWriteOnce：可读可写，只支持被单个节点挂载</li>\n<li>ReadOnlyMany：只读，可被多个节点挂载</li>\n<li>ReadWriteMany：可读可写，被多个节点挂载</li>\n</ol></li>\n<li>persistentVolumeReclaimPolicy 指定PV的回收策略：\n<ol type=\"1\">\n<li>Retain：管理员手动清理</li>\n<li>Recycle：删除数据（NFS和HostPath支持）</li>\n<li>Delete：删除存储资源（EBS等云存储支持）</li>\n</ol></li>\n<li>storageClassName 指定PV的类型为nfs</li>\n<li>nfs的path需要是nfs服务器是存在的路径</li>\n</ol>\n<p>创建pv1：<code>Kubectl apply -f nfs-pv1.yml</code></p>\n<p>查看pv：<code>kubectl get pv</code></p>\n<h4 id=\"创建pvc\">创建pvc</h4>\n<p>编写配置文件 nfs-pvc1.yml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">nginx-html-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">    <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span></span><br><span class=\"line\">    <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">requests:</span></span><br><span class=\"line\">            <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">    <span class=\"attr\">storageClassName:</span> <span class=\"string\">nginx-html</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">nginx-conf-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">    <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span></span><br><span class=\"line\">    <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">requests:</span></span><br><span class=\"line\">            <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">    <span class=\"attr\">storageClassName:</span> <span class=\"string\">nginx-conf</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">nginx-log-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">    <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span></span><br><span class=\"line\">    <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">requests:</span></span><br><span class=\"line\">            <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\">    <span class=\"attr\">storageClassName:</span> <span class=\"string\">nginx-log</span></span><br></pre></td></tr></table></figure>\n<p>创建pvc：<code>kubectl apply -f nfs-pvc1.yml</code></p>\n<p>查看pvc：<code>kubectl get pvc</code></p>\n<h4 id=\"在pod中使用存储\">在Pod中使用存储</h4>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">nginx-deployment</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.7.9</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">        <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx-log</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/var/log/nginx</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx-html</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/nginx/html</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx-conf-d</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/nginx/conf.d</span></span><br><span class=\"line\">      <span class=\"attr\">tolerations:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">&quot;key&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">operator:</span> <span class=\"string\">&quot;Equal&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">value:</span> <span class=\"string\">&quot;nginx&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">effect:</span> <span class=\"string\">&quot;NoSchedule&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx-log</span></span><br><span class=\"line\">        <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">          <span class=\"attr\">claimName:</span> <span class=\"string\">nginx-log-pvc</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx-html</span></span><br><span class=\"line\">        <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">          <span class=\"attr\">claimName:</span> <span class=\"string\">nginx-html-pvc</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nginx-conf-d</span></span><br><span class=\"line\">        <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">          <span class=\"attr\">claimName:</span> <span class=\"string\">nginx-conf-pvc</span></span><br></pre></td></tr></table></figure>\n<p>这样，将容器内nginx的html、conf、log挂载到nfs服务器上，方便编写页面、修改配置、查看日志</p>\n<p>Think：多个应用要挂载路径可能很多，需要创建很多的PV和PVC，管理很不方便，而且PV一般由管理员创建，PVC由开发人员创建，如果每个挂载路径都要要求管理员创建PV，效率低下，不便于管理，该如何解决</p>\n<p>Think：在nfs中修改nginx配置文件后，需要重启Pod才可以让配置生效，如果让Pod按照顺序先后重启，而不是全部同时重启</p>\n<h4 id=\"回收pv\">回收PV</h4>\n<p><code>kubectl delete pvc &#123;pvc_name&#125;</code></p>\n<h4 id=\"pv-动态供给\">PV 动态供给</h4>\n<p>静态供给的缺点有：</p>\n<ol type=\"1\">\n<li>需要提前创建PV，还需要在nfs等共享存储上提前创建目录，管理员的工作增加，效率低；</li>\n<li>维护成本高</li>\n</ol>\n<p>为了解决上面的问题，使用动态共给</p>\n<p>https://kubernetes.io/docs/concepts/storage/storage-classes/#nfs</p>\n<h5 id=\"安装动态pv\">安装动态pv</h5>\n<p>使用helm安装nfs-client-provisioner：<code>helm install nfs-client-provisioner stable/nfs-client-provisioner --set nfs.server=node1 --set nfs.path=/home/work/nfs --set storageClass.defaultClass=true --set image.repository=rkevin/nfs-subdir-external-provisioner --set image.tag=fix-k8s-1.20</code></p>\n<h5 id=\"验证\">验证</h5>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">cat</span> <span class=\"string\">&gt;</span> <span class=\"string\">test-pvc.yaml</span> <span class=\"string\">&lt;&lt;</span> <span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">test-nfs-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">nfs-client</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">1Gi</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br></pre></td></tr></table></figure>\n<figure>\n<img src=\"/images/k8s/image-20220417035033623.png\" alt=\"image-20220417035033623\">\n<figcaption aria-hidden=\"true\">image-20220417035033623</figcaption>\n</figure>\n<figure>\n<img src=\"/images/k8s/image-20220417035117442.png\" alt=\"image-20220417035117442\">\n<figcaption aria-hidden=\"true\">image-20220417035117442</figcaption>\n</figure>\n<figure>\n<img src=\"/images/k8s/image-20220417035331218.png\" alt=\"image-20220417035331218\">\n<figcaption aria-hidden=\"true\">image-20220417035331218</figcaption>\n</figure>\n<p>无需手动创建pv</p>\n<h3 id=\"存在问题\">存在问题</h3>\n<ol type=\"1\">\n<li>为什么不直接为Pod创建云存储空间，而是通过PV-PVC（创建的云存储空间是一次性创建很大一块空间，应用是很多的，每个应用都挂载到一个独立的云存储空间不利于管理和维护，容易造成空间的浪费）</li>\n<li>挂载路径太多，PV&amp;PVC不便于管理，如何解决（答案：PV的动态供给）</li>\n<li>重启nginx服务，如何不全部同时重启，防止服务不可用</li>\n</ol>\n","categories":["k8s"],"tags":["k8s"]},{"title":"k8s-安装kube-admin","url":"/2022/04/04/k8s/kubeadmin-install/","content":"<h2 id=\"环境\">环境</h2>\n<table>\n<thead>\n<tr class=\"header\">\n<th>机器名</th>\n<th>系统</th>\n<th>ip</th>\n<th>资源</th>\n<th>hostname</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>master</td>\n<td>Centos7</td>\n<td>192.168.174.100</td>\n<td>内存=4G</td>\n<td>master</td>\n</tr>\n<tr class=\"even\">\n<td>node1</td>\n<td>Centos7</td>\n<td>192.168.174.101</td>\n<td>内存=4G</td>\n<td>node1</td>\n</tr>\n<tr class=\"odd\">\n<td>node2</td>\n<td>Centos7</td>\n<td>192.168.174.102</td>\n<td>内存=4G</td>\n<td>node2</td>\n</tr>\n</tbody>\n</table>\n<span id=\"more\"></span>\n<p>执行脚本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">时区 与 主机名</span></span><br><span class=\"line\">timedatectl set-timezone Asia/Shanghai</span><br><span class=\"line\">hostnamectl set-hostname master</span><br><span class=\"line\">hostnamectl set-hostname node1   </span><br><span class=\"line\">hostnamectl set-hostname node2    </span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">hosts网络主机配置</span></span><br><span class=\"line\">echo &quot;192.168.174.100 master&quot; &gt;&gt; /etc/hosts</span><br><span class=\"line\">echo &quot;192.168.174.101 node1&quot; &gt;&gt; /etc/hosts</span><br><span class=\"line\">echo &quot;192.168.174.102 node2&quot; &gt;&gt; /etc/hosts</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">关闭防火墙</span></span><br><span class=\"line\">sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config</span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\">systemctl disable firewalld</span><br><span class=\"line\">systemctl stop firewalld</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装docker\">安装Docker</h2>\n<p>准备</p>\n<p>启动docker</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure>\n<p>关闭swap</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">swapoff -a</span><br><span class=\"line\">vim /etc/fstab</span><br><span class=\"line\">注释最后一行</span><br></pre></td></tr></table></figure>\n<p>配置内核转发参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class=\"line\">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class=\"line\">net.bridge.bridge-nf-call-iptables=1</span><br><span class=\"line\">EOF</span><br><span class=\"line\">modprobe br_netfilter</span><br><span class=\"line\">echo 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptables</span><br></pre></td></tr></table></figure>\n<p>配置安装源</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; E0F</span><br><span class=\"line\">[kubernetes]</span><br><span class=\"line\">name=Kubernetes</span><br><span class=\"line\">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\">repo_gpgcheck=0</span><br><span class=\"line\">EOF</span><br><span class=\"line\">yum check-update</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装kube-admin\">安装kube-admin</h2>\n<h3 id=\"master节点\">master节点</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">安装kubeadm</span></span><br><span class=\"line\">yum -y install kubectl-1.20.6 kubelet-1.20.6 kubeadm-1.20.6</span><br><span class=\"line\">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">主节点初始化</span></span><br><span class=\"line\">kubeadm init --kubernetes-version=1.20.6 \\</span><br><span class=\"line\">--apiserver-advertise-address=192.168.174.100 \\</span><br><span class=\"line\">--image-repository=registry.aliyuncs.com/google_containers \\</span><br><span class=\"line\">--service-cidr=192.168.31.0/24 \\</span><br><span class=\"line\">--pod-network-cidr=172.31.0.0/16</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">上面指令执行后，会生成计算节点加入集群的命令，复制到文件</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">kubeadm <span class=\"built_in\">join</span> 192.168.174.100:6443 --token onrw0v.fbr49ehr2i5yb3dk \\</span></span><br><span class=\"line\"><span class=\"language-bash\"><span class=\"comment\">#  --discovery-token-ca-cert-hash sha256:5587d91e7c33e597f2a199d7f7ec27dc4d6a586e37d7b28dbde33c8f698812ba</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">mkdir -p $HOME/.kube</span><br><span class=\"line\">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class=\"line\">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>\n<p>注：apiserver-advertise-address 为主节点ip地址</p>\n<figure>\n<img src=\"/images/k8s/image-20220312094835198.png\" alt=\"image-20220312094835198\">\n<figcaption aria-hidden=\"true\">image-20220312094835198</figcaption>\n</figure>\n<h3 id=\"计算节点\">计算节点</h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">安装 kubelet, kubeadm</span></span><br><span class=\"line\">yum -y install kubelet-1.20.6 kubeadm-1.20.6</span><br><span class=\"line\">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">将计算节点添加到k8s集群中</span></span><br><span class=\"line\">kubeadm join 192.168.174.100:6443 --token onrw0v.fbr49ehr2i5yb3dk \\</span><br><span class=\"line\">    --discovery-token-ca-cert-hash sha256:5587d91e7c33e597f2a199d7f7ec27dc4d6a586e37d7b28dbde33c8f698812ba</span><br></pre></td></tr></table></figure>\n<h3 id=\"部署calico网络插件\">部署calico网络插件</h3>\n<p>作用：容器跨宿主机通讯</p>\n<p>主节点：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p $HOME/app/kube/yaml &amp;&amp; cd $HOME/app/kube/yaml</span><br><span class=\"line\">wget https://docs.projectcalico.org/manifests/calico.yaml</span><br><span class=\"line\">kubectl create -f calico.yaml</span><br></pre></td></tr></table></figure>\n<h3 id=\"部署dashboard\">部署dashboard</h3>\n<h4 id=\"下载dashboard安装yaml文件\">下载dashboard安装yaml文件</h4>\n<p><code>wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml</code></p>\n<h4 id=\"修改yaml文件令以nodeport方式访问dashboard指定dashboard安装在master节点上\">修改yaml文件，令以NodePort方式访问dashboard，指定dashboard安装在master节点上</h4>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改 recommended.yaml </span></span><br><span class=\"line\"><span class=\"comment\"># 第40行-44行</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">NodePort</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">      <span class=\"attr\">targetPort:</span> <span class=\"number\">8443</span></span><br><span class=\"line\">      <span class=\"attr\">nodePort:</span> <span class=\"number\">30000</span></span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">revisionHistoryLimit:</span> <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">k8s-app:</span> <span class=\"string\">kubernetes-dashboard</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">k8s-app:</span> <span class=\"string\">kubernetes-dashboard</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\"># 设置在master节点启动</span></span><br><span class=\"line\">      <span class=\"attr\">nodeName:</span> <span class=\"string\">master</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">kubernetes-dashboard</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">kubernetesui/dashboard:v2.1.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">k8s-app:</span> <span class=\"string\">dashboard-metrics-scraper</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">dashboard-metrics-scraper</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kubernetes-dashboard</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">revisionHistoryLimit:</span> <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">k8s-app:</span> <span class=\"string\">dashboard-metrics-scraper</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">k8s-app:</span> <span class=\"string\">dashboard-metrics-scraper</span></span><br><span class=\"line\">      <span class=\"attr\">annotations:</span></span><br><span class=\"line\">        <span class=\"attr\">seccomp.security.alpha.kubernetes.io/pod:</span> <span class=\"string\">&#x27;runtime/default&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"comment\"># 设置在master节点启动</span></span><br><span class=\"line\">      <span class=\"attr\">nodeName:</span> <span class=\"string\">master</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">dashboard-metrics-scraper</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">kubernetesui/metrics-scraper:v1.0.6</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建dashboard应用\">创建dashboard应用</h4>\n<p>kubectl apply -f recommended.yaml</p>\n<h4 id=\"创建admin账号\">创建admin账号</h4>\n<blockquote>\n<p>dashboard默认的账号无权限管理其他namespace下的资源，故为集群创建admin账号</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ServiceAccount</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kubernetes-dashboard</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">rbac.authorization.k8s.io/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ClusterRoleBinding</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span></span><br><span class=\"line\"><span class=\"attr\">roleRef:</span></span><br><span class=\"line\">  <span class=\"attr\">apiGroup:</span> <span class=\"string\">rbac.authorization.k8s.io</span></span><br><span class=\"line\">  <span class=\"attr\">kind:</span> <span class=\"string\">ClusterRole</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">cluster-admin</span></span><br><span class=\"line\"><span class=\"attr\">subjects:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">kind:</span> <span class=\"string\">ServiceAccount</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">admin-user</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"生成token\">生成token</h4>\n<p><code>kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=\"&#123;.secrets[0].name&#125;\") -o go-template=\"&#123;&#123;.data.token | base64decode&#125;&#125;\"</code></p>\n<h4 id=\"访问dashboard\">访问dashboard</h4>\n<p>https://master:30000 粘贴上面生成的token</p>\n<h2 id=\"遇到问题\">遇到问题</h2>\n<h3 id=\"无法访问dashboard地址master30000\">无法访问dashboard地址master:30000</h3>\n<p>原因：master节点eth0网卡未转发虚拟网卡的数据包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &gt; /etc/sysctl.d/99-ipv4_forward.conf &lt;&lt;EOF</span><br><span class=\"line\">net.ipv4.ip_forward=1</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">sysctl --load=/etc/sysctl.d/99-ipv4_forward.conf</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">或重启网络服务：systemctl restart network</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"dashboard日志报错\">dashboard日志报错</h3>\n<p>部署metrics-server应用</p>\n<h2 id=\"references\">References</h2>\n","categories":["k8s"],"tags":["k8s"]},{"title":"kafka 运行机制","url":"/2023/05/27/kafka/kafka-theory/","content":"<blockquote>\n<p>本文介绍 kafka 相关运行机制，主要包括：</p>\n<ol type=\"1\">\n<li>分区策略</li>\n<li>消息压缩算法</li>\n<li>Kafka 通信方式</li>\n<li>消费者组相关机制</li>\n</ol>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"分区策略\">分区策略</h2>\n<p>kafka的分区机制提供了负载均衡的能力，实现了系统的可伸缩性</p>\n<p>我们希望生产者将消息均匀的分发到每个分区中，分区策略有：</p>\n<ul>\n<li>轮询策略</li>\n<li>随机策略</li>\n<li>按消息键保序策略</li>\n</ul>\n<h2 id=\"消息压缩算法\">消息压缩算法</h2>\n<p>希望以极小的CPU开销带来更少的磁盘占用或更少的网络I/O传输</p>\n<p>Q1：什么时候进行压缩？</p>\n<p>A1：生产者 或 Broker</p>\n<blockquote>\n<p>Broker 压缩的情况：</p>\n<ol type=\"1\">\n<li>Producer压缩消息后，发送到Broker，如果Broker指定了压缩算法，且与Producer的算法不同，则会解压后重新压缩；</li>\n<li>Broker 端发生了消息格式的转换，比如 Broker\n发现有旧版本的消息，需要解压转换为新版本格式，再压缩</li>\n</ol>\n<p>Broker\n压缩会影响性能，应该尽量避免由于压缩算法设置不一致，或消息版本不一致导致的重复压缩</p>\n</blockquote>\n<p>Q2：什么时候进行解压？</p>\n<p>A2：Broker 或 消费者</p>\n<blockquote>\n<p>除了上面提到的 Broker 压缩前需要解压外，每个压缩过的消息在 Broker\n端都会解压，对消息执行各种校验；</p>\n<p>Think：Broker\n具体校验哪些方面呢，能否可以在不解压的情况下校验呢？</p>\n</blockquote>\n<p>有哪些压缩算法？</p>\n<ul>\n<li>GZIP</li>\n<li>Snappy</li>\n<li>LZ4</li>\n<li>Zstandard（zstd）</li>\n</ul>\n<p>四种压缩算法的比较：</p>\n<ul>\n<li>压缩比：zstd &gt; lz4 &gt; gzip &gt; snappy</li>\n<li>吞吐量：lz4 &gt; snappy &gt; zstd 和 gzip</li>\n</ul>\n<p>即：如果希望节省网络带宽，则使用 zstd；如果追求速度，则使用lz4</p>\n<h2 id=\"如何防止-kafka-消息丢失\">如何防止 kafka 消息丢失</h2>\n<p>可能导致消息丢失的场景：</p>\n<ol type=\"1\">\n<li>生产者端丢失：发送过程中由于网络问题、消息不合格等原因，且生产者未感知</li>\n<li>消费者端丢失：先更新offset，后消费消息，如果更新offset后消费消息的线程中断，则它负责的消息没有处理，但是\noffset 却更新了</li>\n</ol>\n<p>对于上述两种场景的解决方案是：</p>\n<ol type=\"1\">\n<li>生产者端：使用带有回调的 send\n方法，在回调中发现失败进行重试等处理</li>\n<li>消费者端：先消费，成功后再提交更新 offset</li>\n</ol>\n<p>防止消息丢失的最佳实践：</p>\n<ol type=\"1\">\n<li>【生产者端】使用 producer.send(msg, callback)</li>\n<li>【生产者端】设置 acks = all，表示全部 broker\n都收到消息，才认为是已提交</li>\n<li>【生产者端】设置 retries 为一个较大值，自动重试消息发送</li>\n<li>【Broker端】unclean.leader.election.enable =\nfalse，不允许一个落后原先 leader 太多的 broker 成为新的 leader</li>\n<li>【Broker端】设置 replication.factor &gt;= 3，将消息多保存几份</li>\n<li>【Broker端】设置 min.insync.replicas &gt; 1\n消息至少要被写入多少个副本才算是已提交</li>\n<li>【Broker端】确保 replication.factor &gt; min.insync.replicas，推荐\nreplication.factor = min.insync.replicas + 1</li>\n<li>【消费者端】消费成功后再提交</li>\n</ol>\n<h2 id=\"kafka-的通信方式\">Kafka 的通信方式</h2>\n<h3 id=\"生产者是如何和broker通信的\">生产者是如何和Broker通信的</h3>\n<p>通信协议：TCP</p>\n<p>什么时候建立连接：</p>\n<ol type=\"1\">\n<li>创建 producer 实例时，生产者应用会在后台创建一个线程，该线程会与\nbootstrap.server 参数中指定的所有 Broker 创建连接</li>\n<li>Producer 与 bootstrap.server 的 Broker 请求 kafka 集群\nMetadata，拿到集群的全部 Broker 后，Producer 会与未建立连接的 Broker\n建议连接，这样 Producer 就与集群中所有 Broker 都建立了连接</li>\n<li>Producer 在发送消息时，如果发现与目标 Broker\n未建立连接，会创建连接</li>\n</ol>\n<h2 id=\"消费者组\">消费者组</h2>\n<h3 id=\"消费者组的作用\">消费者组的作用</h3>\n<p>使消费者的水平扩展，提高消费能力</p>\n<h3 id=\"位移是如何管理的\">位移是如何管理的</h3>\n<p>不同的版本位移的管理是不同的</p>\n<p>2.8.0 之前：zookeeper</p>\n<p>2.8.0 之后：kafka 内部主题 <code>__consumer_offsets</code></p>\n<p><strong>位置放在 zookeeper 中存在的问题</strong>：zookeeper\n不适合频繁的写更新，大吞吐量的写操作会极大地拖慢 zooKeeper\n集群的性能</p>\n<p><strong>位移主题：</strong>保存消费者的位移信息，需要保证持久性和高吞吐量</p>\n<p><strong>consumer 如何提交位移：</strong></p>\n<ul>\n<li><p>自动提交</p>\n<p><strong>参数</strong>：</p>\n<p>enable.auto.commit = true</p>\n<p>auto.commit.interval.ms = 5000</p>\n<p><strong>执行流程</strong>：周期性的 poll（拉取）消息前，都提交上次\npoll 的位移</p>\n<p><strong>优缺点：</strong>可以保证消息不丢失，但可能重复消费</p>\n<p><strong>为什么会重复消费：</strong>在一个周期内发生重平衡，重平衡后再开始消费，由于本周期的位移没有提交，拿到的位移是本周期前的，导致重平衡前本周期消费的消息被重复消费</p></li>\n<li><p>手动-同步提交</p>\n<p>kafkaConsumer#commitSync()</p>\n<p><strong>优缺点：</strong>灵活可控，提交失败可以自动重试，但提交过程中会阻塞消费者进程，也有重复消费的问题（已消费未提交位移时重启、重平衡）</p></li>\n<li><p>手动-异步提交</p>\n<p>kafkaConsumer#commitAsync()</p>\n<p><strong>优缺点：</strong>灵活，异步提交，不阻塞消费进程，缺点是发现提交失败，也无法重试，因为重试提交的也不是最新的位移，只会导致重复消费</p></li>\n</ul>\n<p>综上，无论用哪种提交位移的方式，都会产生重复消费，所以需要消费者自己处理重复消费，如天然是幂等的，或去重</p>\n<h3 id=\"消费者重平衡\">消费者重平衡</h3>\n<p>何时发生重平衡：</p>\n<ul>\n<li>消费者组成员数量发生变更</li>\n<li>订阅主题数发生变更</li>\n<li>订阅主题的分区数发生变更</li>\n</ul>\n<p>重平衡的影响：在重平衡过程中，组内所有实例都不能消费任何消息，影响了消费者的\nTPS</p>\n<h3 id=\"消费者线程\">消费者线程</h3>\n<p>从 0.10.1.0 版本开始，kafka consumer\n采用了用户主线程和心跳线程的双线程设计，是为了将心跳线程与主线程的 poll\n方法分开，防止因消费时间过长无法及时 poll 导致的重平衡</p>\n<p>在单节点上，消费线程是单线程。如果希望多线程消费，可以采用下面几种方案：</p>\n<ul>\n<li>方案一：启动多个消费者线程，即拉取消息又处理消息</li>\n<li>方案二：单（多）消费者线程负责拉取消息，多线程处理</li>\n</ul>\n<p>方案一就是在一个节点上启动了多个消费者，和启动多个消费者节点是一样的，所以启动的消费者数受限于主题分区数，如果启动了大于分区数的消费者，那么多启动的线程也是空闲的</p>\n<p>方案二将拉取消息与处理消息分开，如果拉取消息是多线程，与方案一相同，多线程处理消息可以提高消费速度，但是不能保证消息有序消费；多线程消费需要手动提交位移，需要感知到当前\npoll 的消息全部处理完</p>\n<h3 id=\"位移管理\">位移管理</h3>\n<p>消费者接入到一个 partition 后从哪个位置开始消费，与\n<code>auto.offset.reset</code> 有关：</p>\n<ul>\n<li>earliest：\n当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费</li>\n<li>latest：\n当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据</li>\n<li>nearlist：\n当各分区下有已提交的offset时，从提交的offset开始消费；如果小于\nbeginingOffset 从 earliest 开始，如果超过 endOffset 从 latest 开始</li>\n</ul>\n<figure>\n<img src=\"/images/kafka/offset.drawio.png\" alt=\"offset.drawio\">\n<figcaption aria-hidden=\"true\">offset.drawio</figcaption>\n</figure>\n<h3 id=\"消费者负载不均衡\">消费者负载不均衡</h3>\n<h2 id=\"消费模式\">消费模式</h2>\n<h3 id=\"顺序消费\">顺序消费</h3>\n<p>通过分配规则，对消息 key 计算出对应的 partition，发送到指定的\npartition 中</p>\n<p>Q：什么情况会破坏顺序消费？</p>\n<p>A：批量消费，没有去重，发生 Rebalance 时，可能破坏顺序</p>\n<p>比如批量 poll 了一批消息 [a1, a2, a3, a4, a5]，已经消费到\na4，还没有提交位移，这时发生了 rebalance，则 rebalance 后会重新消费 a1,\na2, a3, a4（不去重的情况），这时发生了先消费 a3，后消费 a1 的情况</p>\n<h3 id=\"延时消费\">延时消费</h3>\n<p>见延时消费</p>\n<h2 id=\"集群设置\">集群设置</h2>\n<h3 id=\"broker-负载均衡\">broker 负载均衡</h3>\n<h3 id=\"consumer-负载均衡\">consumer 负载均衡</h3>\n<h4 id=\"负载均衡策略rebalance-策略\">负载均衡策略（Rebalance 策略）</h4>\n<ul>\n<li><p>Range 算法</p>\n<ol type=\"1\">\n<li>对每个 topic 里面的分区按序号排序(P0, P1,\nP2,...)，对消费者按字母顺序排序（C0, C1, C2, ...）</li>\n<li>对每个 topic 都执行操作：将分片依次分配给消费者</li>\n</ol>\n<p>存在的问题：多个\ntopic，且分区大于消费者个数时，排序靠前的消费者会分配到更多的分区，比如有\nN 个 topic，每个 topic 的分区数都比消费者个数多一个，则 C0\n比其他消费者多分配 N 个分区</p></li>\n<li><p>RoundRobin 算法</p>\n<ol type=\"1\">\n<li>遍历主题列表，从每个主题获取其所有分区的列表，组成分区集合 P</li>\n<li>对 P\n中分区列表进行排序，首先按照主题名称，然后按照分区编号进行排序</li>\n<li>对消费者实例进行排序，保证分配过程中的顺序是确定的</li>\n<li>系统遍历P中的分区列表，从第一个消费者开始，依次分配一个分区，直至分配完列表中的所有分区</li>\n</ol>\n<p>存在问题：</p></li>\n<li><p>Sticky 算法</p>\n<p>目标：</p>\n<ol type=\"1\">\n<li>分区的分配要尽可能的均匀，分配给消费者者的主题分区数最多相差一个</li>\n<li>分区的分配尽可能的与上次分配的保持相同</li>\n</ol>\n<p>步骤：</p>\n<ol type=\"1\">\n<li>按照 RoundRobin 的方式分配</li>\n<li>发生重平衡时，将离线消费者的分区分配给在线消费者，保证分区差不超过1个</li>\n</ol></li>\n</ul>\n<h4 id=\"消费者组不均衡的场景\">消费者组不均衡的场景</h4>\n<ul>\n<li>场景1：消费者组订阅了多个topic，而 topic\n之间流量差异很大，默认的分配策略是不考虑 topic\n具体流量的，只会按分区数分配</li>\n<li>场景2：有一些内置 topic，如 RETRY_TOPIC，这些内置 topic\n平时流量很少，但也参与分配；这就可能导致一些实例上的消费者只分配了内置\ntopic 的分区，而一些实例上分配了正常 topic\n的分区，导致负载不均（与场景1其实是同一个问题）</li>\n</ul>\n<p>解决方案：</p>\n<ul>\n<li>场景1：给不同 topic 设置权重，按照权重分配</li>\n<li>场景2：给内置 topic 设置权重为0</li>\n</ul>\n<h4 id=\"服务实例分配分区不均衡的场景\">服务实例分配分区不均衡的场景</h4>\n<p>由于分区分配策略是在消费者组内部的，不会考虑其他消费者组已分配的分区，当服务实例在多个消费者组中，容易出现不均衡的现象，下面是可能发生的场景：</p>\n<ul>\n<li><p>场景1：使用 RoundRobin\n策略，3个实例（A，B，C），在2个消费组内，订阅2个Topic，各4个分区（P0-0,\nP0-1, P0-2, P0-3, P1-1, P1-2, P1-3, P1-4）</p>\n<p>分配后的结果为：A分配了P0-0,P0-3,P1-1, P1-4，\nB分配了P0-1,P1-2，C分配了P0-2,P1-3，可以发现A比B，C多分配了两个分区，如果在更多的消费组中，则这个问题会更严重</p></li>\n<li><p>场景2：使用 Sticky 策略，3个实例（A，B，C）同上</p>\n<p>先看一个消费组内，在启动服务的过程中，由于分配策略和服务启动先后有关，则一定有一个实例多分配了一个，在N个消费组的情况下，这个实例会被多分配N个分区（因为不同消费组的分配策略是一致的）</p></li>\n<li><p>场景3：使用任何一种策略，10个实例，在30个消费者组中，30个topic，每个topic4个分区</p>\n<p>分配后，肯定存在4个实例，被分配了30个分区，6个实例，分配0个分区</p></li>\n</ul>\n<h5 id=\"实验验证\">实验验证</h5>\n<p>只验证场景1,2，场景3同理</p>\n<p>3个Topic，每个 topic 4个分区，3个消费者组，每组3个消费者，client.id\n依次是 c1, c2, c3</p>\n<p>使用 RoundRobin 和 Sticky 策略，观察分区分配的结果</p>\n<p>RoundRobin策略</p>\n<table>\n<colgroup>\n<col style=\"width: 15%\">\n<col style=\"width: 56%\">\n<col style=\"width: 28%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>分配结果</th>\n<th>分区统计</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>第一个消费者上线</td>\n<td>所有分区都是C1</td>\n<td>C1：12个</td>\n</tr>\n<tr class=\"even\">\n<td>第二个消费者上线</td>\n<td>T0-P0,P2：C1<br>T0-P1,P3：C2<br>T1-P0,P2：C1<br>T1-P1,P3：C2<br>T2-P0,P2：C1<br>T2-P1,P3：C2</td>\n<td>C1：6个<br>C2：6个</td>\n</tr>\n<tr class=\"odd\">\n<td>第三个消费者上线</td>\n<td>T0-P0,P3：C1<br>T0-P1：C2<br>T0-P2：C3<br>T1-P0,P3：C1<br>T1-P1：C2<br>T1-P2：C3<br>T2-P0,P3：C1<br>T2-P1：C2<br>T2-P2：C3</td>\n<td>C1：6个<br>C2：3个<br>C3：3个</td>\n</tr>\n</tbody>\n</table>\n<p>Sticky 策略</p>\n<table>\n<colgroup>\n<col style=\"width: 15%\">\n<col style=\"width: 56%\">\n<col style=\"width: 28%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>分配结果</th>\n<th>分区统计</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>第一个消费者上线</td>\n<td>所有分区都是C1</td>\n<td>C1：12个</td>\n</tr>\n<tr class=\"even\">\n<td>第二个消费者上线</td>\n<td>T0-P0,P1：C1<br>T0-P2,P3：C2<br>T1-P0,P1：C1<br>T1-P2,P3：C2<br>T2-P0,P1：C1<br>T2-P2,P3：C2</td>\n<td>C1：6个<br>C2：6个</td>\n</tr>\n<tr class=\"odd\">\n<td>第三个消费者上线</td>\n<td>T0-P0,P1：C1<br>T0-P2：C2<br>T0-P3：C3<br>T1-P0,P1：C1<br>T1-P2：C2<br>T1-P3：C3<br>T2-P0,P1：C1<br>T2-P2：C2<br>T2-P3：C3</td>\n<td>C1：6个<br>C2：3个<br>C3：3个</td>\n</tr>\n</tbody>\n</table>\n<p>可以发现，在RoundRobin策略和Sticky策略中，C1比C2,C3多分配3个分区</p>\n<h4 id=\"解决方案\">解决方案</h4>\n<p>上面两个场景的本质是相同的，都是多消费者组分配分区执行结果一致，导致部分实例被多分配</p>\n<p>场景1：不同消费组对消费者排序后，机器的顺序是相同的，排序的算法对\nclient.id 的 hashCode 进行排序的，所以只要让同一实例上不同组内的消费者\nclient.id 不同，就可以避免这个问题</p>\n<p>场景2：Sticky分配策略与启动顺序有关，且消费者进程和服务启动是同步的，解决方案是将消费者进程的启动和实例的启动解耦，通过随机睡眠的方式，利用消费者进程启动的随机性，避免这个问题</p>\n<p>场景3：无论使用哪种策略，都要加入随机睡眠</p>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"https://blog.csdn.net/wypblog/article/details/108613306\">如何为Kafka集群选择合适的Topics/Partitions数量</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/439936732\">kafka的 groupid 与\nauto.offset.reset</a></p>\n<p><a href=\"https://www.jianshu.com/p/49ed596e9986\">Kafka\nNote（六）负载均衡机制</a></p>\n<p><a href=\"https://blog.csdn.net/lzb348110175/article/details/100773487\">kafka\n分区分配策略</a></p>\n<p><a href=\"https://www.zhihu.com/question/446316747/answer/2213525748\">kafka\n的几种分配策略</a></p>\n","tags":["kafka"]},{"title":"kafka 延时消息","url":"/2023/06/10/kafka/kafka-delay-queue/","content":"<blockquote>\n<p>本文介绍 kafka 的延时消息</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"延时发送\">延时发送</h2>\n<figure>\n<img src=\"/images/kafka/延时发送.drawio.png\" alt=\"延时发送.drawio\">\n<figcaption aria-hidden=\"true\">延时发送.drawio</figcaption>\n</figure>\n<p>实现原理：</p>\n<ol type=\"1\">\n<li>生产者发送到 __delay_topic</li>\n<li>延时监控服务定时查询 __delay_topic，判断是否达到业务方设置的\ndelayTime 时间戳，达到了将消息转发到业务 topic</li>\n<li>消费者消费业务 topic</li>\n</ol>\n<p>这个方案对延时发送时间的准确性取决于监控服务的查询频率，假设延时发送为10s，查询频率是\n5s 一次，则最大的误差为 4.999s，频率越高精度越高</p>\n<p>这个方案存在的问题有：</p>\n<ol type=\"1\">\n<li>占用更多磁盘空间：如果存在延时较长的消息，则需要延长所有消息的保存时间而无法清理，比如有延时10天和延时1小时的消息在一个__delay_topic中，只能保存10天以上</li>\n<li>不够灵活：一般消息的延时时间是由下游业务确定的，而延时发送需要生产者来控制</li>\n</ol>\n<p>上面问题的解决思路是，生产者将消息发送给消费者，由消费者控制延时时间，即延时消费</p>\n<h2 id=\"延时消费\">延时消费</h2>\n<figure>\n<img src=\"/images/kafka/延时消费-单topic.drawio.png\" alt=\"延时消费-单topic.drawio\">\n<figcaption aria-hidden=\"true\">延时消费-单topic.drawio</figcaption>\n</figure>\n<p>这个方案的好处是：</p>\n<ol type=\"1\">\n<li>生产者不需要关心延时时间，完全交给消费者去处理，不同业务根据自身需要去设置延时时间和过期清理时间</li>\n<li>生产者不再需要保存两份消息，且可自行设置合理的清理时间，缓解了生产者服务\nkafka 集群压力</li>\n</ol>\n<p>延时消费相比于延时发送，解决了生产者侧消息积压的问题，试想为了支持某个高延时的下游业务将清理时间调高，对集群的压力是非常大的，一旦崩溃会影响所有下游业务；同时，数据在生产者和消费者都只需要保存一份</p>\n<p>下面讨论消费者服务如何控制延时消费</p>\n<h2 id=\"延时监控服务如何设计\">延时监控服务如何设计</h2>\n<blockquote>\n<p>延时发送中的延时监控服务，和延时消费的消费者，是相同的思路</p>\n</blockquote>\n<p><strong>方案一 定时轮训</strong></p>\n<p>消费者每次poll一个消息，如果达不到延时时间，则不提交位移，并 sleep\n一段时间，实现周期性轮询</p>\n<p>这个方案轮询的时间要小于<code>max.poll.interval.ms</code>，否则会发生\nrebalance，存在问题：</p>\n<ol type=\"1\">\n<li>资源浪费：大量无效轮训消耗系统资源</li>\n<li>存在误差：假设设置轮训时间是\n500ms，那么延时的最大误差就是499.999ms</li>\n</ol>\n<p><strong>方案二 根据剩余时间等待</strong></p>\n<p>消费者每次 poll\n一个消息，如果达不到延时时间，则不提交位移，计算还需要等待的时间，sleep\n这段时间后再 poll</p>\n<p>这个方案避免了无效轮训，但是等待时间如何大于\n<code>max.poll.interval.ms</code>，会导致 rebalance，所以不能使用 sleep\n的方式等待</p>\n<p>kafka consumer提供了暂停消费的API，暂停消费后 broker 不会认为\nconsumer 挂掉，等待剩余时间后恢复消费，再拉取消息</p>\n<blockquote>\n<p>关于 <code>max.poll.interval.ms</code> 与\n<code>session.timeout.ms</code></p>\n<p><code>max.poll.interval.ms</code> ：如果 poll 在\n<code>max.poll.interval.ms</code>\n内没有被调用，心跳线程会检测到这种情况并发起离组请求，即消费者主动离开；\n<code>session.timeout.ms</code> ：在 0.10.1 版本之前，消费者是通过 poll\n请求与 broker 建立心跳，这样当消费处理时间较长时，就容易被 broker\n误认为断连，0.10.1 之后将心跳与处理解耦，由心跳线程单独向 broker\n发心跳包，如果心跳包间隔超过了 <code>session.timeout.ms</code>，则\nbroker 认为 consumer 断连</p>\n<p><code>max.poll.interval.ms</code> 触发的断连是消费者主动发起的，\n<code>session.timeout.ms</code>触发的断连是消费者被动的</p>\n</blockquote>\n<p>所以可不可以理解为，调用了 pause api，消费者心跳线程就不会因为 poll\n间隔超过了 <code>max.poll.interval.ms</code>\n而发出断连请求，下面进行代码演示</p>\n<p>生产者代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyProducer</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">TOPIC</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;beihai&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Properties</span> <span class=\"variable\">properties</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class=\"string\">&quot;127.0.0.1:9093,127.0.0.1:9094,127.0.0.1:9092&quot;</span>);</span><br><span class=\"line\">        properties.put(ProducerConfig.ACKS_CONFIG, <span class=\"string\">&quot;all&quot;</span>);</span><br><span class=\"line\">        properties.put(ProducerConfig.RETRIES_CONFIG, <span class=\"number\">0</span>);</span><br><span class=\"line\">        properties.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class=\"number\">16384</span>);</span><br><span class=\"line\">        properties.put(ProducerConfig.LINGER_MS_CONFIG, <span class=\"number\">1</span>);</span><br><span class=\"line\">        properties.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class=\"number\">33554432</span>);</span><br><span class=\"line\">        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class=\"line\">        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class=\"line\">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class=\"keyword\">new</span> <span class=\"title class_\">KafkaProducer</span>&lt;&gt;(properties);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            ProducerRecord&lt;String, String&gt; rec = <span class=\"keyword\">new</span> <span class=\"title class_\">ProducerRecord</span>&lt;&gt;(TOPIC, i % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? <span class=\"number\">0</span> : <span class=\"number\">1</span>, <span class=\"string\">&quot;key&quot;</span> + i,<span class=\"string\">&quot;message&quot;</span> + i);</span><br><span class=\"line\">            <span class=\"type\">RecordMetadata</span> <span class=\"variable\">metadata</span> <span class=\"operator\">=</span> kafkaProducer.send(rec).get();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;同步方式发送消息结果: &quot;</span> + <span class=\"string\">&quot;topic-&quot;</span> + metadata.topic() + <span class=\"string\">&quot;message-&quot;</span> + i + <span class=\"string\">&quot; partition-&quot;</span> +</span><br><span class=\"line\">                    metadata.partition() + <span class=\"string\">&quot; offset-&quot;</span> + metadata.offset() + <span class=\"string\">&quot;time: &quot;</span> + CommonUtils.formatTime(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()));</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        kafkaProducer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>消费者代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsumerFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startDelayConsumer</span><span class=\"params\">(String topic, String consumerGroup, String clientId, Long delayMills)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        delayRun(topic, consumerGroup, delayMills, clientId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">delayRun</span><span class=\"params\">(String topic, String consumerGroup, Long delayMills, String clientId)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Properties</span> <span class=\"variable\">properties</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">        properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class=\"string\">&quot;127.0.0.1:9093,127.0.0.1:9094,127.0.0.1:9092&quot;</span>);</span><br><span class=\"line\">        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        properties.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class=\"number\">1</span>);</span><br><span class=\"line\">        properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class=\"line\">        properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class=\"line\">        properties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class=\"string\">&quot;earliest&quot;</span>);</span><br><span class=\"line\">        properties.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class=\"number\">5000</span>);</span><br><span class=\"line\">        properties.put(ConsumerConfig.CLIENT_ID_CONFIG, clientId);</span><br><span class=\"line\">        <span class=\"comment\">// 消费者组</span></span><br><span class=\"line\">        properties.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroup);</span><br><span class=\"line\">        KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class=\"keyword\">new</span> <span class=\"title class_\">KafkaConsumer</span>&lt;&gt;(properties);</span><br><span class=\"line\">        List&lt;String&gt; TOPIC_LIST = Collections.singletonList(topic);</span><br><span class=\"line\">        kafkaConsumer.subscribe(TOPIC_LIST);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            ConsumerRecords&lt;String, String&gt; consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(<span class=\"number\">2</span>));</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ConsumerRecord&lt;String, String&gt; record : consumerRecords) &#123;</span><br><span class=\"line\">                <span class=\"type\">TopicPartition</span> <span class=\"variable\">topicPartition</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TopicPartition</span>(topic, record.partition());</span><br><span class=\"line\">                <span class=\"type\">Long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().getTime();</span><br><span class=\"line\">                <span class=\"type\">Long</span> <span class=\"variable\">alreadyDelayTime</span> <span class=\"operator\">=</span> now - record.timestamp();</span><br><span class=\"line\">                <span class=\"type\">Long</span> <span class=\"variable\">leftDelayTime</span> <span class=\"operator\">=</span> delayMills - alreadyDelayTime;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (alreadyDelayTime &lt; delayMills) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 先 pause，防止断连</span></span><br><span class=\"line\">                    kafkaConsumer.pause(Collections.singletonList(topicPartition));</span><br><span class=\"line\">                    kafkaConsumer.seek(topicPartition, record.offset());</span><br><span class=\"line\">                    Thread.sleep(leftDelayTime);</span><br><span class=\"line\">                    kafkaConsumer.resume(Collections.singletonList(topicPartition));</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    handle(record);</span><br><span class=\"line\">                    kafkaConsumer.commitSync();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Integer <span class=\"title function_\">handle</span><span class=\"params\">(ConsumerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;handle record: partition %s - message %s - sendTime %s - receiptTime %s - delayTime %s\\n&quot;</span>,</span><br><span class=\"line\">                record.partition(), record.value(),</span><br><span class=\"line\">                CommonUtils.formatTime(record.timestamp()),</span><br><span class=\"line\">                CommonUtils.formatTime(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()), <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().getTime() - record.timestamp());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果如下</p>\n<figure>\n<img src=\"/images/kafka/image-20230627172859178.png\" alt=\"image-20230627172859178\">\n<figcaption aria-hidden=\"true\">image-20230627172859178</figcaption>\n</figure>\n<p>可以看到，在分区1中的消息，接收时间 = 发送时间 +\n20s，但是分区0中的消息，延时超过了20s</p>\n<p>这是因为代码中 resume\n到了固定的分区，导致无法切换分区；即使手动resume到其他分区，也无法同时对多个分区延时消费，这是因为在一个分区内是有序的，但是分区之间是无序的，单线程在当前分区等待时，其他分区的消息可能已经过时了，所以需要用多线程的方式。</p>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"https://www.cnblogs.com/hongdada/p/16922111.html\">Kafka\n延时队列，重试队列，死信队列</a></p>\n<p><a href=\"https://blog.csdn.net/feiying0canglang/article/details/121372275\">Kafka--延迟队列--使用/实现/原理</a></p>\n<p><a href=\"https://www.it1352.com/2548072.html\">Kafka 的\nsession.timeout.ms 和 max.poll.interval.ms 之间的差异 &gt;=\n0.10.1</a></p>\n<p><a href=\"https://blog.csdn.net/qq_41889508/article/details/130259348\">springboot\nkafka 实现延时队列</a></p>\n<p><a href=\"https://www.jianshu.com/p/bd19445fed7d\">kafka\ncommit机制以及问题</a></p>\n","tags":["kafka"]},{"title":"k8s-secret与configmap","url":"/2022/04/16/k8s/secret-configmap/","content":"<blockquote>\n<p>应用的配置中可能涉及一些敏感信息，如用户名密码，将这些信息直接容器镜像中是不合适的，明文的形式写在deployment.yaml中也容易泄露。K8s提供Secret以密文的形式存储数据，避免了直接在配置文件中保存敏感信息。对于一些非敏感信息，如应用的配置信息，可以用ConfigMap管理</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"secret管理机密信息\">Secret管理机密信息</h3>\n<h4 id=\"创建secret\">创建Secret</h4>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Secret</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">mysql-secret</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">my-mysql</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">Opaque</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">mysql-root-user:</span> <span class=\"string\">&quot;cm9vdA==&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">mysql-root-password:</span> <span class=\"string\">&quot;MTIzNDU2&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">mysql-user:</span> <span class=\"string\">&quot;empt&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">mysql-password:</span> <span class=\"string\">&quot;MTIzNDU2&quot;</span></span><br></pre></td></tr></table></figure>\n<p>Secret中data的值用base64加密 <code>echo -n root | base64</code></p>\n<p>查看secret\n<code>kubectl get secret</code>，<code>kubectl describe secret &#123;secret_name&#125;</code></p>\n<h4 id=\"configmap管理应用配置信息\">ConfigMap管理应用配置信息</h4>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ConfigMap</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">mysql-cm</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">MYSQL_PORT:</span> <span class=\"string\">&quot;3306&quot;</span></span><br></pre></td></tr></table></figure>\n<p><code>kubectl get configmap</code>，<code>kubectl describe configmap &#123;configmap_name&#125;</code></p>\n<h3 id=\"实例用secret与configmap管理mysql的用户名密码和配置信息\">实例：用Secret与ConfigMap管理MySQL的用户名密码和配置信息</h3>\n<p>PV</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">mysql-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">capacity:</span></span><br><span class=\"line\">    <span class=\"attr\">storage:</span> <span class=\"string\">15Gi</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span></span><br><span class=\"line\">  <span class=\"attr\">persistentVolumeReclaimPolicy:</span> <span class=\"string\">Retain</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">nfs</span></span><br><span class=\"line\">  <span class=\"attr\">nfs:</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/home/work/nfs/mysql/</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">node1</span></span><br></pre></td></tr></table></figure>\n<p>PVC</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">mysql-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">accessModes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ReadWriteMany</span></span><br><span class=\"line\">  <span class=\"attr\">resources:</span></span><br><span class=\"line\">    <span class=\"attr\">requests:</span></span><br><span class=\"line\">      <span class=\"attr\">storage:</span> <span class=\"string\">15Gi</span></span><br><span class=\"line\">  <span class=\"attr\">storageClassName:</span> <span class=\"string\">nfs</span></span><br></pre></td></tr></table></figure>\n<p>ConfigMap</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ConfigMap</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">mysql-config</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">mysqld.cnf:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">    [client]</span></span><br><span class=\"line\"><span class=\"string\">    port=3306</span></span><br><span class=\"line\"><span class=\"string\">    [mysql]</span></span><br><span class=\"line\"><span class=\"string\">    no-auto-rehash</span></span><br><span class=\"line\"><span class=\"string\">    [mysqld]</span></span><br><span class=\"line\"><span class=\"string\">    skip-host-cache</span></span><br><span class=\"line\"><span class=\"string\">    skip-name-resolve</span></span><br><span class=\"line\"><span class=\"string\">    default-authentication-plugin=mysql_native_password</span></span><br><span class=\"line\"><span class=\"string\">    character-set-server=utf8mb4</span></span><br><span class=\"line\"><span class=\"string\">    collation-server=utf8mb4_general_ci</span></span><br><span class=\"line\"><span class=\"string\">    explicit_defaults_for_timestamp=true</span></span><br><span class=\"line\"><span class=\"string\">    lower_case_table_names=1</span></span><br></pre></td></tr></table></figure>\n<p>Deployment</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">my-mysql</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">my-mysql</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">my-mysql</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">my-mysql</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">my-mysql</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">&quot;mysql:latest&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MYSQL_ROOT_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">valueFrom:</span></span><br><span class=\"line\">                <span class=\"attr\">secretKeyRef:</span></span><br><span class=\"line\">                  <span class=\"attr\">name:</span> <span class=\"string\">mysql-secret</span></span><br><span class=\"line\">                  <span class=\"attr\">key:</span> <span class=\"string\">mysql-root-password</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MYSQL_PASSWORD</span></span><br><span class=\"line\">              <span class=\"attr\">valueFrom:</span></span><br><span class=\"line\">                <span class=\"attr\">secretKeyRef:</span></span><br><span class=\"line\">                  <span class=\"attr\">name:</span> <span class=\"string\">mysql-secret</span></span><br><span class=\"line\">                  <span class=\"attr\">key:</span> <span class=\"string\">mysql-password</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">MYSQL_USER</span></span><br><span class=\"line\">              <span class=\"attr\">valueFrom:</span></span><br><span class=\"line\">                <span class=\"attr\">secretKeyRef:</span></span><br><span class=\"line\">                  <span class=\"attr\">name:</span> <span class=\"string\">mysql-secret</span></span><br><span class=\"line\">                  <span class=\"attr\">key:</span> <span class=\"string\">mysql-user</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">cm-vol</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/mysql/conf.d</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nfs-vol</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/var/lib/mysql</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">cm-vol</span></span><br><span class=\"line\">          <span class=\"attr\">configMap:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">mysql-config</span></span><br><span class=\"line\">            <span class=\"attr\">items:</span></span><br><span class=\"line\">              <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">mysqld.cnf</span></span><br><span class=\"line\">                <span class=\"attr\">path:</span> <span class=\"string\">mysqld.cnf</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">nfs-vol</span></span><br><span class=\"line\">          <span class=\"attr\">persistentVolumeClaim:</span></span><br><span class=\"line\">            <span class=\"attr\">claimName:</span> <span class=\"string\">mysql-pvc</span></span><br></pre></td></tr></table></figure>\n<p>Service</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">my-mysql</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">port:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">      <span class=\"attr\">targetPort:</span> <span class=\"number\">3306</span></span><br><span class=\"line\">      <span class=\"attr\">nodePort:</span> <span class=\"number\">30006</span>   <span class=\"comment\"># 指定外网访问端口</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">LoadBalancer</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">my-mysql</span></span><br></pre></td></tr></table></figure>\n<p>以上配置写在 mysql-deployment.yaml中，用 <code>---</code> 分割</p>\n<p>secret信息单独放在secret.yaml中</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Secret</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">mysql-secret</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">my-mysql</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">Opaque</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">mysql-root-user:</span> <span class=\"string\">&quot;cm9vdA==&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">mysql-root-password:</span> <span class=\"string\">&quot;MTIzNDU2&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">mysql-user:</span> <span class=\"string\">&quot;empt&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">mysql-password:</span> <span class=\"string\">&quot;MTIzNDU2&quot;</span></span><br></pre></td></tr></table></figure>\n<p>创建secret信息 <code>kubectl apply -f secret.yaml</code></p>\n<p>创建mysql应用 <code>kubectl apply -f mysql-deployment.yaml</code></p>\n<p>访问mysql服务：<code>mysql -uroot -p123456 -Pnode1</code></p>\n<h3 id=\"遇到问题\">遇到问题</h3>\n<ol type=\"1\">\n<li><p>mysql服务副本数设置为2，有一个Pod总是会失败</p>\n<p>通过 <code>kubectl logs -f  &#123;podId&#125; -n default</code>\n查看Pod日志，发现ibdata1文件被锁住，导致Pod中的mysql进程无法启动，看来不能以2个主节点的形式部署mysql集群，应是一主多从，该如何用k8s部署？（如何用k8s部署高可用的mysql集群）</p>\n<figure>\n<img src=\"/images/k8s/image-20220416003709230.png\" alt=\"image-20220416003709230\">\n<figcaption aria-hidden=\"true\">image-20220416003709230</figcaption>\n</figure></li>\n</ol>\n","categories":["k8s"],"tags":["k8s"]},{"title":"mysql select 的执行流程","url":"/2022/09/17/mysql/mysql-select-process/","content":"<blockquote>\n<p>本文介绍MySQL的逻辑架构，引出一条select语句的执行流程</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"mysql逻辑架构\">MySQL逻辑架构</h2>\n<figure>\n<img src=\"/images/mysql/image-20220911035828494.png\" alt=\"MySQL逻辑架构图\">\n<figcaption aria-hidden=\"true\">MySQL逻辑架构图</figcaption>\n</figure>\n<p>MySQL的逻辑架构可以分为<strong>Server层</strong>和<strong>存储引擎层</strong>两部分</p>\n<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等；存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、\nMemory等多个存储引擎</p>\n<p><strong>注：</strong>MySQL8.0将查询缓存删除</p>\n<h3 id=\"server-层\">Server 层</h3>\n<h4 id=\"连接器\">连接器</h4>\n<p>负责建立、维持、管理客户端的连接，权限认证</p>\n<h4 id=\"查询缓存\">查询缓存</h4>\n<p>将之前执行过的查询语句及其结果以key-value对的形式缓存到内存中，如果能够直接在这个缓存中找到key，则直接返回查询结果</p>\n<p>只要有一个表的更新，这个表的查询缓存就会被清空，导致查询缓存的失效非常频繁，如果查询缓存的命中率非常低，则反而影响了效率</p>\n<p>MySQL8.0将查询缓存删除</p>\n<h4 id=\"分析器\">分析器</h4>\n<p>对查询语句做语法分析</p>\n<h4 id=\"优化器\">优化器</h4>\n<p>选择索引，join多表关联时，决定各表的连接顺序</p>\n<h4 id=\"执行器\">执行器</h4>\n<ol type=\"1\">\n<li>判断用户对表是否有执行查询的权限</li>\n<li>调用搜索引擎的接口取值</li>\n</ol>\n<h3 id=\"存储引擎层\">存储引擎层</h3>\n<blockquote>\n<p>只讨论InnoDB</p>\n</blockquote>\n<p>Server层的执行器调用存储引擎的接口，如使用索引name查询name=Tom\n的记录，这个流程是什么样的呢</p>\n<p>首先介绍索引的类型，以及几种索引机制</p>\n<h4 id=\"索引类型\">索引类型</h4>\n<figure>\n<img src=\"/images/mysql/image-20220917124719018.png\" alt=\"image-20220917124719018\">\n<figcaption aria-hidden=\"true\">image-20220917124719018</figcaption>\n</figure>\n<p>索引类型分为主键索引（聚簇索引）和非主键索引（二级索引）</p>\n<ul>\n<li><p>如果语句是select * fromTwhere\nID=500，主键查询方式，只需要搜索ID这棵B+树；</p></li>\n<li><p>如果语句是select * fromTwhere\nk=5，普通索引查询方式，需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为<strong>回表</strong></p></li>\n</ul>\n<blockquote>\n<p>可以看到回表会增加一次索引查询，在范围查询中，如select id, name from\nuser where age &gt; 10，则需要回表很多次，如何避免回表，提高效率呢</p>\n</blockquote>\n<h4 id=\"覆盖索引\">覆盖索引</h4>\n<p>如果select的字段在一个二级索引中已包含，则不需要回表，这个二级索引对于覆盖了查询需求的语句是一个覆盖索引</p>\n<p>如 select id, name, age from user where name like 'Jane%' and age\n&lt; 18; 建立一个联合索引A (name, age)，在A中，已经包含了要查询的id,\nname, age信息，无需回表</p>\n<h4 id=\"最左前缀匹配\">最左前缀匹配</h4>\n<p>最左前缀匹配是针对联合索引而言</p>\n<p>如下，为(name, age)的联合索引</p>\n<figure>\n<img src=\"/images/mysql/image-20220917130645020.png\" alt=\"image-20220917130645020\">\n<figcaption aria-hidden=\"true\">image-20220917130645020</figcaption>\n</figure>\n<p>索引项是按照索引定义里面出现的字段顺序排序的，匹配时按照从左至於的顺序匹配</p>\n<ul>\n<li>只要是联合索引的那几个条件与where子句中的条件匹配，都能应用对应的联合索引</li>\n<li>在有联合索引（a+b）和单列索引a同时存在时，通过a条件的查询会优先使用联合索引</li>\n<li>在联合索引（a+b）中无法只通过条件b查询，因为b无法匹配最左前缀，这时只能再建一个(b)索引</li>\n</ul>\n<h4 id=\"索引下推\">索引下推</h4>\n<p>对于<code>mysql&gt; select * from user where name like '张%' and age=10 and ismale=1;</code></p>\n<p>在MySQL\n5.6之前，只能从第一个满足【张*】的记录开始一个个回表。到主键索引上找出数据行，再对比字段值</p>\n<p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)，\n可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p>\n<p>如联合索引 (name, age)，会找到 name 和 age 符合条件的 id，再回表</p>\n<blockquote>\n<p>根据上述的索引查找机制，对于一个查询，走哪个索引，是否要回表，就有了一定的认知，进而可以对一些场景进行优化</p>\n</blockquote>\n<h4 id=\"索引的优化\">索引的优化</h4>\n<ul>\n<li>覆盖索引：对于频繁查询 select name, age from user where age between\n(10, 20)，建立联合索引（age, name）避免回表</li>\n<li>索引下推：对于查询 select * from user where name like '张%' and age\n&gt; 10; 建立联合索引（name,\nage），相对于单个name索引，可以减少回表次数</li>\n</ul>\n<blockquote>\n<p>题外话：在用户表中，有身份证号的字段，要不要用身份证号做主键</p>\n<p>分析：</p>\n<ol type=\"1\">\n<li>身份证是无序的，在维护主键索引树的时候，需要挪动其他记录，引发叶分裂</li>\n<li>身份证号长度较大，主键长度越大，二级索引的叶子节点长度就越大，二级索引占用的空间就越大</li>\n</ol>\n<p>答案：不要</p>\n<p>用自增id做索引，在主键索引中，每次插入一条新记录，都是追加操作，不涉及到挪动其他记录，也不会触发叶子节点的分裂，相比于身份证长度要短:+1:</p>\n</blockquote>\n<h2 id=\"总结\">总结</h2>\n<p>本文介绍了MySQL的逻辑架构，包括Server层和存储引擎层，Server层包括连接器、查询缓存、分析器、优化器、执行器；存储引擎层介绍了索引类型，如何通过索引找到记录，索引的一些机制，如覆盖索引、最左前缀匹配、索引下推，最后列举了两个索引的优化策略。一条select语句，就是通过Server层和索引层，最终找到对应的记录</p>\n<h2 id=\"参考文献\">参考文献</h2>\n<p>mysql 45 讲 第1,4,5讲</p>\n","categories":["mysql"],"tags":["mysql"]},{"title":"数据库锁与事务","url":"/2022/07/17/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/","content":"<blockquote>\n<p>本文介绍数据库的乐观锁、悲观锁、事务、MVCC</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"乐观锁\">乐观锁</h2>\n<h3 id=\"上锁流程\">上锁流程</h3>\n<ol type=\"1\">\n<li>读取被操作对象，记录某个特征信息</li>\n<li>对对象进行业务逻辑处理</li>\n<li>数据回写前，检查特征信息是否有变化</li>\n<li>如果一致，回写；如果不一致，重试上述流程</li>\n</ol>\n<h3 id=\"性质\">性质</h3>\n<p>乐观锁的本质是一种读写<strong>策略</strong>，没有真正的在被操作对象上加锁</p>\n<p>对于操作方，有可能失败重试，反复读写，牺牲了操作方的性能（利他策略），但提升了被操作对象的并发度</p>\n<h3 id=\"应用场景\">应用场景</h3>\n<p>读多，极少修改，操作方重试概率低的场景</p>\n<h2 id=\"悲观锁\">悲观锁</h2>\n<p>操作方对被操作对象加锁，等锁释放后其他操作方才能加锁（利己策略）</p>\n<h3 id=\"分类\">分类</h3>\n<h4 id=\"s锁\">S锁</h4>\n<p>Shared Lock，共享锁，读锁</p>\n<p>A加了S锁，其他人可以加S锁，不可加X锁</p>\n<p>如何加S锁（哪些操作会加S锁）：<code>select * from user where ... lock in share mode;</code></p>\n<p>如何释放S锁：事务结束</p>\n<h4 id=\"u锁sqlserver\">U锁（SQLServer）</h4>\n<p>更新锁，加了U锁，不能加U锁和X锁，可以加S锁（相当于加了S锁并预定了X锁）</p>\n<h4 id=\"x锁\">X锁</h4>\n<p>Exclusive Lock，排他锁，写锁</p>\n<p>加了X锁，其他人不能加任何锁</p>\n<p>如何加X锁（哪些操作会加X锁）：<code>select * from user where ... for update;</code>，<code>insert</code>，<code>update</code>，<code>delete</code></p>\n<p>如何释放X锁：事务结束</p>\n<h3 id=\"加锁原则\">加锁原则</h3>\n<p>最小知道原则</p>\n<h3 id=\"悲观锁的作用范围\">悲观锁的作用范围</h3>\n<ol type=\"1\">\n<li>行锁</li>\n<li>页锁</li>\n<li>表锁</li>\n</ol>\n<h3 id=\"锁升级\">锁升级</h3>\n<p>在RR隔离级别中，行锁是加在索引上，如果查询条件不走索引，会加表锁（升级）</p>\n<h4 id=\"实验锁升级\">实验：锁升级</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># clinet 1</span><br><span class=\"line\">begin; </span><br><span class=\"line\">select * from actor where first_name = 1 for update;</span><br><span class=\"line\"># client 2</span><br><span class=\"line\">update actor set first_name = &#x27;2&#x27; where id = 1;</span><br><span class=\"line\"># client 1</span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁\">死锁</h3>\n<h4 id=\"死锁的条件\">死锁的条件</h4>\n<ol type=\"1\">\n<li>互斥：一把钥匙，只能一个人拿</li>\n<li>不剥夺：一个人拿了钥匙，别人不能抢</li>\n<li>请求和保持：有了一个资源，不放手，还要请求其他资源</li>\n<li>循环等待：与另一个人的请求资源形成环</li>\n</ol>\n<h4 id=\"死锁的解决方案\">死锁的解决方案</h4>\n<p>打破任意一个条件即可</p>\n<ol type=\"1\">\n<li>打破互斥条件：不用悲观锁，改为乐观锁</li>\n<li>打破不剥夺：A获取资源B，还要获取资源C，如果申请失败，A释放资源B</li>\n<li>打破请求和保持：保留和请求只留一个，如果需要持有两个资源，已持有一个，需放手后才能持有另一个</li>\n<li>打破循环等待：按顺序抢占锁</li>\n</ol>\n<h4 id=\"如何定位死锁\">如何定位死锁</h4>\n<ol type=\"1\">\n<li>数据库死锁日志：<code>SHOW ENGINE INNODB STATUS;</code></li>\n<li>线程dump文件：<code>jmap -dump:format=b,file=&#123;filename&#125; &#123;pid&#125;</code></li>\n<li>进程堆栈信息：<code>jstack &#123;pid&#125;</code></li>\n</ol>\n<p>本文只介绍数据库层面，其他层面捎带</p>\n<h4 id=\"死锁实验\">死锁实验</h4>\n<p>有对象C，有一个操作：先对C加S锁，再对C加X锁</p>\n<p>A对C加了S锁，B对C加了S锁，A对C加X锁失败，B对C加X锁也失败，A和B都不会主动释放C的S锁，产生了死锁</p>\n<p>什么场景会先加S后加X呢？</p>\n<h5 id=\"防止产生s与x锁死锁的解决方案\">防止产生S与X锁死锁的解决方案</h5>\n<ol type=\"1\">\n<li>获取X锁失败后，主动释放S锁，重试</li>\n<li>使用U锁，允许其他人加S锁，但不能加U和X</li>\n<li>直接加X锁</li>\n</ol>\n<h5 id=\"实验1s锁与x锁的阻塞情况\">实验1：S锁与X锁的阻塞情况</h5>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">## S 锁不能加X锁的情况</span><br><span class=\"line\"># client 1</span><br><span class=\"line\">begin;</span><br><span class=\"line\">select * from actor where actor_id = 1 lock in share mode;</span><br><span class=\"line\"># client 2</span><br><span class=\"line\">select * from actor where actor_id = 1 for update;</span><br><span class=\"line\"># client 2 pending...</span><br><span class=\"line\"># client 1</span><br><span class=\"line\">commit;</span><br><span class=\"line\"># client 2 running or wait timeout exceeded</span><br><span class=\"line\">## X锁不能加S锁的情况</span><br><span class=\"line\"># 同理</span><br></pre></td></tr></table></figure>\n<h5 id=\"实验2数据库层面制造死锁并定位死锁\">实验2：数据库层面制造死锁并定位死锁</h5>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># client 1</span><br><span class=\"line\">begin;</span><br><span class=\"line\">select * from actor where actor_id = 1 lock in share mode;</span><br><span class=\"line\"># client 2</span><br><span class=\"line\">begin;</span><br><span class=\"line\">select * from actor where actor_id = 1 lock in share mode;</span><br><span class=\"line\"># client 1</span><br><span class=\"line\">select * from actor where actor_id = 1 for update;</span><br><span class=\"line\"># client 2</span><br><span class=\"line\">select * from actor where actor_id = 1 for update;</span><br><span class=\"line\">SHOW ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure>\n<h4 id=\"mysql如何自动处理死锁\">mysql如何自动处理死锁</h4>\n<ol type=\"1\">\n<li>超时等待</li>\n<li>死锁检测：谁触发死锁谁回滚当前事务，其他事务继续执行</li>\n</ol>\n<h5 id=\"死锁检测的原理\">死锁检测的原理</h5>\n<p>事务为顶点，锁为边（需求方指向持有方）\n事务A持有L2锁，A需要L1锁，故有一条边由A指向B</p>\n<p>事务B持有L1锁，B需要L2锁，故有一条边由B指向A</p>\n<figure>\n<img src=\"/images/mysql/image-20220714030233959.png\" alt=\"image-20220714030233959\">\n<figcaption aria-hidden=\"true\">image-20220714030233959</figcaption>\n</figure>\n<h2 id=\"事务\">事务</h2>\n<h3 id=\"事务正确执行的四个要素acid\">事务正确执行的四个要素：ACID</h3>\n<p>A：atomicity 原子性，要么全做，要么全不做</p>\n<p>C：consistency 一致性，事务前后的数据是一致的</p>\n<p>I：isolation\n隔离性，多个并发事务同时读写时，防止多个事务并发执行时由于交叉执行导致数据不一致</p>\n<p>D：durability 持久性 事务结束后，对数据的修改是永久的</p>\n<h3 id=\"事务的开始与结束\">事务的开始与结束</h3>\n<p>开始：以第一个DML（Data Manipulation Language，如select, delete,\nupdate, insert）语句的执行开始</p>\n<p>结束：commit, rollback</p>\n<h3 id=\"事务的隔离\">事务的隔离</h3>\n<h4 id=\"事务隔离解决的问题\">事务隔离解决的问题</h4>\n<p>ACID中的ACD对并发事务和单一事务是没有区别的，隔离性是防止并发事务执行时产生的影响，如果没有隔离性，并发事务会带来的问题有：</p>\n<ol type=\"1\">\n<li>脏写：写了被其他事务覆盖，没生效</li>\n<li>脏读：读到未提交的中间结果（中间结果可以回滚，不认为是正确的数据）</li>\n<li>不可重复读：在一个事务内多次读结果不一致</li>\n<li>幻读：一次事务内读到新数据</li>\n</ol>\n<p>所以，需要解决以上问题</p>\n<h4 id=\"事务的隔离级别\">事务的隔离级别</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>读未提交（Read uncommitted）</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>读提交（read committed）</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr class=\"odd\">\n<td>可重复读（repeatable read）</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr class=\"even\">\n<td>串行化（Serializable）</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody>\n</table>\n<p>MySQL 语句的默认事务隔离级别：rr\n可重复读，通过<code>SELECT @@transaction_isolation;</code>查看</p>\n<p>修改隔离级别：<code>SET SESSION transaction_isolation = 'READ-UNCOMMITTED';</code></p>\n<h4 id=\"不同隔离级别通过锁的实现思路\">不同隔离级别通过锁的实现思路</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>隔离级别</th>\n<th>解决的问题</th>\n<th>实现思路</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>RC</td>\n<td>脏读</td>\n<td>写时加X锁</td>\n</tr>\n<tr class=\"even\">\n<td>RR</td>\n<td>不可重复读</td>\n<td>读时加S锁</td>\n</tr>\n<tr class=\"odd\">\n<td>Serializable</td>\n<td>幻读</td>\n<td>事务之间串行执行</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"实验不同隔离级别下的问题复现\">实验：不同隔离级别下的问题复现</h4>\n<ol type=\"1\">\n<li><p>脏读</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># clinet 2</span><br><span class=\"line\">begin;</span><br><span class=\"line\">update actor set first_name = &#x27;Jans&#x27; where actor_id = 1;</span><br><span class=\"line\"># client 1</span><br><span class=\"line\"># client1</span><br><span class=\"line\">SET SESSION transaction_isolation = &#x27;READ-UNCOMMITTED&#x27;;</span><br><span class=\"line\">begin;</span><br><span class=\"line\">select * from actor where actor_id = 1;</span><br><span class=\"line\"># client 2</span><br><span class=\"line\">rollback;</span><br><span class=\"line\"># client 1</span><br><span class=\"line\">select * from actor where actor_id = 1;</span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure></li>\n<li><p>不可重复读</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># client1</span><br><span class=\"line\">SET SESSION transaction_isolation = &#x27;READ-COMMITTED&#x27;;</span><br><span class=\"line\">begin;</span><br><span class=\"line\">select * from actor where actor_id = 1;</span><br><span class=\"line\"># clinet 2</span><br><span class=\"line\">update actor set first_name = &#x27;Jans&#x27; where actor_id = 1;</span><br><span class=\"line\"># client 1</span><br><span class=\"line\">select * from actor where actor_id = 1;</span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"多版本并发控制-mvcc\">多版本并发控制 MVCC</h3>\n<p>Multi-Version Concurrency Control</p>\n<p>在上小节中，通过S锁或X锁解决了一些并发事务的问题，但是这种方式存在以下问题：</p>\n<ol type=\"1\">\n<li>并发读写数据库时，读操作会阻塞写操作</li>\n<li>加锁带来的资源消耗</li>\n</ol>\n<p>如何解决上面的问题，也能保证事务的正确性呢</p>\n<h4 id=\"思路设想\">思路设想</h4>\n<p>我的实现思路：为每个事务建立一个副本，不加锁的操作（select）从副本中读数据，涉及到加锁操作在原表中通过悲观锁操作</p>\n<p>难点：</p>\n<ol type=\"1\">\n<li>副本的形式是什么，是拷贝完整的表，还是一部分？</li>\n<li>创建副本时应该如何控制并发问题？</li>\n<li>副本太多可能导致磁盘不足怎么办？</li>\n</ol>\n<p>MySQL的实现思路：在有变更的操作时创建副本，事务找到它可见的最新副本，用于不加锁操作，涉及加锁操作，在原表中通过悲观锁操作</p>\n<p>难点：副本形式，如何找到可见的最新副本</p>\n<h4 id=\"实现原理\">实现原理</h4>\n<p>MySQL的数据引擎对MVCC的实现原理</p>\n<p>依赖于记录中的三个隐藏字段（row_id，trx_id, rollback_ptr），undo\nlog，read view</p>\n<p>trx_id：该记录最新修改的事务号</p>\n<p>rollback_ptr：上一个版本指针</p>\n<p>undo log：回滚日志</p>\n<p>read view：可见性</p>\n<figure>\n<img src=\"/images/mysql/mvcc.png\" alt=\"image-20220714030233959\">\n<figcaption aria-hidden=\"true\">image-20220714030233959</figcaption>\n</figure>\n<p>如上图，事务5来读取某一行数据，如那行数据的row_id=24，记录中trx_id\n&gt; 5，对事务5不可见，通过rollback_ptr在undo\nlog中找上个版本的记录，发现trx_id &gt; 5，再找上个版本的记录，发现trx_id\n&lt; 5，则该记录是事务5可见的最新版本，读数据</p>\n<h4 id=\"使用mvcc实现事务隔离级别该怎么做\">使用MVCC实现事务隔离级别，该怎么做</h4>\n<p>当前读：从数据表中，不同语句根据隔离级别，使用悲观锁处理冲突，如<code>select ... in share mode</code>，<code>select ... for update</code></p>\n<p>快照读：使用MVCC，从表或undo\nlog中读数据，不需要使用悲观锁，如<code>select ...</code></p>\n<p>RC和RR都可以通过快照读来实现，解决对应的问题</p>\n<p>MySQL 8.x 是通过MVCC实现的RC和RR，不是通过悲观锁</p>\n<h3 id=\"处理事务的注意事项\">处理事务的注意事项</h3>\n<ol type=\"1\">\n<li>查询条件通过索引，避免无索引行升级为表锁</li>\n<li>加锁时，缩小锁的范围，避免间隙锁</li>\n<li>尽量减少锁定资源量和时间，将加锁操作放到最后执行</li>\n</ol>\n","tags":["mysql"]},{"title":"mysql update 的执行流程","url":"/2022/09/11/mysql/mysql-update-process/","content":"<blockquote>\n<p>本文简述MySQL 一条更新指令的执行流程，和其中涉及的日志、crash\nsafe策略、缓存优化方式</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"update涉及的日志模块\">update涉及的日志模块</h2>\n<h3 id=\"redo-log\">Redo log</h3>\n<blockquote>\n<p>why we use redo log?</p>\n</blockquote>\n<p>redo log 是 InnoDB\n引擎特有的日志，由于最开始MySQL没有InnoDB引擎，而MyISAM没有crash-safe能力，导致MySQL在crash时数据是不安全的（WHY？）。所以InnoDB\n使用另外一套日志系统——redo log来实现 crash-safe的能力。</p>\n<blockquote>\n<p>crash safe</p>\n</blockquote>\n<p>如果没有redo log，只有bin log，在写bin\nlog过程中如果服务crash，导致数据丢失</p>\n<h3 id=\"bin-log\">Bin log</h3>\n<p>bin log是MySQL Server层实现的，记录SQL语句的原始逻辑，bin\nlog是追加的，不会覆盖以前的日志</p>\n<h3 id=\"redo-log-与-bin-log-的区别\">redo log 与 bin log 的区别</h3>\n<ol type=\"1\">\n<li>实现层级不同：redo log是 InnoDB 实现的，bin\nlog是MySQL的Server层实现的</li>\n<li>记录内容不同：redo log记录数据页的修改，bin log是语句的逻辑</li>\n<li>存储形式不同：redo log是循环写的，bin log 是追加写的</li>\n</ol>\n<h2 id=\"update-语句执行的流程\">Update 语句执行的流程</h2>\n<h3 id=\"数据页\">数据页</h3>\n<p>为了避免一条一条读取磁盘数据，InnoDB采取页的方式，作为磁盘和内存之间交互的基本单位。一个页的大小一般是16KB。InnoDB主键索引B+树的叶子节点存放表中数据记录的页，称为索引页or数据页</p>\n<h3 id=\"change-buffer\">change buffer</h3>\n<p>在更新某些记录时，先判断这些记录的数据页是否在缓冲池（buffer\npool）中，如果这些页面不在buffer\npool中，将要更新（INSERT，UPDATE或DELETE操作DML）操作记录到change\nbuffer中。当<strong>读操作</strong>将页加载到缓冲池时，将数据页和change\nbuffer合并</p>\n<h4 id=\"目的\">目的</h4>\n<p>无需从磁盘读数据页到内存，提升DML操作相应时间</p>\n<h4 id=\"merge-操作\">merge 操作</h4>\n<p>change buffer中的操作写到原数据页的过程</p>\n<p>merge的触发条件有：</p>\n<ol type=\"1\">\n<li>有读操作访问该数据页</li>\n<li>系统后台线程定期merge</li>\n<li>数据库正常关闭（shutdown）的过程</li>\n</ol>\n<h4 id=\"何时使用change-buffer\">何时使用change buffer</h4>\n<p>对于唯一索引，更新操作都要先判断该操作是否违反唯一性约束；比如，要插入(4,400)记录，要先判断表中是否已存k=4记录，就必须要将数据页读入内存来判断，从第一个k=4的记录开始，顺序的找到第一个k≠4的记录结束。仅写入change\nbuffer无法判断索引的唯一性 因此，唯一索引的更新不能使用change\nbuffer，只有普通索引可使用</p>\n<p>为什么无索引不可以使用 change\nbuffer呢？因为无索引则无法找到数据页（索引页）</p>\n<h3 id=\"update执行流程\">Update执行流程</h3>\n<figure>\n<img src=\"/images/mysql/image-20220911035828494.png\" alt=\"image-20220911035828494\">\n<figcaption aria-hidden=\"true\">image-20220911035828494</figcaption>\n</figure>\n<figure>\n<img src=\"/images/mysql/image-20220911035431549.png\" alt=\"image-20220911035431549\">\n<figcaption aria-hidden=\"true\">image-20220911035431549</figcaption>\n</figure>\n<p>流程说明：</p>\n<p>图1：同查询语句的执行流程，在MySQL的Server层，再调用存储引擎</p>\n<p>图2：绿色部分表示在存储引擎（Innodb）中执行，白色在MySQL的Server层执行</p>\n<h3 id=\"两阶段提交\">两阶段提交</h3>\n<blockquote>\n<p>先写入redo log，再写入bin log，再将redo\nlog的操作设置为commit状态。目的：为了保证redo log和bin log的逻辑一致</p>\n</blockquote>\n<h4 id=\"如果不使用两阶段提交会有什么问题\">如果不使用两阶段提交会有什么问题</h4>\n<ol type=\"1\">\n<li>先写redolog，再写binlog：\nredolog写完，还没来得及写binlog，MySQL宕机。重启以后，redolog里有记录，MySQL判断事务提交成功，但binlog里没有记录，binlog与redolog出现数据不一致。由于binlog是追加写入日志，往后的时间里binlog会一直缺失这条数据。如果在以后使用binlog恢复这个时间点的数据，会出现数据丢失的情况</li>\n<li>先写binlog，再写redolog：\nbinlog写完，还没来得及写redolog，MySQL宕机。重启以后，redolog中没有记录，MySQL判断事务提交失败，但是binlog中有记录，binlog与redolog出现数据不一致。如果以后使用binlog恢复数据，就多出了一个事务操作</li>\n</ol>\n<h3 id=\"数据是怎么写入磁盘实际位置\">数据是怎么写入磁盘实际位置</h3>\n<p>单独的线程将redo\nlog的checkpoint后的记录写入磁盘上的数据页，直到追到write pos为止，write\npos 如果追上checkpoint则不能更新数据</p>\n<p>如果write pos要覆盖之前的redo log记录，需要判断该redo\nlog记录是否对一个事务可见，如果存在，则不能覆盖该redo\nlog记录，判断方法：存在一个事务id，使得trx_id &lt; 事务id</p>\n<figure>\n<img src=\"/images/mysql/image-20220902013004189.png\" alt=\"image-20220902013004189\">\n<figcaption aria-hidden=\"true\">image-20220902013004189</figcaption>\n</figure>\n<p>为什么不直接写到磁盘，而是通过redo\nlog呢？是因为写磁盘是一个随机IO访问，写redo\nlog是顺序的IO访问；即使通过索引可以找到磁盘地址，但是机械硬盘寻址也需要通过磁道旋转</p>\n<p>当change buffer的merge操作也会将数据写入磁盘</p>\n<p>change buffer 和 redo log\n的数据都会刷到磁盘，怎么保证不相互影响呢？</p>\n<h4 id=\"脏页\">脏页</h4>\n<ol type=\"1\">\n<li>什么是脏页：内存数据与磁盘数据不一致的内存中的数据页</li>\n<li>怎么判断脏页：LSN(Page) &gt; LSN(checkpoint)</li>\n<li>什么情况会触发flush 刷脏页：1. redo log 满了；2. buffer pool\n满了；3. 空闲；4. 正常关闭</li>\n<li>什么情况会导致更新操作执行时间很长：1. redo log 满了；2.\n需要刷的脏页太多</li>\n</ol>\n<h2 id=\"总结\">总结</h2>\n<p>本文描述了一条update操作执行的流程，分为MySQL的Server层，和存储引擎层；为了提高update操作执行效率，不直接将数据写入磁盘，而是写到redo\nlog中，化随机IO为顺序IO；redo log 的另一个作用是通过两阶段提交保证 crash\nsafe；如果数据不在innodb 的 buffer\npool中，如果有普通索引，可以不将数据页读到 buffer\npool，而是将变更操作写入 change\nbuffer，减少数据从磁盘拷贝到内存的过程；数据写入redo\nlog后，会有单独线程flush到磁盘；数据页的数据在内存与磁盘不一致时，称该数据页为脏页，一定条件需要刷脏页，可能导致更新操作执行时间很长。</p>\n<h2 id=\"引文\">引文</h2>\n<p><a href=\"https://blog.csdn.net/weixin_44829930/article/details/116212590\">InnoDB引擎中的Buffer\nPool详解</a></p>\n","categories":["mysql"],"tags":["mysql"]},{"title":"redis数据结构——List的底层实现","url":"/2022/08/23/redis/redis-list/","content":"<blockquote>\n<p>本文描述redis底层的list所用到的数据结构，包括ziplist和quicklist</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"redis-list-要解决的问题\">Redis List 要解决的问题</h2>\n<p>Redis的List是一个有序表，可以从表两端存入数据或弹出数据，可以通过下标索引访问表中节点，可以查询表中数据是否存在</p>\n<h2 id=\"linkedlist-双向链表\">LinkedList 双向链表</h2>\n<figure>\n<img src=\"/images/redis/20220823012709693.png\" alt=\"image-2022082301209693\">\n<figcaption aria-hidden=\"true\">image-2022082301209693</figcaption>\n</figure>\n<p>redis3之后已不用linked\nlist做为LIST的底层数据结构，为了引出后面的ziplist和quicklist，这里做简单的介绍</p>\n<p>LinkedList是一个双向链表，每个节点都占用独立的一块内存，每个节点有指向前后的指针，首尾插入和删除的时间复杂度是O(1)，中间插入和查找的时间复杂度是O(n)</p>\n<p>优点：便于在表的两端追加和删除数据</p>\n<p>缺点：带来大量的内存碎片化，前后指针会占用额外的内存</p>\n<h2 id=\"ziplist-压缩表\">Ziplist 压缩表</h2>\n<h3 id=\"为什么要设计压缩表\">为什么要设计压缩表</h3>\n<p>由于LinkedList存在的问题导致空间利用率不高，我们希望设计一个存储效率高的数据结构。</p>\n<p>不能用定长数组，节点的长度无法设定，太长存在浪费，太短可能放不下</p>\n<p>所以ziplist 中节点采用了变长编码方式</p>\n<h3 id=\"结构\">结构</h3>\n<figure>\n<img src=\"/images/redis/20220823013056592.png\" alt=\"image-20220823013056592\">\n<figcaption aria-hidden=\"true\">image-20220823013056592</figcaption>\n</figure>\n<h4 id=\"头部\">头部</h4>\n<p><code>zlbytes</code>：ziplist占用的总字节数，长度4字节</p>\n<p><code>zltail</code>：ziplist表中最后一个entry在ziplist的偏移字节数，为了通过头地址找到最后一个节点的地址，长度4字节</p>\n<p><code>zllen</code>：ziplist表中 entry 的个数，长度2字节</p>\n<h4 id=\"数据部分\">数据部分</h4>\n<h5 id=\"entry的结构\">entry的结构</h5>\n<p>ziplist中每个节点<code>&lt;entry&gt;</code>由<code>prevrawlen</code>、<code>encoding</code>、<code>data</code>构成：</p>\n<p><img src=\"/images/redis/20220822003258004.png\"></p>\n<p><code>prevrawlen</code>：表示前一个entry占用的字节数，用于向前遍历，变长</p>\n<p><code>encoding</code>：表示当前entry的data的编码格式，用于读取数据和向后遍历，变长</p>\n<p><code>data</code>：entry的数据部分，是一个字节数组</p>\n<p>为了提高内存空间利用率，entry会根据存放的数据长度而采用变长的编码，通过<code>prevrawlen</code>和<code>encoding</code>两个字段来控制</p>\n<h5 id=\"prevrawlen-的编码\">prevrawlen 的编码</h5>\n<table>\n<colgroup>\n<col style=\"width: 33%\">\n<col style=\"width: 66%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>二进制</th>\n<th>表示</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>0000,0000（0）</td>\n<td>无前置元素</td>\n</tr>\n<tr class=\"even\">\n<td>0000,0001 ~ 1111,1101（1-253）</td>\n<td>前entry的字节数可以用一个字节表示，直接读该值即可</td>\n</tr>\n<tr class=\"odd\">\n<td>1111,1110（254）</td>\n<td>表示前置entry的字节数用一个字节不够存放，再开辟4字节，读后4字节的值</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"encoding-的编码\">encoding 的编码</h5>\n<table>\n<colgroup>\n<col style=\"width: 12%\">\n<col style=\"width: 8%\">\n<col style=\"width: 12%\">\n<col style=\"width: 48%\">\n<col style=\"width: 6%\">\n<col style=\"width: 12%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>编码类型</th>\n<th>运算</th>\n<th>二进制</th>\n<th>表示</th>\n<th>编码长度</th>\n<th>data长度</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>ZIP_STR_06B</td>\n<td>0&lt;&lt;6</td>\n<td>0000,0000</td>\n<td>前2位表示06B字符串，后6位表示data长度，最大表示2^6-1=63字节</td>\n<td>1Byte</td>\n<td>小于63Byte</td>\n</tr>\n<tr class=\"even\">\n<td>ZIP_STR_14B</td>\n<td>1&lt;&lt;6</td>\n<td>0100,0000</td>\n<td>前2位表示14B字符串，还要加上1字节，共6+8=14位表示长度，最大表示2^14-1</td>\n<td>14bit</td>\n<td>小于2^14-1 Byte</td>\n</tr>\n<tr class=\"odd\">\n<td>ZIP_STR_32B</td>\n<td>2&lt;&lt;6</td>\n<td>1000,0000</td>\n<td>前2位表示32B字符串，后6位不要了，再加上4字节，共4*8=32位表示长度，最大表示2^32-1</td>\n<td>4Byte</td>\n<td>小于2^32-1Byte</td>\n</tr>\n<tr class=\"even\">\n<td>ZIP_INT_16B</td>\n<td>0xc0|0&lt;&lt;4</td>\n<td>1100,0000</td>\n<td>前2位表示整型，3-4位表示data在后2字节</td>\n<td>1Byte</td>\n<td>2Byte</td>\n</tr>\n<tr class=\"odd\">\n<td>ZIP_INT_32B</td>\n<td>0xc0|1&lt;&lt;4</td>\n<td>1101,0000</td>\n<td>前2位表示整型，3-4位表示data在后4字节</td>\n<td>1Byte</td>\n<td>4Byte</td>\n</tr>\n<tr class=\"even\">\n<td>ZIP_INT_64B</td>\n<td>0xc0|2&lt;&lt;4</td>\n<td>1110,0000</td>\n<td>前2位表示整型，3-4位表示data在后8字节</td>\n<td>1Byte</td>\n<td>8Byte</td>\n</tr>\n<tr class=\"odd\">\n<td>ZIP_INT_24B</td>\n<td>0xc0|3&lt;&lt;4</td>\n<td>1111,0000</td>\n<td>前2位表示整型，3-4位表示data在后面3字节</td>\n<td>1Byte</td>\n<td>3Byte</td>\n</tr>\n<tr class=\"even\">\n<td>ZIP_INT_8B</td>\n<td>0xfe</td>\n<td>1111,1110</td>\n<td>前2位表示整型，3-8位表示再读1字节</td>\n<td>1Byte</td>\n<td>1Byte</td>\n</tr>\n<tr class=\"odd\">\n<td>ZIP_INT_IMM_MASK</td>\n<td>0x0f</td>\n<td>1111,(0001~1101)</td>\n<td>不需要再读，后4位直接表示整数，范围是0~12</td>\n<td>4bit</td>\n<td>4bit</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"结束符\">结束符</h4>\n<p><code>zlend</code>：全1的一个字节</p>\n<h4 id=\"举个例子\">举个例子</h4>\n<figure>\n<img src=\"/images/redis/20220823020943794.png\" alt=\"image-2022082302094379\">\n<figcaption aria-hidden=\"true\">image-2022082302094379</figcaption>\n</figure>\n<h3 id=\"源码\">源码</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Fills a struct with all information about an entry.</span></span><br><span class=\"line\"><span class=\"comment\"> * This function is the &quot;unsafe&quot; alternative to the one below.</span></span><br><span class=\"line\"><span class=\"comment\"> * Generally, all function that return a pointer to an element in the ziplist</span></span><br><span class=\"line\"><span class=\"comment\"> * will assert that this element is valid, so it can be freely used.</span></span><br><span class=\"line\"><span class=\"comment\"> * Generally functions such ziplistGet assume the input pointer is already</span></span><br><span class=\"line\"><span class=\"comment\"> * validated (since it&#x27;s the return value of another function). */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">zipEntry</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, zlentry *e)</span> &#123;</span><br><span class=\"line\">    ZIP_DECODE_PREVLEN(p, e-&gt;prevrawlensize, e-&gt;prevrawlen);</span><br><span class=\"line\">    ZIP_ENTRY_ENCODING(p + e-&gt;prevrawlensize, e-&gt;encoding);</span><br><span class=\"line\">    ZIP_DECODE_LENGTH(p + e-&gt;prevrawlensize, e-&gt;encoding, e-&gt;lensize, e-&gt;len);</span><br><span class=\"line\">    assert(e-&gt;lensize != <span class=\"number\">0</span>); <span class=\"comment\">/* check that encoding was valid. */</span></span><br><span class=\"line\">    e-&gt;headersize = e-&gt;prevrawlensize + e-&gt;lensize;</span><br><span class=\"line\">    e-&gt;p = p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Different encoding/length possibilities */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_STR_MASK 0xc0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_INT_MASK 0x30</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_STR_06B (0 &lt;&lt; 6)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_STR_14B (1 &lt;&lt; 6)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_STR_32B (2 &lt;&lt; 6)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_INT_24B (0xc0 | 3&lt;&lt;4)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_INT_8B 0xfe</span></span><br><span class=\"line\"><span class=\"comment\">/* 4 bit integer immediate encoding |1111xxxx| with xxxx between</span></span><br><span class=\"line\"><span class=\"comment\"> * 0001 and 1101. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_INT_IMM_MASK 0x0f   <span class=\"comment\">/* Mask to extract the 4 bits value. To add</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"meta\">                                   one is needed to reconstruct the value. */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_INT_IMM_MIN 0xf1    <span class=\"comment\">/* 11110001 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZIP_INT_IMM_MAX 0xfd    <span class=\"comment\">/* 11111101 */</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ziplist-的操作\">ziplist 的操作</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistNew</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistMerge</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> **first, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> **second)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistPush</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *s, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> slen, <span class=\"type\">int</span> where)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistIndex</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">int</span> index)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistNext</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistPrev</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">ziplistGet</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> **sval, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> *slen, <span class=\"type\">long</span> <span class=\"type\">long</span> *lval)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistInsert</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *s, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> slen)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistDelete</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> **p)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistDeleteRange</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">int</span> index, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> num)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">ziplistCompare</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *s, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> slen)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *<span class=\"title function_\">ziplistFind</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *vstr, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> vlen, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> skip)</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">ziplistLen</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl)</span>;</span><br><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">ziplistBlobLen</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ziplistRepr</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl)</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ziplistSafeToAdd</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">char</span>* zl, <span class=\"type\">size_t</span> add)</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"插入逻辑分析\">插入逻辑分析</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Insert item at &quot;p&quot;. */</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> *__ziplistInsert(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *zl, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *p, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *s, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> slen) &#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> prevlensize, prevlen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> offset;</span><br><span class=\"line\">    <span class=\"type\">int</span> nextdiff = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> encoding = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> value = <span class=\"number\">123456789</span>; <span class=\"comment\">/* initialized to avoid warning. Using a value</span></span><br><span class=\"line\"><span class=\"comment\">                                    that is easy to see if for some reason</span></span><br><span class=\"line\"><span class=\"comment\">                                    we use it uninitialized. */</span></span><br><span class=\"line\">    zlentry tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Find out prevlen for the entry that is inserted. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptail[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">            prevlen = zipRawEntryLength(ptail);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* See if the entry can be encoded */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* &#x27;encoding&#x27; is set to the appropriate integer encoding */</span></span><br><span class=\"line\">        reqlen = zipIntSize(encoding);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* &#x27;encoding&#x27; is untouched, however zipStoreEntryEncoding will use the</span></span><br><span class=\"line\"><span class=\"comment\">         * string length to figure out how to encode it. */</span></span><br><span class=\"line\">        reqlen = slen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* We need space for both the length of the previous entry and</span></span><br><span class=\"line\"><span class=\"comment\">     * the length of the payload. */</span></span><br><span class=\"line\">    reqlen += zipStorePrevEntryLength(<span class=\"literal\">NULL</span>,prevlen);</span><br><span class=\"line\">    reqlen += zipStoreEntryEncoding(<span class=\"literal\">NULL</span>,encoding,slen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* When the insert position is not equal to the tail, we need to</span></span><br><span class=\"line\"><span class=\"comment\">     * make sure that the next entry can hold this entry&#x27;s length in</span></span><br><span class=\"line\"><span class=\"comment\">     * its prevlen field. */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> forcelarge = <span class=\"number\">0</span>;</span><br><span class=\"line\">    nextdiff = (p[<span class=\"number\">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextdiff == <span class=\"number\">-4</span> &amp;&amp; reqlen &lt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        nextdiff = <span class=\"number\">0</span>;</span><br><span class=\"line\">        forcelarge = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Store offset because a realloc may change the address of zl. */</span></span><br><span class=\"line\">    offset = p-zl;</span><br><span class=\"line\">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class=\"line\">    p = zl+offset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p[<span class=\"number\">0</span>] != ZIP_END) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Subtract one because of the ZIP_END bytes */</span></span><br><span class=\"line\">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class=\"number\">-1</span>+nextdiff);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Encode this entry&#x27;s raw length in the next entry. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (forcelarge)</span><br><span class=\"line\">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Update offset for tail */</span></span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* When the tail contains more than one entry, we need to take</span></span><br><span class=\"line\"><span class=\"comment\">         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</span></span><br><span class=\"line\"><span class=\"comment\">         * size of prevlen doesn&#x27;t have an effect on the *tail* offset. */</span></span><br><span class=\"line\">        zipEntry(p+reqlen, &amp;tail);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class=\"line\">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class=\"line\">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* This element will be the new tail. */</span></span><br><span class=\"line\">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class=\"line\"><span class=\"comment\">     * we need to cascade the update throughout the ziplist */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextdiff != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        offset = p-zl;</span><br><span class=\"line\">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class=\"line\">        p = zl+offset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Write the entry */</span></span><br><span class=\"line\">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class=\"line\">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(p,s,slen);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        zipSaveInteger(p,value,encoding);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ZIPLIST_INCR_LENGTH(zl,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> zl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ziplist-的优缺点\">ziplist 的优缺点</h3>\n<h4 id=\"优点\">优点</h4>\n<ul>\n<li>内存利用率高</li>\n</ul>\n<h4 id=\"缺点\">缺点</h4>\n<ul>\n<li>查询效率随着节点数量增多而降低，故只适合存储较少的节点；</li>\n<li>不擅长做修改操作，一旦数据改动，会引发内存realloc，可能导致内存拷贝</li>\n</ul>\n<blockquote>\n<p>Realloc 操作中，会判断分配空间中空余空间是否够用</p>\n<p>如果够用，直接返回；</p>\n<p>如果不够用，则对分配的空间扩容</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 扩容规则</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class=\"line\">    newlen *= <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    newlen += SDS_MAX_PREALLOC;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ziplist对其他数据结构的支持\">ZipList对其他数据结构的支持</h3>\n<p>有很多数据结构都是基于ziplist实现的，如下</p>\n<ul>\n<li>如果Entry直接无关，是一个链表</li>\n<li>如果Entry之间是key-value的关系，则是HashTable</li>\n<li>如果Entry之间是key的关系，则是SET</li>\n<li>如果Entry带有分值排序，则是ZSET</li>\n</ul>\n<h2 id=\"quicklist-快表\">QuickList 快表</h2>\n<h3 id=\"为什么要设计快表\">为什么要设计快表</h3>\n<ul>\n<li>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li>\n<li>ziplist由于是一整块连续内存，存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</li>\n<li>双向链表和ziplist的查询时间复杂度是O(n)，随着表的长度增大，查询效率降低</li>\n</ul>\n<p>设计快表，进而解决以上问题</p>\n<h3 id=\"结构-1\">结构</h3>\n<blockquote>\n<p>A doubly linked list of ziplists</p>\n</blockquote>\n<figure>\n<img src=\"/images/redis/20220823023745778.png\" alt=\"image-20220823023745778\">\n<figcaption aria-hidden=\"true\">image-20220823023745778</figcaption>\n</figure>\n<h4 id=\"头部-1\">头部</h4>\n<p>head：头指针</p>\n<p>tail：尾指针</p>\n<p>count：quicklist中的节点数</p>\n<p>len：quicklist 的 node 数</p>\n<p>fill：控制每个Node上ziplist的长度，含义如下</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>fill取值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>正数，如5</td>\n<td>表示每个quicklist节点的ziplist最多包含5个数据项</td>\n</tr>\n<tr class=\"even\">\n<td>负数，-5</td>\n<td>每个quicklist节点上的ziplist大小不能超过64 Kb</td>\n</tr>\n<tr class=\"odd\">\n<td>负数，-4</td>\n<td>每个quicklist节点上的ziplist大小不能超过32 Kb</td>\n</tr>\n<tr class=\"even\">\n<td>负数，-3</td>\n<td>每个quicklist节点上的ziplist大小不能超过16 Kb</td>\n</tr>\n<tr class=\"odd\">\n<td>负数，-2（默认）</td>\n<td>每个quicklist节点上的ziplist大小不能超过8 Kb</td>\n</tr>\n<tr class=\"even\">\n<td>负数，-1</td>\n<td>每个quicklist节点上的ziplist大小不能超过4 Kb</td>\n</tr>\n</tbody>\n</table>\n<p>compress：控制两端各有几个node不压缩，0=off</p>\n<h3 id=\"quicklist的ziplist设置多长合适\">quicklist的ziplist设置多长合适</h3>\n<p>同样是存储12个数据项，既可以是一个quicklist包含3个节点，而每个节点的ziplist又包含4个数据项，也可以是一个quicklist包含6个节点，而每个节点的ziplist又包含2个数据项。</p>\n<p>这是一个需要找平衡点的问题。只从存储效率上分析一下：</p>\n<ul>\n<li>每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。</li>\n<li>每个quicklist节点上的ziplist越长，在一个ziplist中插入删除节点的成本就会增大，查询效率也会降低。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。</li>\n</ul>\n<h3 id=\"quicklist-的操作\">quicklist 的操作</h3>\n<h4 id=\"quicklist的创建\">quicklist的创建</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Create a new quicklist.</span></span><br><span class=\"line\"><span class=\"comment\"> * Free with quicklistRelease(). */</span></span><br><span class=\"line\">quicklist *<span class=\"title function_\">quicklistCreate</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">quicklist</span> *<span class=\"title\">quicklist</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    quicklist = zmalloc(<span class=\"keyword\">sizeof</span>(*quicklist));</span><br><span class=\"line\">    quicklist-&gt;head = quicklist-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    quicklist-&gt;len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    quicklist-&gt;count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    quicklist-&gt;compress = <span class=\"number\">0</span>;</span><br><span class=\"line\">    quicklist-&gt;fill = <span class=\"number\">-2</span>;</span><br><span class=\"line\">    quicklist-&gt;bookmark_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> quicklist;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"push操作\">push操作</h4>\n<p>不管是在头部还是尾部插入数据，都包含两种情况：</p>\n<ul>\n<li>如果头节点（或尾节点）上ziplist大小没有超过限制（即<code>_quicklistNodeAllowInsert</code>返回1），那么新数据被直接插入到ziplist中（调用<code>ziplistPush</code>）</li>\n<li>如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应的也会新创建一个ziplist），然后把这个新创建的节点插入到quicklist双向链表中（调用<code>_quicklistInsertNodeAfter</code>）</li>\n</ul>\n<h4 id=\"pop操作\">pop操作</h4>\n<p>先从头部或尾部节点的ziplist中把对应的数据项删除，如果在删除后ziplist为空了，那么对应的头部或尾部节点也要删除。删除后还可能涉及到里面节点的解压缩问题</p>\n<h3 id=\"快表的时间复杂度分析\">快表的时间复杂度分析</h3>\n<p>查询：O(count) + O(ziplist-&gt;size)</p>\n<p>表头插入/删除：O(ziplist-&gt;size)</p>\n<p>表尾插入/删除：O(1)</p>\n<p>表中插入/删除：O(count) + O(ziplist-&gt;size)</p>\n<h2 id=\"总结\">总结</h2>\n<ol type=\"1\">\n<li>Redis 的 List 底层采用 quicklist 实现，quicklist 将 linkedlist 和\nziplist 结合，在空间利用率和访问效率上做了平衡</li>\n<li>对于存放数据长度不确定的情况，可以采用变长编码的思路，提高内存利用率</li>\n<li>在对分配空间扩容时，在数据量较少时成倍扩容，到达一定量级后固定步长扩容</li>\n<li>在数据规模不同的情况下，可以采用特定的数据结构，达到针对性的优化。如ziplist在数据量较少的情况，可以做为HashTable，Set，ZSet\n的实现方式</li>\n</ol>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261265&amp;idx=1&amp;sn=e105c4b86a5640c5fc8212cd824f750b&amp;scene=21#wechat_redirect\">Redis内部数据结构详解(4)——ziplist</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261335&amp;idx=1&amp;sn=053d72a348be2e78040f3847f4092d92&amp;scene=19#wechat_redirect\">Redis内部数据结构详解(5)——quicklist</a></p>\n","categories":["redis"],"tags":["redis"]},{"title":"redis RDB 持久化原理","url":"/2023/09/02/redis/redis-rdb/","content":"<blockquote>\n<p>本文介绍 redis RDB 持久化方式的原理</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"问题背景\">问题背景</h2>\n<p>Redis 作为内存数据库，数据存在掉电丢失的问题，虽然 Redis\n中的数据一般是可以丢失的，不过如果由于故障关机，导致全部数据丢失，对系统也带来很大的风险。这时就需要把内存数据持久化到磁盘中，RDB\n则是一个持久化的方式</p>\n<h2 id=\"方案设计\">方案设计</h2>\n<p>在介绍 RDB 原理前，先思考下如何将内存数据持久化到磁盘</p>\n<p><strong>方案1. 主进程中持久化</strong></p>\n<p>Redis 服务启动后，在操作系统中启动了一个进程，这个进程管理着 key -\nvalue，我们只需要遍历这些 k-v，然后写到文件中就可以了</p>\n<p>方案 1\n虽然实现了持久化的功能，但是在写文件的过程中，能否接受数据变更呢？如果有新的写操作进来，那我们最终得到的文件，就存在一些过期的数据，和实际内存中数据有一些\ndiff，关键是我们无法找到这些\ndiff，因为我们不知道数据是何时被写到文件的，也就不知道写入文件后又发生了什么；如果我们不允许有写操作，那么持久化过程中，服务将无法提供写服务，这个过程可能很长</p>\n<p>为了解决上述问题，我们对方案1进行改进</p>\n<p><strong>方案2. 子进程中持久化</strong></p>\n<p>将主进程复制出一个子进程，通过子进程进行持久化，主进程继续向外提供读写服务，记录子进程创建的时间\nt，持久化完成后就得到了 t 时刻的快照，对于 t\n时刻持久化数据是完整和一致的</p>\n<p>这里存在三个问题：</p>\n<ol type=\"1\">\n<li>对父进程的写操作会不会影响子进程的数据</li>\n<li>复制子进程占用多少内存</li>\n<li>复制子进程需要花费多少时间</li>\n</ol>\n<p>对于这些问题，下面介绍下 linux 的 fork 指令</p>\n<h3 id=\"fork\">fork</h3>\n<p>fork 系统调用\n会为当前进程创建一个子进程，子进程拥有父进程的全部数据，父子进程<strong>数据隔离</strong>，父进程的修改不会影响子进程，子进程的修改也不会影响父进程</p>\n<p>这样，子进程就像父进程fork时刻的快照，且在持久化过程中，不会因父进程的写入而改变数据</p>\n<p>如果子进程将父进程的内存拷贝一份，对内存占用量很大，也会比较耗时，所以简单介绍下\nfork 的 copyOnWrite 技术</p>\n<h3 id=\"copy-on-write\">Copy On Write</h3>\n<p>写时复制（COW）：内核并不会立即复制整个地址空间，而是让父子进程共享地址空间，只有在某个进程试图修改共享内存时，才会复制一份专用副本给该进程</p>\n<p><strong>COW 的流程</strong></p>\n<ol type=\"1\">\n<li><p>父子进程共享地址空间，都将PTE设置为只读 R</p>\n<blockquote>\n<p>PTE的全称是Page Table\nEntry，它是一种数据结构，用于描述虚拟内存和物理内存之间的页面映射关系。PTE是页表（Page\nTable）中的一个条目，每个虚拟内存页面都对应一个PTE。PTE包含了一些字段，用于记录当前虚拟内存页面的状态和与之相关的物理内存地址</p>\n<p>Page是内存管理中的单位，linux 中每个 page 大小是 4k</p>\n</blockquote></li>\n</ol>\n<figure>\n<img src=\"/images/java/image-20230831002422506.png\" alt=\"image-20230831002422506\">\n<figcaption aria-hidden=\"true\">image-20230831002422506</figcaption>\n</figure>\n<ol start=\"2\" type=\"1\">\n<li><p>父进程执行 store 指令来更改 page P5 中的数据，由于 PTE\n的状态是只读，会得到一个 page fault。得到 page fault\n之后，我们需要分配一个 page P10，将 page fault 对应的 P5 拷贝到 P10\n上，并将 P10 映射到父进程中，这时 P10 只对父进程可见，所以我们将父进程上\nP10 对应的 PTE 状态改为可读写，然后父进程重新执行 store；现在 P5\n只对子进程可见，所以讲 P5 在子进程上的 PTE 改为可读写</p>\n<blockquote>\n<p>Page fault 页中断异常，触发条件：</p>\n<ol type=\"1\">\n<li>当CPU访问某逻辑地址，而该地址还没有对应的页表项，即还没有分配相应的物理内存并进行映射</li>\n<li>CPU根据虚拟地址查询页表得到的结果是无效的</li>\n<li>发生页访问权限错误，即CPU根据虚拟地址查询页表得到的结果是有效的，但是当前用户没有对该页的访问权限</li>\n</ol>\n</blockquote></li>\n</ol>\n<figure>\n<img src=\"/images/java/image-20230831004941891.png\" alt=\"image-20230831004941891\">\n<figcaption aria-hidden=\"true\">image-20230831004941891</figcaption>\n</figure>\n<p><strong>COW 的优缺点分析</strong></p>\n<ul>\n<li>优点：减少分配和复制大量内存数据带来的空间消耗和操作时延</li>\n<li>缺点：如果在 fork\n后，父子进程还需要继续执行大量写操作时，会产生大量的 page-fault</li>\n</ul>\n<p>所以，fork 出的子进程，不会受父进程写命令的影响，不会拷贝父进程 PTE\n指向的内存，所以效率高，不会消耗大量内存</p>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/336625238\">Copy On Write\nFork</a></p>\n<p><a href=\"https://blog.csdn.net/shadow_zed/article/details/83820345\">Copy On\nWrite机制了解一下</a></p>\n","categories":["redis"],"tags":["redis"]},{"title":"redis数据结构——Sorted Set的底层实现","url":"/2022/08/23/redis/redis-sorted-set/","content":"<blockquote>\n<p>本文描述redis的Sorted\nSet底层实现所用到的数据结构，包括skiplist、dict、ziplist</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"sorted-set-要解决的问题\">Sorted Set 要解决的问题</h2>\n<p>Sorted Set\n是一个有序集合，用于解决去重、按分值排序、查询和范围查询的问题</p>\n<h2 id=\"skiplist\">skiplist</h2>\n<h3 id=\"skiplist-的基本思想二分查找\">skiplist 的基本思想：二分查找</h3>\n<p>第一层：对于有序链表，查询时间复杂度是O(n)</p>\n<p><img src=\"/images/redis/20200427221324575.png\"></p>\n<p>第二层：对第一层每相邻两个节点增加一个指针，让指针指向下下个节点，需要比较的节点数大概只有原来的一半</p>\n<p><img src=\"/images/redis/20200427221348478.png\"></p>\n<p>第三层：对第二层每相邻两个节点增加一个指针</p>\n<p><img src=\"/images/redis/20200427221554998.png\"></p>\n<p>整个查找过程类似于二分查找，时间复杂度降低至O(logn)。但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系，而还需重新维护这种关系</p>\n<h3 id=\"skiplist-的结构\">skiplist 的结构</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZSKIPLIST_MAXLEVEL 32</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ZSKIPLIST_P 0.25</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> &#123;</span></span><br><span class=\"line\">    robj *obj;</span><br><span class=\"line\">    <span class=\"type\">double</span> score;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">backward</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistLevel</span> &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">forward</span>;</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">int</span> span;</span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\">&#125; zskiplistNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplist</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zskiplistNode</span> *<span class=\"title\">header</span>, *<span class=\"title\">tail</span>;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> length;</span><br><span class=\"line\">    <span class=\"type\">int</span> level;</span><br><span class=\"line\">&#125; zskiplist;</span><br></pre></td></tr></table></figure>\n<h3 id=\"skiplist-的构造过程\">skiplist 的构造过程</h3>\n<p>为了避免上面提到的问题，skiplist在构建中不要求两层链表之间严格的对应关系，而是为每个节点随机设置一个层数，每个节点的随机层数的计算过程如下：</p>\n<ol type=\"1\">\n<li>每个节点都有第一层指针</li>\n<li>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p</li>\n<li>节点最大的层数不允许超过一个最大值，记为<strong>MaxLevel</strong>。</li>\n</ol>\n<p>构造过程如下图</p>\n<figure>\n<img src=\"/images/redis/20220822161935812.png\" alt=\"image-20220822161935812\">\n<figcaption aria-hidden=\"true\">image-20220822161935812</figcaption>\n</figure>\n<h3 id=\"搜索过程\">搜索过程</h3>\n<p>应该从哪层开始搜索呢？</p>\n<blockquote>\n<p>在一个16节点的skiplist中，p=1/2，可能存在一种情况是：第一层有9个节点，第2层有4个节点，第三层有2个节点，第14层有1个节点。如果直接从14层开始搜索，将会做很多无用的工作</p>\n</blockquote>\n<p>根据节点层数随机算法，可以得到：</p>\n<p>第一层固定有n个节点</p>\n<p>第二层期望有n*p个节点</p>\n<p>第三层期望有n*p<sup>2</sup>个节点</p>\n<p>...</p>\n<p>假设我们将从第L层开始搜索，期望有1/p个节点。令n*p<sup>L-1</sup>=1/p时，得到当L=log<sub>1/p</sub>n时，会发生这种情况。故我们从第L=log<sub>1/p</sub>n层开始搜索</p>\n<figure>\n<img src=\"/images/redis/20220822162231627.png\" alt=\"image-2022082216223627\">\n<figcaption aria-hidden=\"true\">image-2022082216223627</figcaption>\n</figure>\n<h3 id=\"复杂度分析\">复杂度分析</h3>\n<h4 id=\"时间复杂度\">时间复杂度</h4>\n<p>设C(k)表示在无限列表中爬k个层级后，所需要走过的平均查找路径长度，则\n<span class=\"math display\">\\[\n\\begin{align*}\n&amp; C(0)=0\\\\\n&amp; C(k)=(1-p)*(C(k)+1) + p*(C(k-1)+1)\\\\\n&amp; C(k)=\\frac1p+C(k-1)\\\\\n&amp; C(k)=\\frac{k}{p}\n\\end{align*}\n\\]</span>\n这个结果的意思是，我们每爬升1个层级，需要在查找路径上走1/p步。而我们总共需要攀爬的层级数等于整个skiplist的总层数-1</p>\n<p>由于我们是从L层开始搜索，故总路径长度 = (L-1)/p</p>\n<p>将L=log<sub>1/p</sub>n代入，得到总路径长度 =\n(log<sub>1/p</sub>n-1)/p</p>\n<p>当p=1/2时，2*log<sub>2</sub>n-2，即O(logn)</p>\n<h4 id=\"空间复杂度\">空间复杂度</h4>\n<p><span class=\"math display\">\\[\n1*(1-p)+2*p(1-p)+3*p^2(1-p)+...=(1-p)\\sum_{k=1}^{+∞}kp^{k-1}=（1-p)*\\frac{1}{(1-p)^2}=\\frac{1}{1-p}\n\\]</span></p>\n<p>当p=1/2时，每个节点平均包含的指针数为2；则总的空间复杂度为O(n)</p>\n<h3 id=\"skiplist与平衡数的比较\">skiplist与平衡数的比较</h3>\n<ul>\n<li>内存占用：平衡数的内存占用情况是不可调整的，skiplist可通过参数控制</li>\n<li>范围查找：zset有很多范围查询，在平衡树中需要先找到较小的值然后通过中旬遍历找到较大的值，中旬遍历操作较复杂</li>\n<li>实现成本：平衡树维护平衡关系的操作较复杂，skiplist只需要修改要插入位置前节点的尾指针即可</li>\n</ul>\n<h2 id=\"dict\">dict</h2>\n<h3 id=\"结构\">结构</h3>\n<p><img src=\"/images/redis/20220822211913511.png\"></p>\n<p>说明：</p>\n<p>dict：</p>\n<ol type=\"1\">\n<li>ht[0]与ht[1]是两个哈希表，在不重哈希的时候，只有ht[0]有效，ht[1]没有数据，在重哈希的时候，ht[0]和ht[1]都有效；目的是为了当ht[0]需要扩容rehash时，不阻塞主线程（在发生rehash时，只向ht[1]中写，同时从ht[0]和ht[1]中读）</li>\n<li>rehasidx：-1表示没有在rehash过程，否则在进行rehash</li>\n</ol>\n<p>dictType：</p>\n<ol type=\"1\">\n<li>hashFunction：对key进行哈希值计算的哈希函数</li>\n<li>keyDup和valDup：分别定义key和value的拷贝函数</li>\n<li>keyCompare：定义key的比较操作</li>\n<li>keyDestructor和valDestructor：kye和value的析构函数</li>\n</ol>\n<p>dictEntry：</p>\n<ol type=\"1\">\n<li>k：指向key的指针</li>\n<li>v：直接存放uint64_t、int64_t或double类型，或者指向任意类型的指针</li>\n<li>next：指向下一个dictEntry的指针</li>\n</ol>\n<h2 id=\"zset的实现\">ZSET的实现</h2>\n<ul>\n<li>当数据较少时，sorted set是由ziplist实现的</li>\n<li>当数据多的时候，sorted set是由dict +\nskiplist实现的。其中，dict用来查询数据到分数的对应关系，skiplist用来根据分数查询数据（可能是范围查找）</li>\n</ul>\n<blockquote>\n<p>zset-max-ziplist-entries 128</p>\n<p>zset-max-ziplist-value 64</p>\n</blockquote>\n<p>当sorted\nset中&lt;k,score&gt;个数超过128时，即ziplist数据项超过256，或者，当sorted\nset插入的任意数据的长度超过64字节时，会将ziplist转为dict+skiplist</p>\n<h2 id=\"zset的操作\">ZSET的操作</h2>\n<table>\n<colgroup>\n<col style=\"width: 12%\">\n<col style=\"width: 34%\">\n<col style=\"width: 42%\">\n<col style=\"width: 10%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>操作</th>\n<th>描述</th>\n<th>流程</th>\n<th>时间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>zscore</td>\n<td>查询key的分值</td>\n<td>在dict中查询</td>\n<td>O(1)</td>\n</tr>\n<tr class=\"even\">\n<td>zrevrank</td>\n<td>查询key的排名</td>\n<td>通过key在dict查到score，然后通过score在skiplist查询排名</td>\n<td>O(logn)</td>\n</tr>\n<tr class=\"odd\">\n<td>zrevrange</td>\n<td>根据一个排名范围，查询排名在这个范围内的数据</td>\n<td>在扩展后的skiplist中查询</td>\n<td>O(log(n) + M)</td>\n</tr>\n<tr class=\"even\">\n<td>zrevrangebyscore</td>\n<td>根据分数区间查询数据集合</td>\n<td>在skiplist中查询</td>\n<td>O(log(n) + M)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"http://zhangtielei.com/posts/blog-redis-skiplist.html\">Redis内部数据结构详解(6)——skiplist</a></p>\n<p><a href=\"https://blog.csdn.net/helloworld_ptt/article/details/105801262\">SkipList(跳跃表)详解</a></p>\n","categories":["redis"],"tags":["redis"]},{"title":"总结-动态规划问题","url":"/2022/05/14/algorithm/thought/dynamic-program/","content":"<blockquote>\n<p>动态规划问题思路与题型分类</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"基本思路\">基本思路</h2>\n<ol type=\"1\">\n<li>找到问题的状态（明确dp数组含义）（难点）</li>\n<li>定义base case（填写数组边界值）</li>\n<li>找到状态转移方程（难点）</li>\n<li>填写dp数组</li>\n</ol>\n<h2 id=\"举例分析\">举例分析</h2>\n<blockquote>\n<p>先已知问题是动态规划找思路，再考虑如何判断属于动态规划</p>\n</blockquote>\n<h3 id=\"经典问题\">经典问题</h3>\n<p><a href=\"https://leetcode.cn/problems/min-cost-climbing-stairs/\">746.\n使用最小花费爬楼梯</a></p>\n<p><a href=\"https://leetcode.cn/problems/climbing-stairs/\">70.\n爬楼梯</a></p>\n<p><a href=\"https://leetcode.cn/problems/unique-paths/\">62.\n不同路径</a></p>\n<p><a href=\"https://leetcode.cn/problems/unique-paths-ii/\">63. 不同路径\nII</a></p>\n<h3 id=\"背包问题\">背包问题</h3>\n<h4 id=\"背包\">01背包</h4>\n<p><a href=\"https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85\">01背包</a></p>\n<p><a href=\"https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html\">01背包的滚动数组</a></p>\n<p><a href=\"https://leetcode.cn/problems/partition-equal-subset-sum/\">416.\n分割等和子集</a></p>\n<p><a href=\"https://leetcode.cn/problems/last-stone-weight-ii/\">1049.\n最后一块石头的重量 II</a></p>\n<p><a href=\"https://leetcode.cn/problems/target-sum/\">494.\n目标和</a>（组合问题）（装满背包）</p>\n<p><a href=\"https://leetcode.cn/problems/ones-and-zeroes/\">474.\n一和零</a>（二维背包）</p>\n<h4 id=\"完全背包\">完全背包</h4>\n<p><a href=\"https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html\">完全背包</a></p>\n<p><a href=\"https://leetcode.cn/problems/coin-change-2/\">518. 零钱兑换\nII</a>（装满背包）</p>\n<p><a href=\"https://leetcode.cn/problems/combination-sum-iv/\">377.\n组合总和 Ⅳ</a>（排列问题）（装满背包）（难）</p>\n<h4 id=\"背包问题的总结\">背包问题的总结</h4>\n<blockquote>\n\n</blockquote>\n<h3 id=\"打家劫舍问题\">打家劫舍问题</h3>\n<h3 id=\"子序列问题\">子序列问题</h3>\n<blockquote>\n<p>思路：</p>\n<ol type=\"1\">\n<li><p>确定dp数组含义：<strong>子序列问题一般都是以nums[i]为结尾的{所求代入}</strong></p></li>\n<li><p>base case（边界）</p></li>\n<li><p>状态转移方程：找dp[i]与dp[i-1]的关系，考虑dp[i-1]到dp[i]<strong>关于nums[i]</strong>有几种情况，再求这几种情况的最值</p></li>\n<li><p>填表</p></li>\n</ol>\n</blockquote>\n<p><a href=\"https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=295&amp;fromPut=pc_wzcpa_labuladong_sf\">最大子数组和</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\">最长递增子序列</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-falling-path-sum/\">下降路径最小和</a></p>\n<h3 id=\"股票买卖问题\">股票买卖问题</h3>\n<h3 id=\"编辑距离问题\">编辑距离问题</h3>\n<h3 id=\"技巧型题目\">技巧型题目</h3>\n<blockquote>\n<p>非典型，靠经验</p>\n</blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/russian-doll-envelopes/\">俄罗斯套娃信封问题</a></p>\n<p><a href=\"https://leetcode.cn/problems/integer-break/\">343.\n整数拆分</a></p>\n<p><a href=\"https://leetcode.cn/problems/unique-binary-search-trees/\">96.\n不同的二叉搜索树</a></p>\n<h2 id=\"动态规划的优化方法\">动态规划的优化方法</h2>\n<h3 id=\"空间压缩\">空间压缩</h3>\n<blockquote>\n<p>dp[i]只与dp[i-1]有关，用一维数组代替二维数组，降低空间复杂度，要分清<strong>里层循环的方向</strong></p>\n</blockquote>\n<p><a href=\"https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=295&amp;fromPut=pc_wzcpa_labuladong_sf\">最大子数组和</a></p>\n<p><a href=\"https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html\">0-1背包的滚动数组</a></p>\n<h2 id=\"如何判断一个问题是动态规划\">如何判断一个问题是动态规划</h2>\n<p>根据题目给定的参数范围</p>\n<h2 id=\"reference\">Reference</h2>\n<p>https://labuladong.gitee.io/algo/3/23/67/</p>\n","categories":["algorithm"],"tags":["dynamic-program"]},{"title":"虚拟内存","url":"/2023/09/02/computer-organization/virtual-memory/","content":"<blockquote>\n<p>本文简述操作系统的虚拟内存</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"逻辑地址与物理地址\">逻辑地址与物理地址</h3>\n<p>地址：用 1\n字节将内存分成若干块，每一块头部的地址，称为内存的一个地址</p>\n<p>逻辑地址：也叫虚拟地址，是程序看到的内存地址，是连续的</p>\n<p>物理地址：实际的内存地址</p>\n<blockquote>\n<p>32位操作系统物理地址有 2^32 个，因此最大内存为 2^32 byte = 2 ^ 22 KB\n= 2^12 MB = 2^2 G = 4G，大于4G的内存地址在32位操作系统中无法表示</p>\n<p>任何一个32位程序的逻辑地址最多是2^32个</p>\n</blockquote>\n<p>为什么要有逻辑地址</p>\n<ul>\n<li>安全性：如果进程可以直接操作真实的内存地址，那可能两个进程同时修改同一个内存地址，导致系统崩溃</li>\n<li>隔离性：不同进程之间的逻辑地址是不可见的，也就无法访问其他进程的数据</li>\n<li>连续性：对程序而言，逻辑地址是连续的，方便进行地址计算</li>\n</ul>\n<h3 id=\"逻辑地址和物理地址的映射\">逻辑地址和物理地址的映射</h3>\n<h4 id=\"映射思路\">映射思路</h4>\n<p>方法一：固定偏移量</p>\n<figure>\n<img src=\"/images/java/固定偏移量.drawio.png\" alt=\"固定偏移量.drawio\">\n<figcaption aria-hidden=\"true\">固定偏移量.drawio</figcaption>\n</figure>\n<p>缺点：</p>\n<ol type=\"1\">\n<li>进程分配的内存必须是连续的，如果分配到了另一个进程的内存空间，只能重新申请一份更大的连续空间，并将数据拷贝过去</li>\n<li>产生很多内存碎片，内存利用率低</li>\n</ol>\n<p>方法二：分页</p>\n<blockquote>\n<p>固定偏移量法要求逻辑地址和对应的物理地址必须连续，这点很难实现，所以考虑将连续空间分解成若干小块，再进行对应</p>\n</blockquote>\n<p>将逻辑内存分为多个页（Page），物理内存分为多个叶帧（Page\nFrame），通过页表（Page Table）映射，页表中每个条目是一个 Page Table\nEntry（PTE）</p>\n<figure>\n<img src=\"/images/java/页与页帧.drawio.png\" alt=\"页与页帧.drawio\">\n<figcaption aria-hidden=\"true\">页与页帧.drawio</figcaption>\n</figure>\n<p>一个 Page\n的大小：过大会产生碎片，过小要维护更多的映射关系。根据工业经验，Page\n大小是 4KB</p>\n<h4 id=\"page-table-如何完成地址映射\">Page Table 如何完成地址映射？</h4>\n<p>现在我们有一个逻辑地址 x，想通过 Page\nTable（PT）查到对应的物理地址，PT 的数据结构可以是字典，key =\n逻辑地址，通过散列算法进行映射，但是存在散列冲突和重平衡的问题；或者是一个线性表，长度为Page\n的个数，由于 Page 大小固定，通过计算偏移量得到 Page\n在线性表中对应的坐标，线性表一个单元存储物理地址，或者存物理地址 Page\nFrame 的偏移量，如果保存物理地址（最大值为 2^32-1）需要用 32 bit\n存储；如果存储 Page Frame 的偏移量，则最大偏移量为 4G/4KB - 1 = 2^20 -\n1，需要用 20 bit 来存储</p>\n<p>所以选择存储偏移量，比存储物理地址占用的空间少，这样，物理地址的计算方法为：\n<span class=\"math display\">\\[\n\\begin{align*}\n&amp; PF_x = PT(P_x)*4*2^{10} + x\\%(4*2^{10})\n\\end{align*}\n\\]</span> 其中，Px 为 x 所在 Page 的下标，PT(Px) 为 x 对应的物 PF\n的下标，再转换为物理地址：即下标 * 一叶帧的大小得到 PF 的 head\n地址，再加上 x 在 Page 中的偏移量：x%(4*2^10)</p>\n<p>虽说如何，但是直接存储物理地址更快，所以目前都是直接存储物理地址</p>\n<blockquote>\n<p>地址映射利用了逻辑地址的线性特征</p>\n</blockquote>\n<blockquote>\n<p>问题1：一个进程的页表是一次性建好，还是进程申请内存多少，就创建多少呢？为什么</p>\n<p>答：不确定</p>\n<p>问题2：页表占用多少内存空间</p>\n<p>思考：比如在32位操作系统中，一个进程的页表最多有2<sup>20个，对应的页表最多有2</sup>20个PTE，如果一次性创建长度为2^20的页表，为了方便计算，我们先设一个PTE大小为4Byte，则页表的总空间为\n2^20 * 4B =\n4MB需要4M的内存空间，当有很多进程同时运行时，是一个很大的开销</p>\n</blockquote>\n<h3 id=\"页面置换\">页面置换</h3>\n<p>由于逻辑内存是进程间隔离的，每个进程都认为自己有完整内存空间的逻辑内存，就存在物理内存不够用的情况，当物理内存不够用时，将不常用的内存页面交换到磁盘上，再把这些内存释放和分配给进程。在\nLinux 系统中，可以通过 Swap 分区（Swap Partition）启用Page\n与磁盘交互，Swap\n分区是硬盘上的独立区域，只能用于交换分区，不能存储其他文件</p>\n<p>常见的页面置换算法有：</p>\n<ol type=\"1\">\n<li>先进先出（FIFO）页面置换算法：淘汰最先进入内存的页面</li>\n<li>最不常用（Least Recently Used,\nLRU）页面置换算法：选择最长时间未被使用的页面予以淘汰</li>\n<li>工作集（Working\nSet）页面置换算法：选择当前工作进程实际需要的页面予以保留，淘汰其他页面</li>\n</ol>\n<h3 id=\"page-fault\">Page Fault</h3>\n<p>Page\nFault（缺页异常）是指当程序访问内存时，所访问的页面不在物理内存中，而是被交换到硬盘上。这时，操作系统会触发\ntrap\n机制，进入内核状态，然后通过相应的处理函数将该页面重新加载到内存中，再返回到用户态，继续执行程序。缺页异常是一种实现虚拟内存的重要机制。</p>\n<h3 id=\"页表优化\">页表优化</h3>\n<p>虚拟内存扩展了可用内存，提高了内存使用的安全性，但增多了一步地址转换的步骤，影响了访问内存效率；同时页表自身也占用一定的内存，下面从时间和空间两个角度对页表进行优化</p>\n<h4 id=\"时间优化\">时间优化</h4>\n<p>TLB（Translation Lookaside\nBuffer）是内存中用于实现虚拟地址到物理地址映射的缓存，是MMU（Memory\nManagement\nUnit）的一部分。TLB是一个高速缓存，它存储了当前最可能被访问到的页表项的一个副本，因此可以加快地址翻译的速度，提高处理器性能。当需要将虚拟地址翻译成物理地址时，MMU首先会在TLB中查找是否有匹配的条目，如果有，则称为TLB\nhit，直接使用TLB中保存的结果；否则，MMU需要访问页表，进行慢速的地址翻译，这会产生较大的开销</p>\n<h4 id=\"空间优化\">空间优化</h4>\n<p>上文说过，由于一级页表需要一次性加载完整的页表，对内存的占用很大，页表中很多PTE是空的，导致利用率很低；而一级页表的线性访问又不能将不用的PTE删除掉</p>\n<h5 id=\"二级页表\">二级页表</h5>\n<blockquote>\n<p>二级页表的思路：</p>\n<p>有6个年级，每个年级5个班级，要记录这30个班级，在一级页表的场景中，是创建一个长度为30的表；不过老师们查看班级时基本都只关心本年级的班级，不需要完整的表，所以按照年级创建6个表，额外再创建一个表，表示班级要去哪个年级表中查看。这样，一位老师查看时，会返回一个只有5条记录的表</p>\n</blockquote>\n<p>具体实现方式：</p>\n<p>将虚拟地址的32位分为前10位、中间10位、最后12位</p>\n<p>前10位作为一级页表（PGD）的索引映射到二级页表，中间10位作为二级页表（PTE）的索引映射到页帧的起始地址，最后12位是页内偏移</p>\n<p>物理地址的寻址过程如下图</p>\n<figure>\n<img src=\"/images/java/二级页表.drawio.png\" alt=\"二级页表.drawio\">\n<figcaption aria-hidden=\"true\">二级页表.drawio</figcaption>\n</figure>\n<p>通过虚拟地址的高10位（可表示0 -\n1023），定位到在哪个二级页表中，然后通过中间10位，在对应的二级页表中找到对应的页帧起始地址，最后通过低12位，计算页内偏移量，最后，物理地址\n= 页帧起始地址 + 页内偏移量；这个寻址过程被称为 page table walk</p>\n<p>这种方式看起来只是将之前的一级页面拆成了1024个二级页表，但总的空间没有减少，还加入了地址转换的逻辑，但1024个二级页表不需要同时加载到内存，需要加载一小部分二级页表，其余的页表持久化在磁盘，需要时再加载即可；假设我们最多允许1个二级页表在内存中，需要的内存计算如下：每个页表中有2^10个PTE，一个\nPTE 为4B，需要内存 4KB，相比之前只有一级页表的 4M\n节约了很大的内存空间（emmm...直接 4M/1024 更简单）</p>\n<h5 id=\"三级页表\">三级页表</h5>\n<p>当X86引入物理地址扩展(Pisycal Addrress Extension,\nPAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，页表项从\n4Byte 被扩充到\n8Byte，这意味着，每一页现在能存放的pte数目从1024变成512了。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page\nmiddle directory, PMD)</p>\n<h5 id=\"四级页表\">四级页表</h5>\n<p>64位操作系统中支持了48位的虚拟地址空间，将虚拟地址分为以下五个部分：</p>\n<p>PGD：Page Global Directory（47-39），页全局目录 PUD：Page Upper\nDirectory（38-30），页上级目录 PMD：Page Middle\nDirectory（29-21），页中间目录 PTE：Page Table Entry（20-12），页表项\npage offset: 偏移量</p>\n<figure>\n<img src=\"/images/java/image-20231001182937769.png\" alt=\"image-20231001182937769\">\n<figcaption aria-hidden=\"true\">image-20231001182937769</figcaption>\n</figure>\n<p>三级/四级页表产生的背景、原理还没有弄清楚，但思路和二级页表是一样的</p>\n<h4 id=\"局部性原理\">局部性原理</h4>\n<p>上述的时间优化和空间优化，都是利用了局部性原理：</p>\n<p>局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。具体可以分为时间局部性和空间局部性：</p>\n<ol type=\"1\">\n<li>时间局部性：如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问</li>\n<li>空间局部性：是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问</li>\n</ol>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/631077382\">Linux\n内存管理（一）--虚拟内存</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/627993691\">Linux内核：内存管理——多级页表</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/639166670\">多级页表为什么可以省空间？</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/645063459\">详解虚拟内存如何与物理内存进行映射</a></p>\n","categories":["linux"],"tags":["linux"]},{"title":"快速部署个人博客网站","url":"/2022/05/05/diary/blog-website/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"密码不对哟，请重试\" data-whm=\"Oh, these decrypted content cannot be verified, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"d9a57a7b972e547f58e83c4037dcea0c935a45459b699e1860cff1015b05130e\">9cc172a1f5ae69a375d3a1f55e3dbb3a5ea121b725e47bad14cdc2c2751852da891130fba275f2ea6d97314845075c186550601f61ad431bb1755231b9c82a2b73650817d0bf89a378d52b8e03c096c02bb3827d4419da5c4994f188d8eeb5bd84ab14c035cc18db6e8136d493ee1acd66131896aecefd4d461367ad9af4a95c0d75fed40ba80b9da26231b39ee48f456a9a0f9cff0525fa4b7ba46b14a0a81b7701ea55c08169925ec8c7c5ea35b5e682c9bef7612dcc516656fdc8b6f9fd65a0dce5f6f6e3be12a0d77c65b987e0bb0172271dd7b210c2562a8dd1c48c1aac54967c6ddb74dc56f3a6cbfc88121330d792a8eb5185298491889583a37e26480d9c9214ce5b3b5bfaffe3c255b4f536e938e2841f0882b60a2a0753587647f497f98d35d4c87f3dbbcc284bf84350e6dd6d9d7a6f3a90a466fe02d78fc16de112439e38474d4f0b4a7f500094ca3b72fff94aa0d231dc0f541bd6959f63c9af1f4f7212e82fa14355dd1fba8ba27363077853d181bbb401c30a83095ce79482a4a07da1df5ca3d77a0e35fd49bc540dec6b4cfd140b02b76aabcae265c813203406c329ff0a7ad8a3eb0bf18e711a9fc9183d6f4599f746461026039d51bb6d8ee983843a08f394a7e9758b07501076d4f5fb4eaf5157f52e29aabbd3b4e1cd43e8e7b7f954ac0a5dfa30696b826cdc34bf2a574ca0dfd2c8b99b9ea272ec00189ef45c255e22a24026f4529edcc936219f401b99d19d17ac574e74c5e2c819f4127896ee7ef7b8494b83d7eec320c20ae474575828448a76b22b6a8ae8742a79427e6ac7096145952fce80601c968b33700d541447eeb58bd75c5381c6959fa4c79a9ea4cb6d667fa76a6e64e7a1aeb8a1f67ce2542664ded74c5d88425960cb814ecccbedb7903862e1bbb34f50325a813bb04a06212920857fad0b3576667b6c9d450b5059eb9934f8780c7830fe0a3b7e22644422a7f59d27915a0da813a06c41a1daa294bd9ee32fda7e6f5027362d8050e1bd89f898706df1975111999e9acf068f8c211fadfde8af2bb20ae4e8dd1008cb06593ce356b2a26ac87995e767c2b291a49d1d99d685ee2cd4a27d72086c9112a16f17de8221fd687ff5aa75014cc90b712257ffb8234fea62e363ebc795abe3a829e0c50bb37df9cbcddbaf6b9f8cb4fe44e0846a0b4dc1ccb5a9fc94700d0e91fc46d0bcb6238fd426127ce283509731a0842f39a1f29096f39fa9a9816a20a4995c5eead1091b7ac3054c1843f43e56e57b55c22abfec533da1578bc308d89189f7992bb71d38983fb34aec8ee290c7c14bcc01c0ac18a936d0c568b76883780615cb9bff7137923926ddd0ec68ad4535ad99b52e03c01b537d57c7191757256184df1abd5ac853b7c3e5e6c0184054f8ed163d5138b80bc56844dab0f8e063fbb49c2bba3bcedcc1ff5fedf1b0f5ca206a95999a862f4fa5333aa7a8d6dabeeabf79a863a77beabe876cd5236afb894e2ac3dec83af5f9eff8f945832402118cbc9d34c302934c27a01cf4b2e7068ce5d05d08280bcf8c349d25c95786fec5630a4303816ca96ca6550152d5413bd6f1eb2a09aa9cb25e29af37918b49944c324d5eb831140649587db9d8288fb74ca7e60922e7cc943da89a7c631c0db7e25d5f841ff772171ede77a348353d29ed35f6329638333599b3ae66693afaf48f602d2a47141ceb33e57a98241e1c640ec8e4c2d1df85ce091ab1c3636ecf99352159fb3a423bd8fd1d983aeefca66847b66ce64a169e7e35523414670e7de875b9e7ba50ae87c0e3d20e3ec99e1cadbe262bf86ec3366e0bdc12c0172545f05967c57c84d81274b18a66e2ca691c66160b5cb45f5b1e5ab6d45f078beead9da8a7759a5225d05718df15bf7f06224d36fa6b5447eb3aa27c959fb8dc54eb237c9fcf870825ca5e36ab1aa348513b561d6a6f6cc9ae63793740797fdfaa3e61a979c7a088a896b7f582384d4433b549eec837f9e7a62998396a5f2860adec829e3a3526fd60c2e09dc39f8c449596da52227992b0c5b7fede5a7964240220b915595f2b1cf293c8ce78877548c79b447a94ea8f8ff4f08cb0111ddf3b7ca80bd0778a6608d8a9cc5f9eba94ebef510c57964518373d8b2d333365dec37375fb8fc2ffff56d265a5e8c6b23f65686405132d7ee45f333d37031bad252bd25cf83b2dcf9a8e1b459b9e297b32427ae72d6e247f43f4c1b8e2c9ed03f642532dc67bb7588e06333f687676564c89379541e0705cdeee9cc2cc88e1f065cc25691f2816812b6475c59d0e554fb4fd4de9e3b2fe860c1ca31b9c3211a2756578da4f5ce4c1ffb18d00f2c55834af9a3ee1b34dba149a3370e400f928a4de06dacd356123906b588044bd0c8c370132d313a5448fca570dd1a86d52eff4d43bc50c903a763ac88570509b687afc840f17ba905f6769cb6fef5ddd3d9befd2960aa643a11f46eba6c2e047d2faa656dd64c4ef8851f53407e03475a26e93650c18f43892c0e21496635f8fe6d602957bc591959d547fc131a97b7669f234fabe0373b34873fe0f0a2c2362258b55a31c370d663de07def548f7c4264d76e43590ae9e40781a77f05b032356c4a0371b7cb61e5282ff4416d24e82f0080da1c275446a0b6ffbfcbeac94121b2f3563a151e05156ca9f8a77d13ae61874310131c20854f5d88111934f4919c52b71936a5a485d02f6aa5354d445230e095c51fd16e6007e47ff4dd5c2f1876e3647eac60e3eaa8844ef8a8cb727441abe862aa54efcca6641fb3c0825f88d8ef910fd98c27cad608bc5018884375bf26b26c4db982269fe130a3221e056c15ccfdbdffc35abfc1d4ed7ec39baa29283001719f2140673442e5210a8f63a657079520cf8c6092db5e6502e3bb92286d6f54c0728b5563e2b78b6e78a2fbd398a409a06561c6ddfa6466f4795c68cfce5f8a1f0775396bc184e2654f149548b73ea78508032b674354b28043e48540bd0475cea648419c6563eca040bd7800773bd59b35e280a8f9d06f1c5853ce702d40196aafb41f9cb491cad3ab6b83a7cd3724aceb8d021554ab0567a69ee45c5c4ca16b4f0e8a775c316d3aff414cecd9f7963d3b5435fcaa04eb898b75ca6833ac93a2b525c80787b91f3f5ad25aaa9ccae3d9a447995c8e7bb3882c85ec05d6fd9abaed88360d86a9434c6b6da9c7b65f6289255d6250b57d3e5e10b2ad430415ad0643bf0fb15f87f5c8e148064a42d7cfead62775743486f10376fc96d7013c59635b4498004ae24f25614f007de5739cc84eb00bb2c3ed8974b988b4bad0fc39f67d7d2b8d23a90ea526925911fbf1cdff87d506b23b7c424d0716f3618bd6e8063636d4a1db9b41347c731e73e7216fdec37eb7333431380a1531f2df0ae133f7cf478d443d0b6d3d5ad091333addd5f8ffc8b6736d3b48dc527abe9640b5cf1f988392633c9ea750d51acfe32b439f4a40cc5d937e194153e4a340d376be22dc87500e07b92cea59593876068a706b0f381bb061dd2a9357f1c2e03e025e6641b7da441c4c68600ec9c93fad563e10afc2e4bc0af9ec186e09c9802baeeeb18be2af16ac9818b0f53c75dfec35d29200bceb12bddc5198e3bb94ce3368ff3b67295f32851a10726ffa83026e0d6dc14b688312145e25b4cac3b7f4c3990aeba303b05a541c4a57f73843dc54a18fc4f54e1841f51820e8f60017ba953fd681ce9810810e11ac14cb6ed36d8b05493083d8abad9ea2a4a2dbf6ca4e09bf2d5269c7511ae8c20117cb9cf59ec1b3461c7fe9493773bc988f616cbd64c890eba303fdf841839bd0f32c51d59655e49cbb83ddbd561e08642b6c74929e7added1fd7e9c5bbe8dc14b4b0f587bfd38657828abd4fd6cbe5f2927c87aa6558f1b7d5b33e6e38c7bf75a485b318fecab5a9e7dab360e91dac487dfb35427415378e3aec04d29493cb83597976987a99c1c6d802645fe4c1cea207d11f8b21a6ab6dd8a91120c2d31ba102becbe830da5ca04476c5364c0ed376752c3d512f1aa1b2d7538ffac4a614cff8bfd8b809e66f89b02bf14c9d98967891254f1b18bc5e3a773d6c44db753c5e2a08c72fd96e09f518d8043210be924f436acaecb6355ed26a5048eb263ed8128118583f36fcbbe08156874c8bc652eb8b09b4838925fe81fb121790b8a82da2729305135d5d474fa37a149e9a717af5489c2c872654dcf24aa7e108ddc9547d870d65ff106117e53e61953e31086f68519893936f0d07bef58220ec6936c860905e3b12c29a0283247a04fa32e3891f75cf61b80fcfaf4afbabb0aab461ec657302ff18f3db614aaf4a9fde9c68dfa3bc7af6a6cb718fa1e4164558eee441df1bfd17b7a218dcf91bd8452d6b34f5b4833133d52f18ee7e57bcc09392a89445ad81b4ad151960e60e70edbea2d95b307f07f9650178c7179c5fcac78269e6e6add82001207bb1394edf6ff33db4b007a22bf07cd0900fbb3f351a97991ecbeaebeea7e45b69b824fdbf236879ae5dc3cd66b844b333e1ba6101a022b2157636e87d063bebe08afd28990cab524e8f8553bcf0ac8abb3dae0cf5037aa7d16b982f7f93a6e83e2b6556111a99566c5fe308b0ef3df8d0e5919add8e1e005d739a11283dc6b6b13889a5e8dc3f99165fb3c6235fc3ebc9a4c785ffda8b1d0dcefd6ec3d2f8927148cc189668dfeff9006c46cb99ef3d01127f4da594a95473a55a2f0d03415ff640da101c1d7fca175e123e1654775f532b1bfeab8c74146993ba634426fbbfdf2921ad6f46fa696ecab9a3c5a103edfd5e15dc263b8bd361c133208542f6daa92d51599c10b6efd478c38c37ef70893b3f8e8933c524268c2b9a42c20618f49d1420eb77c15e7e00ff41c0049b5b95b72d4377cbd115784ec769a892d8dcc4ebf97ca37efb0fdaecf7155f30dfaa1be90da6ee9316789316ea9b5a1f24f5ee58e8eb93717c833528a7831d4527d06b98ccf8eb38df56d84c0b12dfddb934c97716e155df8863c7532b4c1838ed717a4bb1b2b223c51451489a4815d8f4b88dc80f05d67cd1c6a4d0021c75a5e22234d59c97440369d4e25af91a243d9c5a3dcef4699fe130793c732ca029ba1106d419d29227436b80b384100ca5f3585f82968476aaf1f457f935e88839fa8eeb32506968d4161da913c33a73c1f698249f7ad74211a1cf75502ba5212773044458b63681887e3f3503ebda04d49005be7f7affbfee8feb8afd5b395e110c0dd2d064bd811ba758d81bffe575ed16b273434111feffd26396730409d6a82d00b3cd0fb0288ddbbb70725dc3ce55517ab1974d5adb7c5350ab9dfc3fd9f50f39d1239377569c64a3117ca2ca664699c289413570439926ddd39d7ab5d4636a941067a41a134d82b7d68dcd7b9cce000b6e2c228d2f4294985adf7065bd4a3b6f8453f69c85f7be7f7eefd17ccd82cf32c760c7fded55401f1d04c2fe114f8623fe5196ca0ca2f7079d048e356fb6fa12b7c72acd2213e12bd070e7bbaac7aa340b4f17fd03161c9250159a2c7afdd1d611b2c904855abbac2093387ea42c3e342ad5e8987a4608db23bb22c0e81552b18663ee72c06d14fb950656cc7bfe23af6aa855eeb168e383198da707f962688a300346ac56bcd52c7b70313d9cbf4dc8e444e7f46fd0269959ea618c8beeff42e545b55a35760731b1954addbeede1f69b25c6dc5115bdd5f1165dc2ca6706ced39b0374669e7f96ee173fef68f8d935819914a757da11e502944f1fbbcdb7e3480e5f400efdc6263a8919b79692b6b43c648b7c892bf7b3a2041622a846d103c35022eff5ec00b93d4cb739767d3f78ef8d1ba462b8b3f6cccb0fa0cb85b74695bfde0ece09a134f3c50963db000f5a7389dfff36c8ba60946668e4f40a21f46e913b8cb084a3a7a08bcf5159eb239b94d8276e767886f82952215ed578665693c9ab57e0b8ce7a9ccfb9554d9ec0170e06a4999cdc89305cee1e15fd481305d6befd7d4bbe72249eaf8a74fecf5d1f03dfdb5360276c4b3d3a4b76d7992993048313613cdaa303afb10cd29365740ada03422640661e4422fc5dd8f6196b07c4e5280a99974c3cc514b29d367f854929bb6a92b3db46180528f390619ab3a9c033dc3a89a18ad3e9af0188f28895777e18f759999d6653407ff98f0177a4de451fb85278bcfb739a81d620d36c86c5908361a5aab1f7f8656b2c048a55e7db72bbf221fc17e10bc25c73e93da5870d4df6b7ab16b7131a3fc692d8f48e5ebe7f2a89e9f4e539b77dd68f8a14865cd306bab5ca9284a052f0f372906fe3ca93aa10e3ef642d79070181c8da3c0a895fefbf503091b59b114f26865d43a3bfeea3be08378bdfe1647ae8878563a2618599e1c7f25d34bb321b5f4b52de24cc720df5e5512b49dbc40f18d0b3770decf3beb883e1af58c1be36038b988e482d3c240573b279c161b7d56ef603cfea5689aeeed3a0a930bb1bfed4438df39321035279807cf6aa9cb14dfbbcbac35e667e8621697a68a8896c4a406b9c1bc19815afa39558ae8981508443d85950289fbd47824b46a253307d2bdb4f94881594365b5ca505e71816b19b0bcb232e19a3c5cc49a1ad9c9700385ce8aa0c660fe25edcec970b142e415d90d506662c0aa772d055872a40130aef8e943ddd1a222eb2b588addd07ff783e09d672fd588343f91012d1df183299d363c8ac97313d482b35c93e0813ccdfcbdbf8b37eca0e25fa634085cd7b76eb97b163fc9563c44418ab4d6a74d6e29249af7ad8b66427ee82ee6cf7878c72d7215efccffd37e919a2279066b0a1ffb2c0526aa7865bc037b64e4ffd4c0636704176bb0ee5235da289b931d7fcb8739c64e9f8cdcb381d59675cebc0dd91948f5a39c4b97aa322b67f819a914715b26fb16b3b16193005d63fae3facae6b87ea147ba9b603c5957590e43aebdea06e8dc85e5297db6029b5c560212c062fbd442d0458c449b80fb7b27714c9b4d0720bb2a491e06331da8d57ced5a2f3884b4dbd3d2c23a486a79c7e527520644ed7396c569c1b25c5e8fae9b87fe858e7b9af0b29010edcc3b66d6059d0329b3e4ca87cfa985cb0ee9b868271ad93d0f62a654b9557bf3c97c0b45ebc2f8ddeb115b76c31bc15c56b2d63a189cecd82c2b6c36f78ccf4d861baa5a86a85e2fc6b038fe6080dd40f0a3f55e4c35acfebc3b09f80ed041ac8eda46d04875c3c060090600dbf647f4f5fa43ab23bcfe93d556d916a202b3ea3040b686e117a9c0ff5cabda50fbd546e84f7e8185c8961078705e5e3ccbf33f6b9f2392ed41d4a6d6b390a85000a9786cd8bbcf930f4b4f1e57a8c2bb75ca8ca28edfecb5e0e61347f24a136d1b6f999ccc3f75003891431e729527d67a47dfb510b06c08dbc3b1f38a77d13c1b57c9afe69299e4db44661bf17210635f643361d33f820233254b5c9085cd3f3c51f8b063a1e94788eb34947e844bf212bc3aae2373ca193268eb1531ae6f2c94fa796ec71b1d917737ba4bced64eca92af4d67cdf9a4dc9638340180bf0969dea92bdbcf35761783a66595b97cb072454f6744bff22bf65dccc97d589b2c74ac8ced487a166fddcc54af196041d64d7c5e7b5f0562bac07ae5c632f42e0a9e2b975a9168318b3363707a8b203734e47b9d85604fb61800c059679d1c3476392e2af3dc91936f80aacfc1d60446b589b61e2362a3070ec9c9553639036458090669e6913a008dc3f792e89af4218d439747733ccbb678ec8a00debaa349418aeb6fd2c452441a9c320d3724b65203df92dbc57439ac903f78a3eef4ca621a6cfc623047ebe486e462e75b10f826b7439c60e8d67f297b3563f40b974f4ca18a1cd4e835bbccdbb86c81becc94f062b79731c4fe7f83c0c0a390cf28124f170e1eb6a795df34185be464f86dfa7dfa32dfae1214d3ecf785b807737d8bd5fed3e3a29f2a3800922a4b0b1c66695d3e772698426500047090fd69b366ca3f04d2f1d4c3f0f19b22b859854a80f48ad63ba02cf9b57704f55b7bda60b0e8946b7ebf4af60891f0fc348b0aad8566c4a52c55053b7fe05e923e847b3e203cff8a7164f02bd336ec1b68e54ab3e4dfcbc0fe3d5857f19dae7229daf3007a71197f2187f25f1c1bb75ba2ec243a77b383c3a26893fafa7f49b235cba2b11298fb1f95b0e7008c63417ba84379f6b776fae2f21ddda874b9d12dd7d5ea661e3055f51ff47218b5af9982aa7949f014a9031a8a7e89c6e775b06b9e787927e670831973de27e5834a10ff3483e26e7fe0fc20c5c903ddd0c72a50ca83d4cf0f96df80ed2842afe213da59bf42b23b8d24f151e9bc30d1704696a1940c88300cbb372c1af9693b0f6e9a9570bc88a1e2367aef80efa1bcfeac95853cc84e6aa92b6729c3d791ce2b0738b01d0f7a49ec80d7a095c30f86da5db6edf3598da9a2d1543c342c68185645bc6715b2f4b13bb135c13806db75b613ea3be9c6a6f947c02669405bdccfb9bc6e693ff3404310434a6dc93ba5a61aa869e53918db01afe2ee8e31fa272305e802a7274d009bb284133edbc2ad5d3e1be4198077b8a21469f9062f4647c4e752485f42e8d573c601024cbc6fbb893216a36b0c0d572de3065fbdb7c85b1e218977a1f361aae46b9a3de375bf2ea7985c10cdfee15d6c833fc70206ac98b58b1a2494111156b2cc307d436109d80826ade5856cf85094086760951fa1ceef6cc49c24c5c557564f036c1c576e48fd048b5ec9ccd91e157988c2e186eb18c04fd41daf21e2dbc955c046341c9acf15fd9a5aa5d922a99f6da8b4d9fb41c14c9230a01d6829e8f4792ee266795365227ec72bab828af0a44cd734ef592449f465891396d843248be48592e1714902eb35a518ec12913451d409c02959c59db6e27e0f80fd5f7f24e8b540f5681f1a1370a39336f8b9041a41b35ed610b15443f362813eaa14199431a130dacc9302c7f85b6ea76e4ad2b6359382ffe99d4a5352b9ad7618c94ecab71f01d00caee778b5cacf33c8e547aeda77958dec33e72451d92107a4ee92c01eae60cf4a3d751cba83ab666687e2f0d2e2e0a2448466dcbd53985d47ae0a7c4171aa2f8732c6bfda5a141e3c78cf2369b991e7b2f3b964380564230b970bc61ab65a0c95b4aef07d3c1f6da73ca51adefc0aab2457169943737ea138c35de4e30572a010bb643fd38ddc1e2518a5cc3f240d4e35f906ed3850d2056b18e7fa939057e53fbd0c4bdf97d1c56819dc06fd76f3ee5414d450d564ec36b1a1fac282908f7104978bd9ba507a96637a5ad5c0208bf2bd2499517c09cf09356ba3694ee4da45019c4e4f9f23691a822bb9ae1de6ac4ed116a6e376898262c390e82614e5992b156a2564952f20013614ea701a3ced6a2c4d771eadbc8e562aa5769a26ede93bc7008eaaddf35015a513162ab39086d5a3db5a3d1c1552e32b8a08bc703887d6c37f035b26e90cac62cb8de6a3975b0438ddcf4c243e09c4ded0e0650dad4fda89ee209cdeaa0165c514227c164a4b8d0f379bf45860bc9fd00efa0c42ea6956f90f6d83c43b2025217993082e7fe864d2c8358f6fcf92f6fad5832de9582f43993eef012e881913ab69af8473dcb3da4ca0b0a00cc6bcbe0095128e401c0108f925848d7113a5ad93814db30c72dc3eca1b96f10a66631db201a3272de037024507efd0479e9fca58a1d3993d7d3a9f8e10b8c54a08db04756e4dbb6f26598a5453b2b9a536ba02cbfdf4f89b7b1f39fb6e1b0e3cee8255269f402b32355a9dc557c835583c772c77801c9b147c467a5a0441b8755697c9e1262028908c38a95764811509787e9f80ea24544278df12b2b9dfc4d06bd149501e1ed720f070925bd55403737754eb21acc4aaafd53d9f2c3a681482e35265c12040285f881d608eb22328a640ffae029bcb33730554315301de3754fa37c00298446bc2eef42fb491510237b64e45d66e5a36c1be8531dc232e4e284b17ca6422a8ff014e5c73d2399f2f09e205b6265487c516ff366ccb365482b0aaadb7a260d2afc51941461828caf16c0895935cb4c84dfeb97bb98b147d55a7098f5aacedc63ee26c4c795699af90aac8d93537c7cd634320ec253d7a01a36c3109093947671658b920fb4577e2515a5588140d14424e32a2e621ee12c1f7c14d704869ce3292016007b8a2f1fe965404e9cfd69cc901e841935da5f369f1ca2fc4c76096531df87ecebb9226b2825872788e74eadf6c250d153d32161135bfda2cca7edf7570b93053b4940c3d46d76ba1bec75d721aaa1c7ba26d3f066620302b85e74587326bffc01d1c90fc4e790963a63993b67a6807ce72aff087d1e9b90488c1ccfa17621023cb81e748cd07a14ad3848c590e50db197bddbd6274a7dd5cdb819fd9161277075449599b0805981db1dab1d63c26117c30349fd27e4ccaa6fc047c8e9ec84204f59429cb6133e30ca58b42a49d4de7cc38288b27f757f9109d2cad1ebc7a8e8f62644ed90c87bc4e06ebe9a05bccb13085ef330654fac3392b10eee2f2791fc4dd4415b90397fb49447e1734f1980fc15e90b9c1eb722efb1117a4bd225d84495e802a23baaef98ec17bed5e52af107c11a67105e87805d7e25e20f519bff452785d74ed8b83b2731706d0ddae9dc8a9489d88c955cf21603097ec5a76938fe965fe48e43ddf587f52b9e12459338d33d9f9496527f812ef680c43dd2b1e87b2df8427413d8540bb373454b4cfc4a8cd25a0f57dcf0f7a070b974b353bab36bf7d75048502f188d0b10d5d46b4d82e739a7f1c05cddff8e5a907a5dd238724501e5d3496da96e22249c9dd34828a67e3183a2ba26d4c02b2e5567535a3f4c6ba19e90c103610537917bc6fb1a027159dc59e0ed4bf88afbb01cb94bca135c48658ced4a48d84483a9263429d6b28cca89275b9cc7bb8ed761afb1a5eb5a8fc0c6a1366ba98167997331f8f46a534d198fb74f2a4bf7f325aa4b0766633ddb4d7f80cc9ee07a777c5d6c43bcc039460a5404065a35cb5ff71c1c4ddd3171caf14eec8294485be85bac974c97b284a9d82f30e20d73c8b1f96a44efb664c26a3d28e3c267d0e8b0e7d670ca5aec6c89da5bec0211ca9814725b2bcbc9154d8303acdf3f5fd30cb4baae2302cb3af097bc290b19211c991759a0c4a0bc5b7d08e4700c45b065a41fef1fd5c042d2ca2d2e0f492c9973ac5c2831f8a78808b2c06700b86ac56d5e1e51fafa2de18cbb1a06856d4e720efd622adeadf2a8ff6ac80aae2f521b72b3402b3c906f1f1d4dd623957c442db5c0b1bf09481e4bee62a11a75787231de627a0d52dbdc0e65baec648b6606f8539b02721b1280c2440f5b8b0b234a3a0290629a5c710052c43033c5a68afa4d037632947d3d766a659f0a527f0e8b4521ef1d9b4e347c129654d69e725cca0832a5b739dc998c8d9e7ab28f725be733b15da95e9236b3a1f4f8c3cd6b065b9c094af47c85fcc13cb431a99c94b44d67a9e10216161bd28a415bf64ad6126712b0cdc8b18dca04631f80258910f8c3ff2a73b57651d4a45903b79fb6a23bca41f5ee9d88192089577bf096a1ee472bdb20f8f34452007c326eb7b4b34be6abe2bc765fa071cf423ebb0e48f37a3baa8b13fbfcd78dc6b9e26a1336c3508b6bf8fd2de0e811b3c2a595759ae2e46039af2207769c9d98cd49d786ed2617defc9b20f878408c3b150a70da0847b302e3b6c797fb3ac98afe57b1006450db09a6586c46f1073bdcfed41653416c619a3040ebf0344fb5b3b1a3fba85825474c53d02fdc04e05dc240ffda6d9d95f6ee591526f0e241697426721cae15a2e5d6782771bfc33158452be1e387dac9c5c1da924b3f4e00925d7bc9a803990e2b</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-flip\">\n      <input class=\"hbe hbe-input-field hbe-input-field-flip\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-flip\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-flip\" data-content=\"Hi，请输入密码\">Hi，请输入密码</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","categories":["personal"],"tags":["hexo"]},{"title":"常用的服务shell命令","url":"/2022/03/28/shell/server-shell/","content":"<h4 id=\"根据服务名查询服务状态\">根据服务名查询服务状态</h4>\n<span id=\"more\"></span>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span></span><br><span class=\"line\">server_name=&#x27;voc&#x27;</span><br><span class=\"line\">jcNumber=`ps -ef | grep $server_name | grep -v grep | wc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">if  [ $jcNumber  -eq  0 ];  then</span><br><span class=\"line\">  echo &#x27;stopped&#x27;</span><br><span class=\"line\">else</span><br><span class=\"line\">  echo &#x27;running&#x27;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h4 id=\"根据port查询服务状态\">根据port查询服务状态</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span></span><br><span class=\"line\">port=8080</span><br><span class=\"line\">jcNumber=`netstat -nlp | grep :$port | wc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">if  [ $jcNumber  -eq  0 ];  then</span><br><span class=\"line\">　　echo &#x27;stopped&#x27;</span><br><span class=\"line\">else</span><br><span class=\"line\">　　echo &#x27;running&#x27;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h4 id=\"根据服务名停止服务\">根据服务名停止服务</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span></span><br><span class=\"line\">server_name=&#x27;voc&#x27;</span><br><span class=\"line\">set -e  # set -o errexit</span><br><span class=\"line\">set -u  # set -o nounset</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"built_in\">set</span> -x  <span class=\"comment\"># set -o xtrace</span></span></span><br><span class=\"line\">set -o pipefail</span><br><span class=\"line\"></span><br><span class=\"line\">ps ux | grep $server_name | grep -v grep | grep -v stop.sh | cut -c 9-15 | xargs kill -s 9</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;kill $server_name done&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"根据port停止服务\">根据port停止服务</h4>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span></span><br><span class=\"line\">port=8080</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查询pid</span></span><br><span class=\"line\">pid=$(netstat -nlp | grep :$port | awk &#x27;&#123;print $7&#125;&#x27; | awk -F &quot;/&quot; &#x27;&#123;print $1&#125;&#x27;);</span><br><span class=\"line\">if [ -n &quot;$pid&quot; ]; then</span><br><span class=\"line\">    kill -9 $pid;</span><br><span class=\"line\">    echo &#x27;kill port: $port, pid: $pid&#x27;</span><br><span class=\"line\">eles</span><br><span class=\"line\">\techo &#x27;no server port at $port&#x27;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n","categories":["shell"],"tags":["shell"]},{"title":"澳洲技术移民调研","url":"/2023/07/07/diary/austrial-migrate-survey/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"密码不对哟，请重试\" data-whm=\"Oh, these decrypted content cannot be verified, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"5dc38f5a2b53fcbbca1115c6b8f733696d5ef1ce2898c31696814b47b93f9a80\">9cc172a1f5ae69a375d3a1f55e3dbb3a5ea121b725e47bad14cdc2c2751852dacf182945915c0807145d065a2bee780454ba354595cc7993b7f6e85e07fabce105dd37526d838625aa609dc849b89af4d7524d65ad326bd8e5594838994d320b00810c2d39aa2610b873e212b1a513cd27e052fd06ebe0c23155d6f746c43b00d5a6d8f5bc30909c79004366a34a3e886bacce9cefa45a7f809903b5cc64aa9e029407e5ccf93bea59a5969d9119c1f568e7285c9297d761eda374bb7bfa8b01a90ce496f93464119f0d21e27713e32884ff077fca88a6ea37181ec3865ae623ff892aafed55d37ef6f098c656ee06d37e0021d466f372c240b3d271cb2457d20c9bf9c6a405e99fb9b37f8ab1ce3e38d4f64e3d3431c2b788b79568a8d338280699ad0b89e4af7083e632a27374a76ac0170572d295d9842609c1b944152ee5b76d6706e2b4e48cbda1983dad0ea1004ddb1ac70500d5e6a9bb728a4bb8d0a56ba51a35fe743fa550cfcff8b491ea4b2c87b2971896ed31dad4198747efbb36c16508501981ff3992ab6dc551c13bf47995a13be5065d6e344dab583ab1e1fdd85d63d0b731c7bc80c5d65b28189dca5dc61af4352c5bcbe84d406b5253eb46baee3f550fcf179130fc49cbb648bd8fcaa158a64f3ce3502f82244ec8af2db9a925e0bad64fc5d2d62251aa50efd6e041cf50fc92c0a6204ae0128f240d1576962653aa0eff3e668f918c24da01f74565b84621798757d7ebb673808f75fdfeb20b0a46ef463f2d8711c6887834dd43f54f769198e4e64225a095295369f0d9a3bbbc8ec323a8c7d40c941ad1116f6e16c7ac868110a3fa6a87a80ffec785fafab59f762019e2273c8a41d2fac0b9e1b94c117b2a7108ac986d7d4edafbf4ba5df8c79533087820ef6d9ab608d09827d61a0e55a5fcd26d5da5bce4e2b98bf5e8ffb1272febd207b5a48152ac0ec494f29baf5a07e5296e546db8dcb0e6092f7fb7e66b6dc44de6a3299340078cac432335ee6b2ed1224d164d9d76b1b8bb8e07c6e02beecaad75ee91754d44b2b80410bd44e3f8e9fd3ad02e6bf7dde1a0a24a4ec43f7110e2a8597c54e84de543c0dbc9853024217e77fd7eb8d714c64cadf7507402415674f8e39a100b132a5be0f6dec7b2a9d7f48f10a7dd4ac5117af03baeadbad55d8324d61aa19fa8f3c4e43a1cc04563665f72265d5d403e7bd30c82c39d5841ee9bbfc40e0e02343ff76e0875eec9b8e0b322131913268f29c76e944742542070141134d22fbc5f2dc55533286a4bd697d7ef468de037f0718ccf0285604eefe4b7afa73b3765bfcb1d0da1c2471df095afa0ac73160d36d2d6736f8532d661e105d5e345eceb7b0595836b3032f803712958addc3d84011f6406b24624ab8bed88bd670eee90fd24f00ec2967151c2025fd36c5a54662d5aaa7d97d4fa22864375bf677589058280dacb44a8a7747235dc0ca596df1e675b49e025e2d61f9fe57d052c79a41f4c01e8d9df123a11dcf85f938c89be2d4f2c9aee8ebaf20d991c164199aa9af7c182e1b4e7c9e70b58b13bbc3adfac3345ec3ebc33f3903e002e8332984c8f614a5e3b3b608cac0b41a0dee421600e6eda1121c0b9093b946bb3817a96f72a8c707e8eb5d1eb3c24466122916e182c1b5ea0e1aeeb391952296e4c63a9f06f7d73de9f3dad84551c5abd89b27259dcf4d2b689a7fac1773244382d65e6f0bddca3b19889b1fffc868ff32eaf35784a4aa3adaed1eb36bb2e130275f81947c1b1149ded2c8b817387c52efedd70cdd4fa1bad1b22cf6b451ba3bed06a115339d0d2551b6a80f0cb52abd7703cad090165387eb637000f9f1e3e131e7f652c87538a3795a6ce1014c4272d22af5a99fb613e1b659ea2739d3e6996ea05173705697190021528f52b6eedbb0b2b4bd5724b28dc1149ae2ffc766c15dab74bc835369f9cd1cd32f1bfd35a35517df8daa91d08c35aeb001b578978b2ab89e40d9685942d236b5df4bb149667975bdf7cc253dd4a5cb4f3be70fc0af3aa3d8666ae213b63cab61005a006eb71d2732737412134f4ed639996b401077bac728de6ff9cdd309e149edb10dfd2f582bdb9036cf639c77a96c39218a9e5d98071df01525f05e82f9321e5237a467159899558c18cf25e833b4e8a4531151ec181f232c53ad510ae3f3bcefcd7c5701fb5f241f913d71763314c5ec66c099aea116e5ebb87d7f110e1a10ea16e25a3d4d883c3f5d44901f1f73bf36c2bfcb0596feced6fb5a21f15232ea331fa380657d8b50903f8b534ca7523fc6ab665d9b1fdd56b96f4e556ac5e30fdb6871db40ef9af1135ac1dab1322436ac497b1944a1d9888fbef817cf6dd3d14c26b714fc36ca5e950679db85e7c7bd61496cf9c807a72971bb73ed48d6c1d414c9a6996eac6484f32b173d2a4475c360a1ad40eabbe6ecb5a6ec23b5f2e4a11a5b7d3b2045aad256bb8ff9313ec667a2139935ba50855a5da7fd5bda1634a038e711a88159e7dc47e4676f9018322315074e579c2e826452c291547d7eb2a9ab50c64ba109e632a8b9a8096e117be9d67783f4f360027cd56709ad5b90c63e0a27c612a78a22f5cc5e2f3d13f7d6b9f73d3605f57426fa28be219b8b43a6911511d346b792f6e4d2984641feda2092a4f6043fd706569924bfba3fa2fb03a0624d595f2d0b2783840e20785fda79b8af10d9df2d135475a234a3f43cd3f334eee0af25df183696095639b1e4704f5ac83ad4eebcc5455e620f19bf63613d3fa085d82f72a02f8c24e1347cee6ca95d5bbd1601ed76b59736c9b279c5a02e103de0d7eb355155d8d8fa0ec8a96dadbadf3c16a6311617eef33d74df41851c2aafb4ed2c22973750d60942755b1db5199fd882e4aafc79b1042f3bfd61fd907b1dce9b11ff22570224d38cbf0c04c264d75c09e1ccc9dc2b221e7590d3f55e986d63f8297e4205aeaed67fd3d416e0624f1b6c49297435023d845a5428b4dbdfb98504cfe137fb646cb039e8b08c60d5a7ff2b0a6ec8460e17de0684249719676d5e1db0cba549fc46df0d466b978d82cf2c7a433f77c631f48302c393fde257654f1528624e3c46c4a5faeb69823ac6efe8e09daaeb583f5b10127b18dc1faf405084064bba8a17d1433e2c4373e4a6de5a1dc71438c1db392c56b9c397f34467cd356faab47a6eff2113f1cf67ecd28c82f82e402e5cc31f39d4ae294c9a68ef2c21d7d461147db6e63fd79f6748586a859472c238fd8c13724bb6a9b67338592eca27833f14957fad7b095d8a2cee920272bf5c05e17fde495de05949b70329d55c18fe1a98a9d367a6569799ba928de08c7d5b5b0fe3582ba46c26b89c435a977313958b1357c602b0e7c7eac7e7e1a103bed5fba87e0c9ce23193b1ac1f471c0e47b62ff1b116446455ee1e71b930bedfa6157bf25a9630d6adc5719739efe3658b375a105d09e79bf2ac6aa0c39b30bbdcc70c3001fd9e6c216c9d29d415ff0e9cbe05f5bcfd42465a10af37355a478bf680452fcd14ac2b23bb42f957a527dea2fb88b677705d3658c076b3079835fc779045ddb511d7ef10e71893554dae28f4287a237ed9056b601b2f39c2839e10a634f0a33a6341e86aea4738eef2526d6f6a6b048a2a9ab85881dd4ba219fd74cff479a9c434c7cda9a20976bf885e31d981d491e67fce9f83eacb23be329f32cfd2e8aba0c1fe13ba7931c8360d774e8fd877a0ae1aac10a666a7b76330efc23ab36e077c1d859476fc5e9671f375f315d5337bb159b926feffda36473f196d0515013785d2d8a4231a208a1bad5248a80c2eccb5ea9afdf563de3a755c976816483eae655db6b1882b224eef48b0b1d7d2cc593686a14f414dca7c98509f20e3c47567ebc587da78d491cb40cbf7ceeb6a296c19f7e5b7c5cf20ef0a63bdf0a95b43af2b4f570f1a090fb441e76ff0e43ff468284e315ddea1b3b96b02a833866b4aaa913a365732e184e016900497e620ee3fe62c027afd1465299fc9ca59374721e8cd76ea6cf2061624fa226840de0dc12c908a63bb7115f68e84fcb020226db1eaa354622fd7b3006442b8a7b74db5336ad2bcaf69bd89f4ad5bb066b7c57140b6cb0575f814d1c9ba48924324c76c55292b9e1d503c888f37acf4aca1aebd5ae341e29148f1a33e1ac9462463db35435566d3be940e870003a70d04c49701f6aadbfee1128499fb8d77e8b1877980e50e46da3a3146a63dcf6c9859e74b2ace6a077fc66722f79b5c1f212253bd7d24353110aaaa107bc9410e56f48e59b78d452b4f8868eb203fde380103a84e7580a50f65df0a49fe4aa89d1478a2e1e4db0a6a0133d2afdcc0787dc33033762e958b44642fd69084093650535376f6829828fbade02e9d08e5b771a19ff212f53d0901b1d615b5638d2fab926d59269ca6c745fac88efd864e12debf56c72311f84379544f0c6ce15b11efb9aaf157250a977c2d864d371c15c37bc85b626586308028df28fcf28f09095bec967aea399002f8bacda8bff0f96035752cfef132ac5dba6686837bd0670a2a76b71a0e8e771ce184961027c300837b3c3db65bc5a3506ca577b664ab80e4458a31b64c25ef2d26ec87d3626456319e5421f6eee0f59aafcb0a1c51dfeef168fdfb049daff75df1b90ef5b17b4a22cdb67677612f328e0052b933c2afc20193417aa760dec4df1da08f492972ec73bbe8a54cf00a9849c867c0d59a08ce7a6139e121f54f0df8182c74347f61e37427950ae9152d5708e79d1239c9a032c1fd1cf963c53395d0964450f1c717bd458aaa7270005fc429f135e24eda7deb3a77616d62953ea4793ffa3b79ef1153dc0f5c05770befa6a58164975a98ac05e66cbe259d40d19a2fa0bfadd7b172a3027e8e4c8dbbb312aa6535a1b555c98b7586613a61255f85115831ddb435779bd7d52bc6cb056f9773a747b4583806ecae60adfaf3da61d1a0c6c88806882d41d68c61e2f8eff186b3bc3b62555c57797a76dad5580bd2cc0b45187fd433f840147bcf8f0fb868cbdc2b0adbf532aa072039261e70a5daca65a1d9d4b9964f9bfe3f2a5103c844ab498435a6d96313e7208230a1e47b6f5ff204a60645c8ab7ffd477657877e2ef222db5129d06331b533ea74a183ffa75aa9f5d0d9ef50773573cae67f5ebde2862a5d6464956c65f7ba114a0ecb410396b68905766ca16a760886a72cd72c47ac61e2ed335abf9b5776b8220d0b291d8b37a0fe70d84d31a08699c58cda974433110c62c59acf177c6571fd09cd3eba1ddac662e69044eec3b51a80d8be6572483ca32d46a7a86ebcad4be22f04e082a93848b4c91684829d02fb841c11d9fb9196badfa23766d56a9e83394309239e2d5082e2fed572dd724415e5928621fc96cb05e6742e701acf76e2511edce82b495e53e0560c9f5c57bd41552078178ec9ca4e30bb1f408f752f611c1a6baea44d4bd792a2594248c2e50ea051fd546fb82b6afa36e73453e6d1ad11a873d58c79ff838ca528edef8810730206f9aeed0a2142fe71459fc66dae1722e9c821bf7bcd0c9a217e150268e2f882b1ba3c73d9d1bb534350cf6981b989d830b78f3cd6ec63e712b1a18e8d154bf446ba0d1c01a47861531f7795152a73699bee7aebc6e354c6c93210ab7d7c9ab968a417d9f2906d33e08d10800147584ae6bc3a4a2766cd8bac162dd376c45a651d8f7ce85d6f4e809e6e64358389a9a6378ea7a677488a83f3f0cfe3e9bdd7ffa41ef746b676fb783c67561495274cdbfb30353c6c5969a7153d2d48ec527ffbe4c16e2baafad68e0aec41e5bcba6855bb7b20725754e0a2f1bb6970cd947a9c3d9b43fdf20f150ebeb22aad33597b7ae136141feb387b44b2698c0cb73645dfb69737df1c39897531486178f753409502efca1f9572fb23635706b6d3908355f7a5b9e79565edb197020720b7f062d24f6054230cb9de54a8a677ad5451ad4001f556cece2c3f884d2f7a814a8aa7bf045202ead7235540a734ae44ecead8120efa4a022554f7b5e063aa48bd1bf8c485369e3f3b0b7d959ea0eff0c84c73a6c08ab133051f91651d6f512ec4eefbd7392a8bbf72816daf8cdb252d8ef16df2580014869037c85820a2cdf3cbc4c3e7fde34ec24f554550c7c1506a9ab0312efc22c27f2232f41389e98e30928e045eafa1bcbe5de126ddf1d9dfe32566a608bd45a84d63eca814bd1e776a7a7bb52d825682913c32a7c75eb8f9ab50bf751ed0024eb32e8d5dbe0092b4382888942be379e5eda2aa46ade9ec536c0c3c8b9a12a6c891dd85232edd739f6f661d2168e4fa98d3bd762b1a6df5cf1f7673efcafdef797d7b32d49cf8aeac8bca1623753694f99b6fdd41fbc8455ffe836e5e0908f85dd71d4a8d75aef42470495ea8b2fab00cb37c8d9fbc457841a64a114924798c30b85d5b061cd77f89ee3ed16c9c63dd66fa44b1b924f86c9e650fb5378e1d1efecf2566a97a582786016d9258365d737213ed3e7a559999b5c1c94c19263edc702fbcdb8d1b696b9cc21375b91d1996d0ff415131ca2ab440be273ad4de77c3a7e12fe49cd4d37d3c107d3543549634a410496c1d98077804fde15bf8c446f1b5dd4094536a18db86a91ed7067b0fa4d2e8fa2209adae96f66d1ba5b7542dd9a5a7ea446d452ced3bbfdcc246d4c769d424e9fe58d1e04edbcf1a8fda04faa813656486d6b076242bb1073c91f45844f9851a7f071186dbd27de7e7ecfdc285ab6224e5feacf374ca32cc2eadbbf75094495e063391c860894ef2d6c163617210406860ff5939e7000b425035336bcac7ed75a77484f5fb3a8d54e1958faa277eb1b0ef4cb5d2caf97debfe8268f03b31e22fc660196e17d468f57037ac7d32cc2320fe9646894c7d6ec8197aa0aaf3c1aa621a5fc1c638dd721348b271ada8090be4295179d76a38ee9c391f76cbf63ff8f72034650d32972d5745984780ff37d866f40be57975b8e21bf48318303e898701bef606936c9f47f58879afec75834e4a1334097b188cdbf553e83eaa42c53a049636dbbe0bb79b814a79003ee3a9541d6184096d2277cf42e675aaef8fbf8e5e88bb5aa68a3961d170d8a64d488937d3bf08a79ee9b3b96b12024f6ef0fc835d78e39df72dbcf2841662ae73a74dd0559b0173fd4d529c9c8100f082f4b2ea99bfb914f0d43c623ff2332e7a559f0b7dd13231fb9770684130d201cbbe3e2c314d56b6af2929ee8006b5c3585aae702b7756fff5ccae00025496ace993acbab019f4021a0bcb7cd2e547d0e85368dc857c181344423c533adc8534c0734bac0fae146fb5b050a49eab2b126831ed44a4b762442c34868e406743713c3b3bb684a116ae5d8ef735eddf2980639ef9c22b8eaa51af784ad445e63711ebfbd402817438fab93ab8a40ebc4d16d26b6c50195913c4d0798c99e68860cc29c7b5310d6613b5ab1e1cd3ed8f31f79a58f0d74e9d3655ee3a8fba37cfdfbad7564a3c963c403a1dfc6df5c9814888d76c73648cb619a709e831119de66c43b997368f6dbf4f41828dc5d1fba9a9066b15606c5af3c3153f104695835610227fe81cde028a83b51a66054bb32e0819ec0afcaeccce5ac09411cd03c90ae7557aefff5e08f3c7292a00a69913e2e664d3c06f88994e84e2fa8b52c07a67ed4b7cdff2207cbc3d4c129d8564340e8b5dc9fe9f10d9b721a1fc892871e44d851b0f43263e3b4e7d76f1875ace7de87f609bd2406d9b906a2a605d27b29fc8b8411aa21ae01f02fd8b5888a6e7bf0118e2c45459181d995fc00d5c390c7b966d8f325b49804c4d77c939ff5c850bd5156a2740de959c38ea5ac1b34f7d597d0ef8e2c414aa404fea7c759f3d66f35c755e4418e52769bbcb13ea2a636f97acf83f8500fca523abeee8ba9e3f19b140a5438ec54d56ead8bf672a3583f101f7a7a0d142b9946e167bf6c30ba692f4878f464131fac7303014c3dc57f44be6704ff7798fe6d52e19bfa226bd8b378cc664629a2d0a213f53d41c79582e92a1c4649b735558cfa5e283761efbb429a4c6a8a648c0e2f59afe1c19f3ccc1b70e4fa2b6e7291ac2bc33d98db5ac940812693bda118d83f07b2220ae8a73c27a727b7318916901b74767d8ac511aee411600ab33e974f9e1d0d0f08459eb60d94e99ccb06a00ea042210ed85e83df67fbbd0ff5e43bc27d1ee8ca1dc3c75827e0f64379568d22d73ed492be652287aeda17f3860b539b6741593613468a963ac86166eb2405afc48e1723f7d25fa19829cb9eac4b2c2d6d6366758f849682a5c94cbf5b71a2ed045f2030ecf22ecdfd37101fa10f7f4db18d0f2e5f75798e802bb341aac7103ebee9251c102c019c6b536a65b846d8226d3b9845ec13914da5f46440e34135989ec49efcc70f8ec418ee0cc92b863e150a4e0236ab30de7315427d07e310e974ba560e7cdb19944279755c282f22f3078245074e9b18155f2e93482228434ce4abf2f98219c1cb59401ecb7a66702a2ebd96e5863d7f9aaf4a7059b8531b10cc4fdf76f38df86e9ac4c2485eb8a0d05953ec7abdd4fcbad7e375c7cf3a27c09c3e06abf71fd249f6fa5c4f687e847fbbad134de35f0dfe61d7e25919017ba2b9a6c5928cf2d9ef77461ea0870387301e5b78fb6b49a652335bbcadfd77e294e17eff95619c39a202bc9bb2831437c50bf5d56ce58f26669021bfb1e2d86435aae1a270297b110df0f181c055033b017bcecb7c95137beee8f10febbc2726b1ed7deb4a826ecea38562949ea9c2fbc9e8a5f3e318fd87c5189329245724049f23d09f36cab1bb605ee33819ecce1896d05a6c982c0581a24fd246179840680b822e1640e6942438ca99666a8dafb61f4642c0237ab8a78c0801ed623c204fec845a57eed3e0fa2136ecc378e894c3f65c17c6ccffdb32728b88d5720f50cb31f1574da43f8ff6b16b13c6d338be81194089b686d818c68b6c655cafddb0ddb4fc8a64f425d035f42695fe74e8afa0f39044175f8c91a81ae5b0963021fa27a9e15a76562739a0881db4415f72dcaca6bc2e8a1c4246191d0716824d59d2b9f7d9037b8ea012a993176a485187faab8fc81bc77ec5693479235659db81f7d0ffe6463fe2702aa16840197208b3abbe753df6d23a568f32b8429ba25ca458034b3863d78b531eac3aae0a7315be12e8b1eaa88ba72e69cb9414cb79624fcd0f04952395a53da2b27e37abbf46f2213400f700ce1f61cf21ba8f09a0bf7bb14c5d4251b6d07ae9e1c4382a7a060baeb65454eb958529fc4a51d7c8fbd5421a19ab428356a7636241c039ab53b6ea927d2f5624af6200ebfea868be5bfe15d1b2b377797b3d3a76a240d44b860235bd18ddd3dd79c0e5c9f8af6ca5513c5cf1ae47c1e3dae29a30d47082f7b2de904ef95e65bdaca4cb508b7af4f8a7f13d739e8a94da07deb3c44a612d8672c83b6516aede4245311397f0885ca161402ad9f212d471a0739f218634ac1ed71745fd35754a06460ce0297595a5f7b51321621c65c793bc1601dd86b1fd6278a57b3fb75c71bde675bb15518c39b484738dabd26f97a810b753582966d970528eb86a42ca24adfddb6bb7846b3abab3cfae1ec53b8792e476e0acd7d5561ae661ae61adcbb11c53deb7837f7a49b5e15a679941311ac41997ab78669e52bb27d97ea4f4e9b8544ef0fc492638d64bc422af4beb16359e93dc19b30fc370f4c1e49232ca2e5d3a71f2db3213e8b71556b24e06e399dea13d55d2ffafd6dd785feaeb71c942f0c9badf6416afdb1650a8c6d5eeb8ac8c02f755c6602c3e9f1f113c4527c2f07ccc4f86ea931ed64df1e40d807493b7f2398c7657acb292cb40bb572aaff4dd0ee13458ca19541dd40258feae5efa9cc925384c1d47412ef036b12718ac9ba439c8c43500f913b435ed3825e30fe19aa046b411d26f546ed13e7af3d2dd22598efd6d3677ded2bbc99070e8e97de935d88feccefe84c6842b4e4b37425ea34df5a6a01832100d2cf3f06bc79eb1887c98b738803ed465cf005ae32f63a49671575b1174016344cae9acbb69e9fe2603ffb02100a36ab3a7684854448426a1e93b24ab06f03e2ba61864a00ef438da10d541677bf44a070ca740a52c427763fa5def204d304b9875bdfdfb94ac5c9e8a3760c84032de853313e612e028f18709bc635fc9c7b99718005a682858398f1fb72ad398993b22aeb698006fdf16059bb143549d72da702d3b15379b87535d2475e98895bd78dbf599d90b1350f52014fd755ed2c12aff4c2782ee2ca84c258971e3c284b706c5e0c2c06bcdab0a616e0e174cb6f30f016cff21e9add502f55f07336bfaaba6aa978513bd2950035814ff7562bebdd9b3b166ddb4c41342642fb5a6b8f1d48e1529a52aed7026297b0bfc3a1cf2a157158601982dcf8bb0fd7cc7c4896cb0156d63f968f91d4c41ff11a49c47b832d14a5739fc4856fb2513111454c7f9e0667151166fb3eea2bd24bf51adabcf3a090abccff1567ae7c4d7404fe268975cb206bbb24d7807f67f05fe5aed7da006d2db1645977acefa23b5d9d56f35154efcff1984b40694ce0dc7dab1b8c337d2c785f88639eafa63aecd6d1942a7bdb42be41fa40d9bf7b97adab376eed138e1aaec0fe921a5825a617db1cd3763f7223b1f28b0facd204a036adc0e282fdb7f0b8de84b6290311411f3b05e3b5f1c59722b9b03d0a72fc8bbd15901926434c16510cd5cfd770c898fbf8bcf3a42e6019d36468abb7a3f72d7199b34987e53ebf22845f79e8d37b9e9c6ef9b67e7439a5cfc52d9b90ab34d4cec8306f49211c1977ad2dd3321b767b9fb9c7323a9956ebfcc90c412c093f68b1df41e0360f01844496184305f40df8aa6166384a74915b2f8754657f620</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-flip\">\n      <input class=\"hbe hbe-input-field hbe-input-field-flip\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-flip\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-flip\" data-content=\"Hi，请输入密码\">Hi，请输入密码</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","categories":["personal"],"tags":["study-plan"]},{"title":"redis 哈希环","url":"/2023/10/06/redis/redis-hash-ring/","content":"<blockquote>\n<p>本文介绍 redis 哈希环的原理</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"背景\">背景</h2>\n<p>我们使用一主多从的 Redis\n集群存储数据，总的容量不会随从节点的增多而增多，如果容量遇到单机瓶颈，需要扩展主节点机器，让每个主节点存储一部分数据，来提高总的存储空间。假设我们现有3台主节点，我们需要使用一个散列算法把数据映射到这3台主节点上，方法如下\n<span class=\"math display\">\\[\nmasterId = hash(key) \\% 3\n\\]</span>\n这种方法存在一个很严重的问题，即当容量不足时需要扩容，散列方法发生了变化，而数据还在原来的节点上，就需要对所有的数据重新散列一遍，造成大量的数据迁移，对性能产生较大影响</p>\n<blockquote>\n<p>Redis集群能否一边迁移一边对外提供服务呢？</p>\n<p>从读写两个角度来分析下：</p>\n<p>读：按新的hash算法取值，没有再按旧的hash算法取值</p>\n<p>写：按旧的hash算法写，如果没有再按新的hash算法取值</p>\n<p>这样看，在数据迁移过程中，Redis\n集群是可以对外提供读写服务的，但主要问题在于全量数据迁移导致资源和性能的浪费</p>\n</blockquote>\n<p>为了解决这个问题，产生了哈希环的数据一致性算法</p>\n<h2 id=\"hash-环\">hash 环</h2>\n<p>hash 环的一致性算法会建立一个有 2^32\n个槽点的环，对于一台主节点（masterA），会通过 hash(masterA) % 2^32\n得到一个槽点 A，对于一个 key = K1，同样使用 hash(K1) % 2^32\n映射到环上，然后以该点出发，顺时针遇到的第一个主节点，即为数据存储的主节点</p>\n<figure>\n<img src=\"/images/redis/hash_ring.drawio.png\" alt=\"hash_ring.drawio\">\n<figcaption aria-hidden=\"true\">hash_ring.drawio</figcaption>\n</figure>\n<h3 id=\"hash-环上的数据迁移\">hash 环上的数据迁移</h3>\n<p>如果新增一个节点，如 masterA 和 masterB 之间插入一个节点D，只需要迁移\nA 与 B 之间的数据，而不需要全量迁移</p>\n<figure>\n<img src=\"/images/redis/hash_ring.drawio-1.png\" alt=\"hash_ring.drawio-1\">\n<figcaption aria-hidden=\"true\">hash_ring.drawio-1</figcaption>\n</figure>\n<h3 id=\"hash-环的数据倾斜\">hash 环的数据倾斜</h3>\n<p>用多台机器分别存储数据，理想情况下希望数据能均匀分布，如果 hash\n环上的节点分布不均匀，都集中在一部分时，数据会倾斜到某个节点上，一方面，对某个节点的压力较大，成为系统瓶颈，另一方面，在插入/删除节点时，可能造成大量数据失效和迁移</p>\n<p>如下图，数据倾斜在 masterB 中，masterB\n的负载会明显高于其他节点；如果B失效，会有大量数据倾向到 masterA</p>\n<figure>\n<img src=\"/images/redis/hash_ring.drawio-2.png\" alt=\"hash_ring.drawio-2\">\n<figcaption aria-hidden=\"true\">hash_ring.drawio-2</figcaption>\n</figure>\n<h4 id=\"虚拟节点\">虚拟节点</h4>\n<p>为了解决数据倾斜问题，引入了虚拟节点，比如指定每个实际节点会有 100\n个虚拟节点，每个虚拟节点按照 {实际节点编号}#{虚拟节点序号}\n的方式命名，如 masterA#1，然后通过散列函数映射到 hash 环上，这样会使\nhash\n环上的节点更多，从而减少数据倾斜程度；在操作数据时，如果命中了虚拟节点，则到对应的实际节点上执行操作</p>\n","categories":["redis"],"tags":["redis"]},{"title":"自己实现一套应用层网络协议","url":"/2023/10/17/dubbo/application-layer-protocol/","content":"<blockquote>\n<p>本文介绍如何自己实现一套应用层网络协议</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"应用层协议要解决的问题\">应用层协议要解决的问题</h2>\n<p>应用层协议有\nhttp，FTP，SMTP，dubbo等，以http协议为例，数据包的传输过程如下</p>\n<figure>\n<img src=\"/images/dubbo/image-20231007221130080.png\" alt=\"image-20231007221130080\">\n<figcaption aria-hidden=\"true\">image-20231007221130080</figcaption>\n</figure>\n<p>Ref https://zhuanlan.zhihu.com/p/648405247</p>\n<p>Ref:\nhttps://blog.csdn.net/why_still_confused/article/details/86599613</p>\n<p>传输层协议不关心数据是什么格式和含义，都按照字节流的形式交给应用层处理，应用层解析协议头和数据部分等</p>\n<p>所以，应用层要解决的问题有：</p>\n<ol type=\"1\">\n<li>解析传输层数据</li>\n<li>将数据交给应用为使用者服务</li>\n</ol>\n<h2 id=\"应用层协议的实现思路\">应用层协议的实现思路</h2>\n<p>想自己实现一套应用层协议的思路如下：</p>\n<ol type=\"1\">\n<li>需要定义应用层协议头格式</li>\n<li>根据协议头格式，解析协议头</li>\n<li>根据协议头，解析数据部分</li>\n</ol>\n<p>下面设计一套简单的应用层协议（Timo）仅供参考</p>\n<h3 id=\"定义协议头\">定义协议头</h3>\n<p>对数据的处理方式，可以分为：</p>\n<ol type=\"1\">\n<li><p>固定长度协议</p>\n<p>每条消息长度固定，读写效率比较高，但消息过小存在浪费，超过限制则需拼接</p></li>\n<li><p>特殊终止符协议</p>\n<p>每条消息都有一个特殊终止符表示消息结束，不会浪费空间，接收时需要搜索终止符来确定结束位置，如果内容中包含了终止符需要转移处理</p></li>\n<li><p>可变长协议</p>\n<p>每条消息的长度可变，由头部标志消息长度，不会浪费空间，需要解析消息头来确定长度</p></li>\n</ol>\n<p>注：消息指一个完整的应用层数据包，在传输层可能是多个TCP数据包</p>\n<p>参考 Dubbo 协议头，定义 Timo 的协议头如下：</p>\n<table>\n<colgroup>\n<col style=\"width: 16%\">\n<col style=\"width: 18%\">\n<col style=\"width: 6%\">\n<col style=\"width: 11%\">\n<col style=\"width: 21%\">\n<col style=\"width: 8%\">\n<col style=\"width: 8%\">\n<col style=\"width: 9%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>Bit offset</th>\n<th>0-23</th>\n<th>24</th>\n<th>25</th>\n<th>26-27</th>\n<th>28-31</th>\n<th>32-63</th>\n<th>64 - ?</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>含义</td>\n<td>Magic Value</td>\n<td>req</td>\n<td>success</td>\n<td>serialization</td>\n<td>code</td>\n<td>len</td>\n<td>data</td>\n</tr>\n</tbody>\n</table>\n<p>其中：</p>\n<ol type=\"1\">\n<li>Magic Value是固定的 24 位二进制，用于判断是否是 Timo 协议</li>\n<li>req：0表示请求，1表示响应，长度1bit</li>\n<li>success：1表示成功，0表示失败，长度1bit</li>\n<li>serialization\n表示序列化方法，长度2bit，最多支持4种序列化方法，0表示json，1表示Hessian，2表示XML，3表示Kryo</li>\n<li>code 表示状态码，长度4bit</li>\n<li>len 表示数据长度，长度32bit，最大支持传输2^32-1长度的数据</li>\n<li>data 表示数据部分，变长</li>\n</ol>\n<h3 id=\"解析协议头\">解析协议头</h3>\n<p>以 TCP 协议为例，TCP\n协议会解析出数据包的数据部分（是一个字节数组），Timo\n协议拿到这个字节数组，取前32位，则拿到了 Timo\n协议头（如果长度不足32位等待下一个TCP数据包组成一起），然后根据上面定义的格式，解析出各部分含义</p>\n<h3 id=\"解析数据\">解析数据</h3>\n<p>由于 TCP 存在粘包和拆包，所以一个 TCP 数据包不一定包含了完整的 Timo\ndata，需要根据 len 判断，如果当前数据包末位大于 head size +\nlen，则截取到 head size + len 位置，如果当前数据包末位小于 head size +\nlen，则等待下一个 TCP 包到后再判断，直到找到完整的 data，再根据\nserialization 解析</p>\n<h2 id=\"实例\">实例</h2>\n<p>服务端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">(<span class=\"type\">int</span> port)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">serverSocket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>(port);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;服务端已启动，等待客户端连接...&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> serverSocket.accept();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;客户端已连接: &quot;</span> + client.getRemoteSocketAddress());</span><br><span class=\"line\">        <span class=\"type\">BufferedInputStream</span> <span class=\"variable\">bis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(client.getInputStream());</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PrintWriter</span>(client.getOutputStream(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">// 从缓冲区读取字节流</span></span><br><span class=\"line\">            <span class=\"type\">byte</span>[] bytes = readFromBufferForLen(bis);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bytes == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                out.println(Timo.encode(GsonUtils.toJson(ResponseFactory.fail())));</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 解码</span></span><br><span class=\"line\">            <span class=\"type\">Dog</span> <span class=\"variable\">dog</span> <span class=\"operator\">=</span> Timo.decode(bytes, Dog.class);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dog == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;exit&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;dog: &quot;</span> + dog);</span><br><span class=\"line\">            out.println(Timo.encode(GsonUtils.toJson(ResponseFactory.success())));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bis.close();</span><br><span class=\"line\">        out.close();</span><br><span class=\"line\">        client.close();</span><br><span class=\"line\">        serverSocket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        start(<span class=\"number\">8080</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">(<span class=\"type\">int</span> port)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>(<span class=\"string\">&quot;0.0.0.0&quot;</span>, port);</span><br><span class=\"line\">        socket.setSendBufferSize(<span class=\"number\">30</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;已连接到服务器 &quot;</span> + socket.getRemoteSocketAddress());</span><br><span class=\"line\">        <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in));</span><br><span class=\"line\">        <span class=\"type\">BufferedInputStream</span> <span class=\"variable\">bis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(socket.getInputStream());</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PrintWriter</span>(socket.getOutputStream(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> reader.readLine();</span><br><span class=\"line\">            <span class=\"type\">Dog</span> <span class=\"variable\">dog</span> <span class=\"operator\">=</span> DogFactory.makeDog();</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">requestBody</span> <span class=\"operator\">=</span> GsonUtils.toJson(dog);</span><br><span class=\"line\">            requestBody = Timo.encode(requestBody);</span><br><span class=\"line\">            out.println(requestBody);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (input.equals(<span class=\"string\">&quot;bye&quot;</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">byte</span>[] bytes = readFromBuffer(bis);</span><br><span class=\"line\">            <span class=\"type\">Response</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> Timo.decode(bytes, Response.class);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;服务端响应: &quot;</span> + response);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reader.close();</span><br><span class=\"line\">        out.close();</span><br><span class=\"line\">        socket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        start(<span class=\"number\">8080</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>协议解析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Header <span class=\"title function_\">decodeHeader</span><span class=\"params\">(<span class=\"type\">byte</span>[] head)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;解析协议头&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">byte</span>[] signal = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        signal[i] = head[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">signalStr</span> <span class=\"operator\">=</span> ByteUtils.printBytesToStr(signal, <span class=\"string\">&quot;魔法值&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 请求 or 响应</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">req</span> <span class=\"operator\">=</span> head[<span class=\"number\">4</span>] &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 是否成功</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> (head[<span class=\"number\">4</span>] &gt;&gt; <span class=\"number\">1</span>) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 序列化方法</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">serial</span> <span class=\"operator\">=</span> (head[<span class=\"number\">4</span>] &gt;&gt; <span class=\"number\">2</span>) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">  \t<span class=\"comment\">// 数据长度</span></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] lenBytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">        lenBytes[i] = head[<span class=\"number\">3</span> + i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> ByteUtils.bytesToInt(lenBytes);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;数据长度:&quot;</span> + len);</span><br><span class=\"line\">    <span class=\"type\">Header</span> <span class=\"variable\">header</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Header</span>();</span><br><span class=\"line\">    header.setSignal(signalStr);</span><br><span class=\"line\">    header.setLen(len);</span><br><span class=\"line\">    </span><br><span class=\"line\">    header.setSerialization(serial);</span><br><span class=\"line\">    header.setRequest(req == <span class=\"number\">1</span>);</span><br><span class=\"line\">    header.setSuccess(success == <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> header;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>协议构造同理，解析数据比较困难，需要根据解析出来的 len\n截取字节流，或者等待下一个包，没写出来</p>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1750157486254257485&amp;wfr=spider&amp;for=pc\">我们一起来聊聊Dubbo协议</a></p>\n","categories":["dubbo"],"tags":["dubbo"]},{"title":"dubbo 负载均衡策略","url":"/2023/11/14/dubbo/dubbo-loadbalance/","content":"<blockquote>\n<p>本文简述 Dubbo 的负载均衡的几种策略</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"dubbo-负载均衡的原理\">Dubbo 负载均衡的原理</h2>\n<p>从注册中心（如 zookeeper）拉取 provider 信息，保存在客户端，封装成\ninvoker 对象，再使用某种负载均衡策略选择一个 invoker 提供服务</p>\n<p>org.apache.dubbo.rpc.protocol.AbstractInvoker</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractInvoker</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Invoker</span>&lt;T&gt; &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> URL url;\t<span class=\"comment\">// 路径</span></span><br><span class=\"line\">  \t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">available</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;\t<span class=\"comment\">// 可用性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String version;\t<span class=\"comment\">// 版本号</span></span><br><span class=\"line\">  \t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"dubbo-提供的负载均衡策略\">Dubbo 提供的负载均衡策略</h2>\n<ul>\n<li>Random：随机</li>\n<li>RoundRobin：轮询</li>\n<li>LeastActive：最少活跃调用数</li>\n<li>ShortestResponse：最短响应时间</li>\n<li>ConsistentHash：一致性哈希</li>\n<li>P2C：Power of Two Choice</li>\n<li>Adaptive：自适应</li>\n</ul>\n<h3 id=\"random\">Random</h3>\n<p>org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance#doSelect</p>\n<p>从 invoker 列表中随机选择一个，或者加权随机</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Number of invokers</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> invokers.size();</span><br><span class=\"line\"><span class=\"comment\">// 随机选择一个 invoker</span></span><br><span class=\"line\">invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br></pre></td></tr></table></figure>\n<p>随机选择在短时间内不同 invoker\n之间存在一定差异，长期累计会比较均匀</p>\n<h3 id=\"roundrobin\">RoundRobin</h3>\n<p>org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance#doSelect</p>\n<p>轮训法（RR）从 invoker 列表中按顺序选择一个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">atomicInteger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class=\"title function_\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">currentInvokerIndex</span> <span class=\"operator\">=</span> atomicInteger.incrementAndGet() % invokers.size();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokers.get(currentInvokerIndex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>加权轮询（Weighted Round Robin，WRR）</strong></p>\n<p>在 RR 基础上考虑 invoker 性能，下面有两种实现思路：</p>\n<p><strong>思路一</strong>：将 invokers 按权重数生成一个集合，按 RR\n的方式按顺序选择</p>\n<p>这种方式流量短时间聚集在一个服务上，过了这段时间要等到下一轮才被分配，导致每个服务的流量不平稳（波动起伏），比如权重为\n10:3:3 的分配结果为：[0-9, 10-12,\n13-15]，这样带来的问题是，流量可能有尖刺，对保障的要求提高</p>\n<p><strong>思路二：平滑加权轮询</strong>，操作步骤如下：</p>\n<ol type=\"1\">\n<li>为每个 invoker 设置两个权重，weight 和 currentWeight，weight\n为用户配置的权重（固定），currentWeight 是当前权重（动态变化），初始值为\n0</li>\n<li>第一次轮询，currentWeight = weight</li>\n<li>后面的轮询，被选中的 invoker 的 currentWeight = currentWeight -\n权重之和</li>\n<li>所有 invoker 的 currentWeight = currentWeight + weight</li>\n</ol>\n<p>举个例子描述下这个过程：</p>\n<p>我们有三个 invoker a, b, c，权重比为 5: 2: 1，a b c 的 currentWeight\n变化如下</p>\n<ol type=\"1\">\n<li>Step0：a b c = 0 0 0（初始化）</li>\n<li>Step1：a b c = 5 2 1（加 weight，a 的 currentWeight 最大，选择\na）</li>\n<li>a b c = -3 2 1（a 减总权重 8）</li>\n<li>a b c = 2 4 2（加 weight，b 的 currentWeight 最大，选择 b）</li>\n<li>a b c = 2 -4 2（b 减总权重 8）</li>\n<li>a b c = 7 -2 3（加 weight，a 的 currentWeight 最大，选择 a）</li>\n<li>a b c = -1 -2 3（a 减总权重 8）</li>\n<li>a b c = 4 0 4（加 weight，a、c 的 currentWeight 相等，选择 weight\n大的，选择 a）</li>\n<li>a b c = -4 0 4（a 减总权重 8）</li>\n<li>a b c = 1 2 5（加 weight，c 的 currentWeight 最大，选择 c）</li>\n<li>a b c = 1 2 -3（c 减总权重 8）</li>\n<li>a b c = 6 4 -2（选 a）</li>\n<li>a b c = -2 4 -2（a - 8）</li>\n<li>a b c = 3 6 -1（选 b）</li>\n<li>a b c = 3 -2 -1（b - 8）</li>\n<li>a b c = 8 0 0（选 a）</li>\n<li>a b c = 0 0 0（a - 8）</li>\n</ol>\n<p>最终一轮的分配情况为：<strong>a, b, a, a, c, a, b, a</strong></p>\n<p>对比普通加权轮询的分配情况：<strong>a, a, a, a, a, b, b,\nc</strong>，平滑加权轮询保证权重分配不变，且分配更平滑</p>\n<blockquote>\n<p>一般的生产环境都是通过 k8s\n编排出相同配置的服务容器，感觉不太常用WRR，不过这种思想还挺有意思的，即：有权重要选择一个最大值时，可以通过加weight减totalWeight的方式，达到平滑的效果</p>\n</blockquote>\n<h3 id=\"leastactive\">leastActive</h3>\n<p>org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance#doSelect</p>\n<p>统计每个 invoker 的活跃调用数，选择活跃调用数最小的 invoker</p>\n<h3 id=\"shortestresponse\">ShortestResponse</h3>\n<p>统计每个 invoker\n在过去一段时间内的平均响应时间，选择平均响应时间最小的 invoker</p>\n<h3 id=\"consitenthash\">ConsitentHash</h3>\n<p>将请求参数或标识进行哈希计算，选择哈希值最接近的 invoker</p>\n<p>由客户端请求决定分配情况，适用于用户和服务节点反复通讯的场景</p>\n<h3 id=\"p2c\">P2C</h3>\n<p>Power of Two Choice 算法简单但是经典，主要思路如下：</p>\n<ol type=\"1\">\n<li>对于每次调用，从可用的 invoker 列表中做两次随机选择，选出两个节点\ninvokerA 和 invokerB</li>\n<li>比较 invokerA 和 invokerB\n两个节点，选择当前正在处理的连接数较小的那个节点</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; Invoker&lt;T&gt; <span class=\"title function_\">selectByP2C</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> invokers.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(length == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> chooseLowLoadInvoker(invokers.get(<span class=\"number\">0</span>),invokers.get(<span class=\"number\">1</span>),invocation);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">pos1</span> <span class=\"operator\">=</span> ThreadLocalRandom.current().nextInt(length);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">pos2</span> <span class=\"operator\">=</span> ThreadLocalRandom.current().nextInt(length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pos2 &gt;= pos1) &#123;</span><br><span class=\"line\">        pos2 = pos2 + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> chooseLowLoadInvoker(invokers.get(pos1),invokers.get(pos2),invocation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Q：为什么 pos2 要从 [0, len - 1] 取随机数呢？</p>\n<p>A：避免 pos1 和 pos2 相等时判断边界</p>\n<p>Q：pos2 的取法，不会让最后一个 invoker 被选择的概率小于其他 invoker\n吗？</p>\n<p>A：通过实验验证不会小于其他 invoker</p>\n</blockquote>\n<h3 id=\"adaptive\">Adaptive</h3>\n<p>基于 P2C 思想实现的负载均衡策略</p>\n<ol type=\"1\">\n<li>从备选列表中做两次随机选择，得到 invokerA 和 invokerB</li>\n<li>比较 invokerA 和 invokerB 的负载值，选择较小的那个</li>\n</ol>\n<h3 id=\"自定义策略\">自定义策略</h3>\n<p>继承 AbstractLoadBalance，实现 doSelect 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyLoadBalance</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractLoadBalance</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">NAME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;my_random&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class=\"title function_\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; invokers.size(); i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;MyLoadBalance invoker: &quot;</span> + invokers.get(i));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;MyLoadBalance invoker ip: &quot;</span> + invokers.get(i).getUrl().getIp());</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> url.getParameter(<span class=\"string\">&quot;index&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Strings.isNotBlank(index)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Integer.valueOf(i).equals(Integer.valueOf(index))) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invokers.get(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"不同策略的比较\">不同策略的比较</h2>\n<table>\n<colgroup>\n<col style=\"width: 15%\">\n<col style=\"width: 27%\">\n<col style=\"width: 33%\">\n<col style=\"width: 23%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>策略</th>\n<th>特点</th>\n<th>缺点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>Random 随机</td>\n<td>静态、公平、稳定</td>\n<td>短时间内不同服务间存在一定差异</td>\n<td>服务端处理能力相同、稳定性高</td>\n</tr>\n<tr class=\"even\">\n<td>weighted Random 加权随机</td>\n<td>静态、公平、稳定</td>\n<td>需要维护机器性能的权重比例</td>\n<td>服务端处理能力不同、稳定性高</td>\n</tr>\n<tr class=\"odd\">\n<td>roundRobin 轮询</td>\n<td>静态、公平、稳定</td>\n<td></td>\n<td>服务端处理能力相同、稳定性高</td>\n</tr>\n<tr class=\"even\">\n<td>weighted roundRobin 加权轮询</td>\n<td>静态、公平、稳定</td>\n<td>需要维护机器性能的权重比例</td>\n<td>服务端处理能力不同、稳定性高</td>\n</tr>\n<tr class=\"odd\">\n<td>leastActive 最少链接数</td>\n<td>动态</td>\n<td>最小链接的服务不一定可以代表服务的吞吐能力</td>\n<td>服务端处理能力有波动</td>\n</tr>\n<tr class=\"even\">\n<td>最快响应</td>\n<td>动态，更加关注响应速度</td>\n<td>大多数情况下，不同 provider\n的响应时间没有明显区别，导致退化为随机选择</td>\n<td>服务端处理能力有波动</td>\n</tr>\n<tr class=\"odd\">\n<td>固定哈希</td>\n<td>稳定</td>\n<td>由客户端决定分布，可能分布不均</td>\n<td>确定的入参，确定的提供者，适用于有状态请求</td>\n</tr>\n<tr class=\"even\">\n<td>P2C</td>\n<td>随机选择两个节点后，继续选择\"连接数\"较小的那个节点</td>\n<td></td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td>自适应</td>\n<td>随机选择两个节点后，继续选择\"负载\"较小的那个节点</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"https://heapdump.cn/article/6236723\">一种自适应的负载均衡</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/592033102?utm_id=0\">常用负载均衡及策略图解</a></p>\n<p><a href=\"https://www.zhihu.com/tardis/bd/art/653067090?source_id=1001\">NGINX:\n轮询调度、加权轮询调度、平滑加权轮询调度</a></p>\n<p><a href=\"https://www.jianshu.com/p/d15fa78c645a\">dubbo负载均衡之随机负载均衡</a></p>\n","categories":["dubbo"],"tags":["load-balance"]},{"title":"服务限流 原理与实现","url":"/2023/11/23/dubbo/dubbo-rate-limit/","content":"<blockquote>\n<p>本文简述限流的原理，代码走读分享</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"常见的限流算法\">常见的限流算法</h2>\n<p>给定单位时间 T（统一设为1s）内的最大访问量\nMR，下面讨论几种限流算法</p>\n<h3 id=\"不平滑的限流算法\">不平滑的限流算法</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> AtomicInteger count;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Long nextTime;    </span><br><span class=\"line\"><span class=\"keyword\">private</span> Long maxReqNum;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">limit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now &gt; nextTime) &#123;</span><br><span class=\"line\">        count = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        nextTime = now + <span class=\"number\">1000</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> count.incrementAndGet();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num &gt; maxReqNum) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol type=\"1\">\n<li>单位时间 T 内维护计数器 count</li>\n<li>当请求到达时，判断时间是否进入下一个单位时间</li>\n<li>如果是，重置 count = 1</li>\n<li>如果不是，count++，判断 count 是否超过最大访问量\nMR，如果超过，则拒绝访问</li>\n</ol>\n<p>不平滑的限流算法在两个单位时间的临界值上可能失效，如下图，在每个 T\n内可以满足 MR &lt;= 3，但在临界的 T 内存在 MR = 5</p>\n<figure>\n<img src=\"/images/dubbo/不平滑限流器.drawio.png\" alt=\"不平滑限流器.drawio\">\n<figcaption aria-hidden=\"true\">不平滑限流器.drawio</figcaption>\n</figure>\n<h3 id=\"漏桶\">漏桶</h3>\n<p>漏桶算法思路是先将请求进入到桶内，漏桶以固定的速度出水，出水意味着处理请求，如果桶已满，则水会溢出，也就是拒绝请求。漏桶可以控制请求的处理速率</p>\n<p>漏桶不能处理突发请求，比如 MR = 1000，T 时刻我们希望处理 1000\n条请求，漏桶会把这 1000 个请求平铺在 1 秒内处理完，而不会在 T\n时刻同时处理这 1000 个请求</p>\n<h3 id=\"令牌桶\">令牌桶</h3>\n<p>令牌桶以恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。相比于漏桶，令牌桶允许处理突发请求</p>\n<h5 id=\"如何实现\">如何实现</h5>\n<blockquote>\n<p>我的思路：设一个计数器 count\n表示桶容积，是写一个线程向一个桶里循环的放令牌（count++），每次 sleep\n1000/限流值 ms，当有请求来的时候 count--</p>\n<p>看起来是很直观的方法，但是存在两个严重的问题：</p>\n<ol type=\"1\">\n<li>如果有多个接口都要限流，要有多个限流桶，也就有多个线程在一直运行</li>\n<li>为了处理同时投放和取令牌的场景，每次放/取令牌都要抢锁/加锁</li>\n</ol>\n<p>显然这个方案是不行的，下面看下 guava\n的实现方式（guava:23.0），大致思路是：请求时再取令牌+放令牌</p>\n</blockquote>\n<p>guava 的实现，分为 SmoothBurstry 和 SmoothWarmingUp</p>\n<h4 id=\"smoothburstry\">SmoothBurstry</h4>\n<h6 id=\"创建令牌桶\">创建令牌桶</h6>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个令牌桶，每秒投放 premitsPerSecond 个令牌</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RateLimiter <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"type\">double</span> permitsPerSecond)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@VisibleForTesting</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> RateLimiter <span class=\"title function_\">create</span><span class=\"params\">(<span class=\"type\">double</span> permitsPerSecond, SleepingStopwatch stopwatch)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">RateLimiter</span> <span class=\"variable\">rateLimiter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmoothBursty</span>(stopwatch, <span class=\"number\">1.0</span> <span class=\"comment\">/* maxBurstSeconds */</span>);</span><br><span class=\"line\">    rateLimiter.setRate(permitsPerSecond);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rateLimiter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>maxBurstSeconds：最多存储多少秒的令牌，默认值为1s</p>\n<p>permitsPerSecond：每秒生产的令牌数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setRate</span><span class=\"params\">(<span class=\"type\">double</span> permitsPerSecond)</span> &#123;</span><br><span class=\"line\">    checkArgument(</span><br><span class=\"line\">        permitsPerSecond &gt; <span class=\"number\">0.0</span> &amp;&amp; !Double.isNaN(permitsPerSecond), <span class=\"string\">&quot;rate must be positive&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mutex()) &#123;</span><br><span class=\"line\">    \t  doSetRate(permitsPerSecond, stopwatch.readMicros());</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置限流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSetRate</span><span class=\"params\">(<span class=\"type\">double</span> permitsPerSecond, <span class=\"type\">long</span> nowMicros)</span> &#123;</span><br><span class=\"line\">    resync(nowMicros);</span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">stableIntervalMicros</span> <span class=\"operator\">=</span> SECONDS.toMicros(<span class=\"number\">1L</span>) / permitsPerSecond;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class=\"line\">    doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>stableIntervalMicros：生产一个令牌的毫秒数</p>\n<p>重新计算桶内令牌数、下一次可以取令牌时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">coolDownIntervalMicros</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> stableIntervalMicros;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">resync</span><span class=\"params\">(<span class=\"type\">long</span> nowMicros)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// if nextFreeTicket is in the past, resync to now</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class=\"line\">      \t<span class=\"type\">double</span> <span class=\"variable\">newPermits</span> <span class=\"operator\">=</span> (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class=\"line\">      \tstoredPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class=\"line\">      \tnextFreeTicketMicros = nowMicros;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>nowMicros：当前时间戳（毫秒）</p>\n<p>nextFreeTicketMicros：下一次可以取令牌的时间戳</p>\n<p>newPermits：新产生的令牌数</p>\n<p>maxPermits：最大容积（也就是1秒产生的令牌数）</p>\n<p>storedPermit：桶内的令牌数</p>\n<p><strong>设置最大容积和已有令牌数</strong></p>\n<p>第一次创建或修改限流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doSetRate</span><span class=\"params\">(<span class=\"type\">double</span> permitsPerSecond, <span class=\"type\">double</span> stableIntervalMicros)</span> &#123;</span><br><span class=\"line\">  \t<span class=\"type\">double</span> <span class=\"variable\">oldMaxPermits</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.maxPermits;</span><br><span class=\"line\">  \tmaxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class=\"line\">  \t<span class=\"keyword\">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class=\"line\">    \t\t<span class=\"comment\">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class=\"line\">    \t\tstoredPermits = maxPermits;</span><br><span class=\"line\">  \t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// oldMaxPermits 为 0，说明第一次创建，storedPermits = 0</span></span><br><span class=\"line\">      \t<span class=\"comment\">// oldMaxPermit 不为 0，说明已创建过，本次是修改限流，做等比例缩放</span></span><br><span class=\"line\">    \t\tstoredPermits =</span><br><span class=\"line\">        \t\t(oldMaxPermits == <span class=\"number\">0.0</span>)</span><br><span class=\"line\">    \t\t\t\t\t\t? <span class=\"number\">0.0</span> <span class=\"comment\">// initial state</span></span><br><span class=\"line\">            \t\t\t\t: storedPermits * maxPermits / oldMaxPermits;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>oldMaxPermits：之前的容积</p>\n<p>maxBurstSeconds：装满令牌桶需要的时间（秒）</p>\n<h6 id=\"从令牌桶里取令牌\">从令牌桶里取令牌</h6>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通常取一个令牌</span></span><br><span class=\"line\"><span class=\"meta\">@CanIgnoreReturnValue</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">acquire</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * permits: 要取的令牌数，通常为 1</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值：0 表示不限流，非0 表示等待的时长（毫秒）</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"meta\">@CanIgnoreReturnValue</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">acquire</span><span class=\"params\">(<span class=\"type\">int</span> <span class=\"keyword\">permits</span>)</span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 预约，如果当前不能直接获取到 permits，需要等待</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">microsToWait</span> <span class=\"operator\">=</span> reserve(<span class=\"keyword\">permits</span>);</span><br><span class=\"line\">  \t<span class=\"comment\">// sleep 阻塞</span></span><br><span class=\"line\">    stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class=\"line\">  \t<span class=\"comment\">// 返回 sleep 的时长</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1.0</span> * microsToWait / SECONDS.toMicros(<span class=\"number\">1L</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>计算取到下一个令牌需要的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 预约 permits（通常为1）个令牌需要的时间</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"title function_\">reserve</span><span class=\"params\">(<span class=\"type\">int</span> <span class=\"keyword\">permits</span>)</span> &#123;</span><br><span class=\"line\">    checkPermits(<span class=\"keyword\">permits</span>);</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mutex()) &#123;</span><br><span class=\"line\">\t      <span class=\"keyword\">return</span> reserveAndGetWaitLength(<span class=\"keyword\">permits</span>, stopwatch.readMicros());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"title function_\">reserveAndGetWaitLength</span><span class=\"params\">(<span class=\"type\">int</span> <span class=\"keyword\">permits</span>, <span class=\"type\">long</span> nowMicros)</span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 可获取令牌的时间</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">momentAvailable</span> <span class=\"operator\">=</span> reserveEarliestAvailable(<span class=\"keyword\">permits</span>, nowMicros);</span><br><span class=\"line\">  \t<span class=\"comment\">// 还需等待的时间，0 表示不需等待</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(momentAvailable - nowMicros, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"title function_\">reserveEarliestAvailable</span><span class=\"params\">(<span class=\"type\">int</span> requiredPermits, <span class=\"type\">long</span> nowMicros)</span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 更新 storedPermits</span></span><br><span class=\"line\">    resync(nowMicros);</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">returnValue</span> <span class=\"operator\">=</span> nextFreeTicketMicros;</span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">storedPermitsToSpend</span> <span class=\"operator\">=</span> min(requiredPermits, <span class=\"built_in\">this</span>.storedPermits);</span><br><span class=\"line\">  \t<span class=\"comment\">// 桶内令牌不足时，还需要添加的令牌数</span></span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">freshPermits</span> <span class=\"operator\">=</span> requiredPermits - storedPermitsToSpend;</span><br><span class=\"line\">  \t<span class=\"comment\">// 计算需要等待的时间，storedPermitsToWaitTime 在 SmoothBursty 中恒为 0，在 SmoothWarmingUp 有其他实现</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">waitMicros</span> <span class=\"operator\">=</span></span><br><span class=\"line\">        storedPermitsToWaitTime(<span class=\"built_in\">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class=\"line\">            + (<span class=\"type\">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算下一次发令牌的时间</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class=\"line\">  \t<span class=\"comment\">// 更新桶内令牌数</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> returnValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">storedPermitsToWaitTime</span><span class=\"params\">(<span class=\"type\">double</span> storedPermits, <span class=\"type\">double</span> permitsToTake)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0L</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本次不管 storedPermits 够不够，返回的是 nextFreeTicketMicros\n的旧值，当次的 acquire 是可以成功取到令牌的，如果 storedPermit 不够，将\nnextFreeTicketMicros 往后推一段时间</p>\n<p>SmoothBursty 可以处理突发请求，它会缓存最多 1 秒的 permits</p>\n<h4 id=\"smoothwarmingup\">SmoothWarmingUp</h4>\n<p>SmoothWarmingUp\n适用于资源需要预热的场景，比如我们的某个接口业务，需要使用到线程池、数据库连接、缓存，如果我们的系统刚启动，池子中的线程还没有创建，或者长时间处于低负载或零负载状态，线程被慢慢释放掉了，此时池子是冷的，如果此时有大量请求，线程池需要瞬间创建大量的线程，可能会导致系统负载过高甚至压垮系统</p>\n<blockquote>\n<p>这里导致系统负载高的原因，不是由于请求太大线程池处理不过来，线程池处理不过来可以进等待队列或者直接丢弃，这个过程不会消耗什么资源</p>\n</blockquote>\n<p>所以线程池是冷的，我们不能让大流量都进入线程池，要给线程池一个预热过程</p>\n<p>在 SmoothBurstry 中，由于桶里已经有1秒的\npermits，突发请求会直接通过，不给预热的时间；在 SmoothWarmingUp\n中，取令牌需要耗时的，这样对取令牌的速度进行控制</p>\n<p>在下图中，X 轴代表 storedPermits，Y 轴代表获取一个 permit\n需要的时间（在令牌足够的情况下），storedPermits\n越大，代表越冷，获取令牌耗时越多</p>\n<figure>\n<img src=\"/images/dubbo/smooth-warm-up.png\" alt=\"smooth-warm-up\">\n<figcaption aria-hidden=\"true\">smooth-warm-up</figcaption>\n</figure>\n<p>如图分析三种场景：</p>\n<ol type=\"1\">\n<li>系统繁忙时，storedPermits &lt;= thresholdPermits，需要的时间为\nstable interval，最短时间</li>\n<li>系统空闲时，storedPermits = maxPermits，需要时间为 Cold\ninterval，最大时间</li>\n<li>系统预热过程中，thresholdPermit &lt; storedPermits &lt;\nmaxPermits，需要时间在 stable interval 到 cold interval 之间</li>\n</ol>\n<p>图片引用于 https://www.javadoop.com/post/rate-limiter</p>\n<p><strong>参数值设定</strong></p>\n<p>直接介绍下代码中给出的参数值，设长方形面积（RS） = stableInterval *\nthresholdPermits，梯形面积（TS） = (stableInteval + coldInteval) *\n(maxPermits - thresholdPermits) / 2，coldInteval = stableInterval *\ncoldFactor，其中 coldFactor 为常数 3</p>\n<p>有关系如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">TS = <span class=\"number\">2</span> * RS;</span><br><span class=\"line\">thresholdPermits = TS * <span class=\"number\">0.5</span> / stableInterval;</span><br><span class=\"line\">maxPermits = <span class=\"number\">2</span> * RS / (stableInterval + coldInteval) + thresholdPermits;</span><br></pre></td></tr></table></figure>\n<h5 id=\"如何实现-1\">如何实现</h5>\n<p>只看下和 SmoothBurstry 差异的地方</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">doSetRate</span><span class=\"params\">(<span class=\"type\">double</span> permitsPerSecond, <span class=\"type\">double</span> stableIntervalMicros)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">oldMaxPermits</span> <span class=\"operator\">=</span> maxPermits;</span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">coldIntervalMicros</span> <span class=\"operator\">=</span> stableIntervalMicros * coldFactor;</span><br><span class=\"line\">    thresholdPermits = <span class=\"number\">0.5</span> * warmupPeriodMicros / stableIntervalMicros;</span><br><span class=\"line\">    maxPermits =</span><br><span class=\"line\">        thresholdPermits + <span class=\"number\">2.0</span> * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);</span><br><span class=\"line\">  \t<span class=\"comment\">// 梯形边的斜率</span></span><br><span class=\"line\">    slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits - thresholdPermits);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class=\"line\">    \t  <span class=\"comment\">// if we don&#x27;t special-case this, we would get storedPermits == NaN, below</span></span><br><span class=\"line\">        storedPermits = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        storedPermits =</span><br><span class=\"line\">            (oldMaxPermits == <span class=\"number\">0.0</span>)</span><br><span class=\"line\">                ? maxPermits <span class=\"comment\">// initial state is cold</span></span><br><span class=\"line\">                : storedPermits * maxPermits / oldMaxPermits;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>计算取令牌需要等待的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">storedPermitsToWaitTime</span><span class=\"params\">(<span class=\"type\">double</span> storedPermits, <span class=\"type\">double</span> permitsToTake)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">availablePermitsAboveThreshold</span> <span class=\"operator\">=</span> storedPermits - thresholdPermits;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">micros</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// measuring the integral on the right part of the function (the climbing line)</span></span><br><span class=\"line\">  \t<span class=\"comment\">// 大于 thresholdPermits，需要预热，计算梯形面积</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (availablePermitsAboveThreshold &gt; <span class=\"number\">0.0</span>) &#123;</span><br><span class=\"line\">      \t<span class=\"type\">double</span> <span class=\"variable\">permitsAboveThresholdToTake</span> <span class=\"operator\">=</span> min(availablePermitsAboveThreshold, permitsToTake);</span><br><span class=\"line\">        <span class=\"comment\">// TODO(cpovirk): Figure out a good name for this variable.</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> permitsToTime(availablePermitsAboveThreshold)</span><br><span class=\"line\">                + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);</span><br><span class=\"line\">      \t<span class=\"comment\">// 梯形面积</span></span><br><span class=\"line\">        micros = (<span class=\"type\">long</span>) (permitsAboveThresholdToTake * length / <span class=\"number\">2.0</span>);</span><br><span class=\"line\">      \t<span class=\"comment\">// 矩形x轴边长</span></span><br><span class=\"line\">        permitsToTake -= permitsAboveThresholdToTake;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// measuring the integral on the left part of the function (the horizontal line)</span></span><br><span class=\"line\">  \t<span class=\"comment\">// 总时间 = 梯形面积 + 矩形面积</span></span><br><span class=\"line\">    micros += (stableIntervalMicros * permitsToTake);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> micros;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其他流程与 SmoothBurstry 相同</p>\n<p>由于 SmoothWarmingUp\n每次取令牌都有等待时间，会让每个请求之间保持一段时间，所以\nSmoothWarmingUp 可以看作漏桶</p>\n<h2 id=\"sentinel\">Sentinel</h2>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/165006444\">流量控制算法——漏桶算法和令牌桶算法</a></p>\n<p><a href=\"https://www.javadoop.com/post/rate-limiter\">限流-RateLimiter\n源码分析 (Guava 和 Sentinel 实现)</a></p>\n","categories":["dubbo"],"tags":["dubbo"]},{"title":"全链路透传参数","url":"/2023/12/30/dubbo/add-user-param/","content":"<blockquote>\n<p>本文介绍在全链路透传参数场景的解决思路和方案</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"链路中透传参数的任务\">链路中透传参数的任务</h2>\n<p>有一天，用户网关的同学拉小明说：网关今后会在 http\n请求头中加一些用户信息，可以从 Header\n中获取，要求小明把这些信息传给下游；于是小明发起了一个全体大会，同步了这个消息，有的下游使用\nhttp 协议，小明把 Header\n带下去，并要求他们也要带下去，这些人感觉工作量还好，点点头离开了；有的下游使用\ndubbo 协议，他们要求小明更新 dubbo\n包，把网关参数加进去，这样他们才能拿到网关参数；好在有一个 base\n请求体，所有的请求类都继承了它，小明可以直接在 base\n类加这些参数，并在所有的方法中 set\n了网关参数；发布后，小明让下游开始传递，所有的服务都开始了传递参数的工作......</p>\n<p>在集合大联调时，有个老哥发现没有传下来，就开始问上游，是不是忘传了，上游说我传了呀，我给你问问上游，于是开始了漫长的向上排查</p>\n<p>对于这个场景，你有什么好的解决方案吗？</p>\n","categories":["dubbo"],"tags":["链路追踪"]},{"title":"Shaun JM 的 2023 年度总结","url":"/2024/01/06/diary/2023-persional-summary/","content":"<blockquote>\n<p>2023 年度个人总结</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>2023\n年的工作强度和压力都很大，单调且枯燥，每天盼着下班，庆幸着又熬过了一天。回顾这一年，总结出\n2023 年的关键词，大概有：挣扎、坚持、追找方向</p>\n<h2 id=\"年总结\">23 年总结</h2>\n<h3 id=\"挣扎\">挣扎</h3>\n<p>工作占据了2023年绝大多数时间，我一直努力让自己不犯错，没有想着把业务做的多好，缺乏激情和斗志。虽然逐渐习惯了快速的工作节奏，上线压力，不断的告警电话，但是这种无限的重复，导致身心比较疲惫，也经常让我怀疑工作的意义</p>\n<p>从经济角度看，2023年的主要收入和支出分布如下</p>\n<figure>\n<img src=\"/images/diary/image-20240106122507860.png\" alt=\"image-20240106122507860\">\n<figcaption aria-hidden=\"true\">image-20240106122507860</figcaption>\n</figure>\n<p>从工作内容上看，2023年主要是积累业务经验，技术上收获不多</p>\n<h3 id=\"坚持\">坚持</h3>\n<p>利用好碎片化时间，养成一个习惯，每天用很短的时间，坚持做一件事情，是\n2023 年一直在尝试的事情，也是 2024\n年要继续坚持的事情。这样可以工作之余，做一些自己的事情</p>\n<p><strong>第一点</strong></p>\n<p>在地铁上背单词。在百词斩上每天上班的地铁和道路上，背10个单词，如今已经背过\n2000\n多个单词，有多少比例的单词可以记住，我不好说，不过这更是一种习惯的养成</p>\n<figure>\n<img src=\"/images/diary/image-20240101201820575.png\" alt=\"image-20240101201820575\">\n<figcaption aria-hidden=\"true\">image-20240101201820575</figcaption>\n</figure>\n<p><strong>第二点</strong></p>\n<p>坚持每周六练琴，2023 年一共练成并发布6首曲子：</p>\n<table>\n<colgroup>\n<col style=\"width: 13%\">\n<col style=\"width: 86%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>时间</th>\n<th>曲目</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>2023-12-2</td>\n<td><a href=\"https://www.bilibili.com/video/BV1vN411L7Ho/?spm_id_from=333.999.0.0\">匈牙利舞曲第五号</a></td>\n</tr>\n<tr class=\"even\">\n<td>2023-9-23</td>\n<td><a href=\"https://www.bilibili.com/video/BV19m4y157fX/?spm_id_from=333.999.0.0\">一步之遥</a></td>\n</tr>\n<tr class=\"odd\">\n<td>2023-9-9</td>\n<td><a href=\"https://www.bilibili.com/video/BV1nw411v7va/?spm_id_from=333.999.0.0\">爱乐之城</a></td>\n</tr>\n<tr class=\"even\">\n<td>2023-4-5</td>\n<td><a href=\"https://www.bilibili.com/video/BV1um4y167qb/?spm_id_from=333.999.0.0\">那些年</a></td>\n</tr>\n<tr class=\"odd\">\n<td>2023-3-23</td>\n<td><a href=\"https://www.bilibili.com/video/BV13V4y1X7Ng/?spm_id_from=333.999.0.0\">成都</a></td>\n</tr>\n<tr class=\"even\">\n<td>2023-2-4</td>\n<td><a href=\"https://www.bilibili.com/video/BV1Fy4y197Ju/?spm_id_from=333.999.0.0\">月亮河</a></td>\n</tr>\n</tbody>\n</table>\n<p>每周六坚持1-2个小时，难度很大，需要更多的耐心，很容易放弃，唯有热爱~</p>\n<p><strong>第三点</strong></p>\n<p>坚持写技术博客。在 2023\n年之前，工作分配的技术分享，我都写不出什么有质量的内容，没有工作太忙没有时间准备。在\n2023 年里，我能够产出 16 篇技术文章，有几篇质量还是很高的</p>\n<table>\n<colgroup>\n<col style=\"width: 14%\">\n<col style=\"width: 85%\">\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>时间</th>\n<th>文章</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>2023.01.01</td>\n<td><a href=\"https://shaun2016.github.io/2022/12/31/jvm/jvm-gc/\">JVM篇\n垃圾收集</a></td>\n</tr>\n<tr class=\"even\">\n<td>2023.02.02</td>\n<td><a href=\"https://shaun2016.github.io/2023/02/02/computer-organization/cpu-memory-visibility/\">硬件层面多\nCPU 下的可见性问题</a></td>\n</tr>\n<tr class=\"odd\">\n<td>2023.03.25</td>\n<td><a href=\"https://shaun2016.github.io/2023/03/25/java/java-reflect/\">java\n反射机制与代码走读</a></td>\n</tr>\n</tbody>\n</table>\n<p>这些博客无法集中时间完成，都是每天在公司空闲时间或者下班时间，写一段，写一行，或者画一个图，在写的过程中不断发现问题，寻找答案，最终整合成一篇文章。这个过程提高了自学能力，和时间管理能力，当遇到一个很感兴趣的点，到了工作时间，就要切断思路回到工作中，需要把一件事情拆的很细很碎</p>\n<h3 id=\"追找方向\">追找方向</h3>\n<p>人生所做的大多数事情，概况的说是在追求自己想要的生活，前提是想清楚自己想要什么样的生活</p>\n<p>目前还处于迷茫期，感觉缺少努力的方向和动力，但 2023\n年还是有思考和尝试，比如参加了一次相亲，和一些朋友了解不同国家、不同城市、不同工作的生活状态，调研了一种移民方案和可行性；一时的迷茫是正常的，重要的是不断思考和更新认知</p>\n<h2 id=\"新年期望\">新年期望</h2>\n<p>2024年，希望把喜欢做的事情坚持下去，能够更好的利用好琐碎的时间，努力完成以下几个目标：</p>\n<ol type=\"1\">\n<li>阅读理想国，思考什么是快乐，如何让生活快乐</li>\n<li>继续思考自己想要什么样的生活</li>\n<li>坚持练琴和写博客</li>\n</ol>\n","categories":["personal"],"tags":["personal"]}]